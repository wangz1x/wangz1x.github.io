<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>笔记本安装SSD, 并在SSD中安装系统</title>
    <url>/2018/05/02/ssd/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很早就想买个ssd了，经过一些事情之后，我也没那么多顾虑，想买就买了。本来打算是在ssd中重装一个系统的，但是后来考虑到电脑里边有些东西重装系统后再搞很麻烦，就没有选择重装系统了，但是突然想试试Linux，就选了Ubuntu，安在了ssd里边，把电脑搞成双系统，所以这篇文章有这几个部分吧：笔记本安装ssd、安装Ubuntu系统、笔记本实现双系统。</p>
<span id="more"></span>

<h3 id="笔记本装ssd"><a href="#笔记本装ssd" class="headerlink" title="笔记本装ssd"></a>笔记本装ssd</h3><p>我的笔记本没有空出的位置装ssd，所以就把光驱拆了，买ssd时候把电脑型号发给客服，客服会告诉你用什么规格的支架。然后就是拆光驱，把ssd放进支架里，在把支架安在原来放光驱的地方，挺简单的。</p>
<p>对了，还有关于笔记本是否能发挥ssd性能的几个小点，首先是接口，就是光驱那个接口最好是sata3接口的; 然后是bios里有个地方IDE要设置成 AHCI模式。</p>
<p>装好之后可以下载一些测试工具，这里我忘了我用的啥了，查一下就知道。</p>
<h3 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h3><p>我用的是u盘作为启动盘，所以这里就讲讲这种方式。</p>
<p>首先下载ubuntu系统iso， 然后用UltraISO制作启动盘，制作好后，保持u盘插入的状态，重启电脑，这时候要进入BIOS系统(具体按哪个键可以搜一下，我的华硕是F2)，在BIOS中更改启动盘，选择刚刚的u盘，应该会有名字的。</p>
<p>启动之后应该就是安装的界面了，具体安装过程怎么选择我也忘了，这里没有截图，捡我记得的写。我在安装过程中，提示过我一个东西，好像是有个格式不对，我选择的跳过还是什么的，反正不是确认。我那时候出现这个问题，就去google了，说是启动盘要用一个别的软件做才行，然后我信了他的邪，重新一边还是这样。后边再有印象的就是分区了。</p>
<p>首先说明一点，分区分区，分的是你电脑里，没有进行过初始化的区域，当你的ssd刚安电脑里的时候，你用硬盘管理看到这块磁盘是未分配状态的，那么在安装系统过程中就会使用这些未分配的区域。</p>
<p>Linux分区，应该是安装系统中比较重要的一点？我也是按照网上的一般教程进行分区的，分了四个区: &#x2F;, &#x2F;boot, &#x2F;home, &#x2F;swap， 另外在分区时，需要注意的是swap分区需要选择”交换空间”，其他三个就按默认的Ext4日志文件系统。在说一下这四个分区的含义：&#x2F;，主分区相当于windows的c盘;  &#x2F;boot 引导分区;  &#x2F;home 用户存储数据用，需要大一点;  &#x2F;swap 相当于电脑的内存，设置为内存的1.5～2倍。分区设置完毕后，下方还有一项“安装启动引导器的设备”，默认是ubuntu引导windows，也就是开机启动显示的ubuntu的样子，然后选择是ubuntu还是window，如果想windows引导ubuntu，则“引导器的设备”选择之前&#x2F;boot分区的名字。</p>
<h3 id="实现双系统"><a href="#实现双系统" class="headerlink" title="实现双系统"></a>实现双系统</h3><p>前面的说明了，我是从windows引导ubuntu的，所以还需要一些工具来设置ubuntu的启动选项，这里我用的是EasyBCD，打开easyBCD，选择add new entry，选择linux&#x2F;BSD，name那里填Ubuntu（可自行填写）。device(驱动器)这一栏选择我们刚创建的“&#x2F;boot”分区（200MB那个，可能大小会有一点出入）。最后点击Add entry（添加条目）。最后还有一点可能会出错的地方，就是设置了引导后，选择ubuntu却无法正常启动，具体原因我不记得了，应该是在新建ubuntu条目时有个选项有问题，具体是什么，我后面在看看。</p>
<p>好了，大概就是这样了，有很多东西没有讲清楚，因为google一下总会有讲的清楚的，我在这里也只是理了一下我做这些事情的一个过程，就是一个简单的思路。</p>
]]></content>
      <tags>
        <tag>ssd</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX下配置环境变量</title>
    <url>/2018/05/21/linux_env/</url>
    <content><![CDATA[<p>有些东西不自己写一下，总是会忘记，当然写了也可能还是会忘，但是找起来印象会深一点吧。之前在需要配置环境变量的时候就直接查了一下，完成配置后就没管了，最近再次想到这个问题，结果已经忘记该怎么配置了。所以什么东西都是写一下比较好吧.</p>
<span id="more"></span>

<h3 id="方式一：使用export"><a href="#方式一：使用export" class="headerlink" title="方式一：使用export"></a>方式一：使用export</h3><p>使用export命令直接修改PATH变量<br><img src="/fig1.png" alt="enter description here"></p>
<h3 id="方式二：修改-x2F-etc-x2F-profile"><a href="#方式二：修改-x2F-etc-x2F-profile" class="headerlink" title="方式二：修改&#x2F;etc&#x2F;profile"></a>方式二：修改&#x2F;etc&#x2F;profile</h3><p><img src="/fig2.png" alt="enter description here"></p>
<p>如果要立即生效需要执行命令</p>
<p>source &#x2F;etc&#x2F;profile</p>
<p>使用这种方式，所有用户都会受影响,当第一个用户登录时,该文件被执行.</p>
<p>类似的还有&#x2F;etc&#x2F;enviroment文件，影响所有用户</p>
<h3 id="方式三：修改-x2F-bashrc"><a href="#方式三：修改-x2F-bashrc" class="headerlink" title="方式三：修改~&#x2F;.bashrc"></a>方式三：修改~&#x2F;.bashrc</h3><p><img src="/fig3.png" alt="enter description here"></p>
<p>同样立即生效需要：</p>
<p>source ~&#x2F;.bashrc</p>
<p>专属于个人bash shell的信息，当该用户登录时以及每次打开新的shell时,该文件被读取.</p>
<p>类似的还有~&#x2F;.profile，当用户登录时,该文件仅仅执行一次!默认情况下,它设置一些环境变量,然后执行用户的.bashrc文件.</p>
]]></content>
      <tags>
        <tag>path</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git push的完整形式</title>
    <url>/2018/05/24/git_push/</url>
    <content><![CDATA[<p>现在的情况是，本地有两个分支：master、div， 远程仓库有一个分支：master，本地master分支和远程master分支建立有跟踪联系，这样本地master分支提交时直接git push(只有一个远程仓库的情况下)</p>
<span id="more"></span>

<p><img src="/fig1.png" alt="enter description here"></p>
<p>那么div分支也想提交到远程master怎么办呢，先试试直接git push：<br><img src="/fig2.png" alt="enter description here"><br>提示信息很清楚了</p>
<p>这里使用命令  git push origin HEAD:master 即可</p>
<p>而HEAD指向的是当前的分支，git可以通过HEAD找到当前的分支名，所以该命令相当于 git push origin div:master</p>
<p>&#x3D;&#x3D;git push&#x2F;pull &lt;远程主机名&gt; &lt;源分支&gt;:&lt;目的分支&gt;&#x3D;&#x3D; 是git push常用的精简命令的完整格式，当然还可以加git push的各种 [<options>]，这里就不说了。</p>
<p>说实话，我平时只顾着用git push ，连git push不省略的格式是什么都不记得了，唉.</p>
<p>2018.06.20 更新</p>
<p>在推送前，我们可以使用命令 git push -u &lt;远程主机名&gt; &lt;分支名&gt;</p>
<p>其中-u 参数效果：如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push.</p>
<p>–set-upstream 是用来和远程分支建立追踪关系<br><img src="/fig3.png" alt="enter description here"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX下的JOB, FG, BG, &amp;</title>
    <url>/2018/06/12/job/</url>
    <content><![CDATA[<p>在使用linux过程中，偶尔会不自觉的按ctrl + z，这时候会显示[1]+ Stopped 之类的，而且如果这时候你在做一些操作，比如编辑文件等，会直接回到命令状态。那么之前的工作去哪了呢?</p>
<span id="more"></span>

<p>去了Stopped于后台中了。</p>
<p>这是输入jobs命令，就可以查看Linux中的任务列表及任务状态，包括后台运行的任务。</p>
<p>bg(background) 将后台暂停的任务启动，在后台继续运行</p>
<p>fg(foreground) 将后台任务调至前台执行</p>
<p>&amp; 放在命令的最后，用于将任务放在后台执行</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bg</tag>
        <tag>fg</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone branch</title>
    <url>/2018/06/20/git_clone/</url>
    <content><![CDATA[<p>在使用git clone项目后，查看本地分支，只有master分支，远程仓库的其他分支并没有克隆下来，如果需要其他分支可以用下面两种方法</p>
<span id="more"></span>

<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><code>git branch -a</code> 先查看当前远端分支情况</p>
<p><code>git checkout origin/xxx</code>  选择远端xxx分支</p>
<p><code>git branch xxx</code>  创建本地xxx分支</p>
<p><code>git checkout xxx</code>  选择新创建的分支就可以了</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><code>git clone -b &lt;branch-name&gt; &lt;remote&gt;</code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>netstat 命令</title>
    <url>/2018/06/22/netstat/</url>
    <content><![CDATA[<blockquote>
<p>Print network connections, routing tables, interface statistics,<br>masquerade connections, and multicast memberships</p>
</blockquote>
<p>netstat用来显示网络相关的信息，如网络连接，路由表，接口统计，伪装链接和广播成员</p>
<span id="more"></span>
<h3 id="常用的几个选项"><a href="#常用的几个选项" class="headerlink" title="常用的几个选项"></a>常用的几个选项</h3><blockquote>
<p>–numeric , -n Show numerical addresses instead of trying to determine<br>symbolic host,port or user names.</p>
</blockquote>
<p>不解析名称，显示数字就行</p>
<blockquote>
<p>-p, –program Show the PID and name of the program to which each socket belongs.</p>
</blockquote>
<p>显示端口(?)所属的程序的pid和名字</p>
<blockquote>
<p>-l, –listening Show only listening sockets. (These are omitted by default.)</p>
</blockquote>
<p>只显示正在监听的端口</p>
<blockquote>
<p>{-t|–tcp} {-u|–udp}</p>
</blockquote>
<p>分别表示显示TCP&#x2F;UDP传输协议的连接</p>
<h3 id="一些在我看来很高级的用法："><a href="#一些在我看来很高级的用法：" class="headerlink" title="一些在我看来很高级的用法："></a>一些在我看来很高级的用法：</h3><h4 id="查看连接某服务端口最多的的IP地址："><a href="#查看连接某服务端口最多的的IP地址：" class="headerlink" title="查看连接某服务端口最多的的IP地址："></a>查看连接某服务端口最多的的IP地址：</h4><blockquote>
<p>netstat -ntu | grep :80 | awk ‘{print $5}’ | cut -d: -f1 | awk<br>‘{++ip[$1]} END {for(i in ip) print ip[i],”\t”,i}’ | sort -nr</p>
</blockquote>
<h4 id="TCP各种状态列表："><a href="#TCP各种状态列表：" class="headerlink" title="TCP各种状态列表："></a>TCP各种状态列表：</h4><blockquote>
<p>netstat -nt | grep -e 127.0.0.1 -e 0.0.0.0 -e ::: -v | awk ‘&#x2F;^tcp&#x2F;<br>{++state[$NF]} END {for(i in state) print i,”\t”,state[i]}’</p>
</blockquote>
<h4 id="查看phpcgi进程数，如果接近预设值，说明不够用，需要增加："><a href="#查看phpcgi进程数，如果接近预设值，说明不够用，需要增加：" class="headerlink" title="查看phpcgi进程数，如果接近预设值，说明不够用，需要增加："></a>查看phpcgi进程数，如果接近预设值，说明不够用，需要增加：</h4><blockquote>
<p>netstat -anpo | grep “php-cgi” | wc -l</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title>error/exception in java</title>
    <url>/2018/06/24/error_exception/</url>
    <content><![CDATA[<h3 id="java异常分为Error和Exception，二者都是继承自Throwable"><a href="#java异常分为Error和Exception，二者都是继承自Throwable" class="headerlink" title="java异常分为Error和Exception，二者都是继承自Throwable"></a>java异常分为Error和Exception，二者都是继承自Throwable</h3><p><img src="/fig1.png" alt="enter description here"></p>
<span id="more"></span>

<h4 id="先来看看Exception："><a href="#先来看看Exception：" class="headerlink" title="先来看看Exception："></a>先来看看Exception：</h4><blockquote>
<p>The class Exception and its subclasses are a form of Throwable that<br>indicates conditions that a reasonable application might want to<br>catch.</p>
</blockquote>
<blockquote>
<p>The class Exception and any subclasses that are not also subclasses of<br>RuntimeException are checked exceptions. Checked exceptions need to be<br>declared in a method or constructor’s throws clause if they can be<br>thrown by the execution of the method or constructor and propagate<br>outside the method or constructor boundary.</p>
</blockquote>
<p>可以知道Exception的子类除了RuntimeException 都是检查型异常，在程序中需要捕获处理或者抛给上层处理。</p>
<h4 id="再看看RuntimeException"><a href="#再看看RuntimeException" class="headerlink" title="再看看RuntimeException"></a>再看看RuntimeException</h4><blockquote>
<p>RuntimeException is the superclass of those exceptions that can be<br>thrown during the normal operation of the Java Virtual Machine.</p>
</blockquote>
<blockquote>
<p>RuntimeException and its subclasses are unchecked exceptions.<br>Unchecked exceptions do not need to be declared in a method or<br>constructor’s throws clause if they can be thrown by the execution of<br>the method or constructor and propagate outside the method or<br>constructor boundary.</p>
</blockquote>
<p>可以看到不要求在编译的时候处理。</p>
<h3 id="Error的定义"><a href="#Error的定义" class="headerlink" title="Error的定义"></a>Error的定义</h3><blockquote>
<p>An Error is a subclass of Throwable that indicates serious problems<br>that a reasonable application should not try to catch. Most such<br>errors are abnormal conditions. The ThreadDeath error, though a<br>“normal” condition, is also a subclass of Error because most<br>applications should not try to catch it.</p>
</blockquote>
<blockquote>
<p>A method is not required to declare in its throws clause any<br>subclasses of Error that might be thrown during the execution of the<br>method but not caught, since these errors are abnormal conditions that<br>should never occur. That is, Error and its subclasses are regarded as<br>unchecked exceptions for the purposes of compile-time checking of<br>exceptions.</p>
</blockquote>
<p>Error是程序中严重的错误，任何合理的程序都不能去捕获Error。<br><img src="/fig2.png" alt="enter description here"></p>
]]></content>
      <tags>
        <tag>error/exception</tag>
      </tags>
  </entry>
  <entry>
    <title>linux删除查找到的所有文件及目录</title>
    <url>/2018/07/08/rm/</url>
    <content><![CDATA[<h3 id="这里需要用find命令，因为find命令后边可以跟其他可执行的命令"><a href="#这里需要用find命令，因为find命令后边可以跟其他可执行的命令" class="headerlink" title="这里需要用find命令，因为find命令后边可以跟其他可执行的命令"></a>这里需要用find命令，因为find命令后边可以跟其他可执行的命令</h3><span id="more"></span>

<h4 id="Step1-首先根据关键字查找特定的文件及目录"><a href="#Step1-首先根据关键字查找特定的文件及目录" class="headerlink" title="Step1. 首先根据关键字查找特定的文件及目录"></a>Step1. 首先根据关键字查找特定的文件及目录</h4><p>我这里用steam作示范，这样就能找到所有包含’steam’关键字的文件及目录<br><img src="/fig1.png" alt="enter description here"></p>
<h4 id="Step2-在后边追加操作命令"><a href="#Step2-在后边追加操作命令" class="headerlink" title="Step2. 在后边追加操作命令"></a>Step2. 在后边追加操作命令</h4><h5 id="1-追加命令格式为-exec-command"><a href="#1-追加命令格式为-exec-command" class="headerlink" title="1)  追加命令格式为: -exec command {} ;"></a>1)  追加命令格式为: -exec command {} ;</h5><p><img src="/fig2.png" alt="enter description here"><br>在{}和\之间必须要有空格，否则会报错.</p>
<h5 id="2-xargs用于从-标准输入获得参数并且传递给后面的命令，这里使用的命令是-rm，然后由rm删除前面选择的文件"><a href="#2-xargs用于从-标准输入获得参数并且传递给后面的命令，这里使用的命令是-rm，然后由rm删除前面选择的文件" class="headerlink" title="2)  xargs用于从 标准输入获得参数并且传递给后面的命令，这里使用的命令是 rm，然后由rm删除前面选择的文件"></a>2)  xargs用于从 标准输入获得参数并且传递给后面的命令，这里使用的命令是 rm，然后由rm删除前面选择的文件</h5><p><img src="/fig3.png" alt="enter description here"></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo每次deploy后需要重新绑定自定义域名</title>
    <url>/2018/07/20/hexo_deploy/</url>
    <content><![CDATA[<p>在hexo目录下的source下新建一个CNAME文件，写上自定义的域名即可。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap如何产生环</title>
    <url>/2018/07/31/ring-in-hashMap/</url>
    <content><![CDATA[<p>HashMap本身不是线程安全的，所以高并发的情况下不应该使用HashMap，但是这里还是看了一下HashMap可能会产生的问题及其原因。这里讨论的主要是jdk1.7版本的HashMap。</p>
<span id="more"></span>

<h3 id="正常情况下HashMap"><a href="#正常情况下HashMap" class="headerlink" title="正常情况下HashMap"></a>正常情况下HashMap</h3><p>当HashMap中的元素超过其阀值时，HashMap要进行扩容，进行resize()操作, 下边的是jdk1.7的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;  </span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组  </span></span><br><span class="line">        Entry&lt;K, V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素  </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;  </span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）  </span></span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">                Entry&lt;K, V&gt; next = e.next;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置  </span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]  </span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上  </span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素  </span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>单线程下的resize()<br><img src="/fig1.gif" alt="enter description here"><br>接下来进行resize()操作，首先e指向A，next指向B，然后把e放到新的HashMap中<br><img src="/fig2.gif" alt="enter description here"><br>结束这一次迭代时把e指向B<br>就这样循环的把每一个Entry都放到新的HashMap中<br><img src="/fig3.gif" alt="enter description here"><br>最终变成这样：<br><img src="/fig4.gif" alt="enter description here"><br><strong>注意while循环的结束条件为 e&#x3D;&#x3D;null</strong></p>
<h3 id="并发下的HashMap"><a href="#并发下的HashMap" class="headerlink" title="并发下的HashMap"></a>并发下的HashMap</h3><p>假设有两个线程对上边的HashMap进行操作，在他们运行时，都知道要进行resize()，首先是线程1：<br><img src="/fig5.gif" alt="enter description here"><br>刚把e和next赋值，cpu就被线程2抢走了，而且线程2还比较厉害，一直把resize()完成才退出，那么线程2结束时我们的HashMap就变成这样了：<br><img src="/fig6.gif" alt="enter description here"><br><strong>这里线程2对HashMap的操作会影响线程1中的e和next，因为操作的都是同一块内存</strong><br>然后线程1继续执行，但是他不知道e和next的位置已经发生了变化，甚至不知道他已经不用再resize()了，需要注意的是，在resize()过程中，新表在建立过程中会把旧表中的Entry都置为null，但是线程1可不管那么多，他只知道e和next还指向内存块，他还要进行resize().</p>
<p>然后线程1在线程2建立的新表的基础上继续resize()，要注意的是，此时线程1在循环之前就把他的新表建立了，线程1继续执行的效果如下<br><img src="/fig7.gif" alt="enter description here"><br>把A取出放入新表中，然后e指向next即B，注意此时B的next为A，然后新一轮迭代中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next = e.next</span><br></pre></td></tr></table></figure>

<p>所以next指向了A<br><img src="/fig8.gif" alt="enter description here"></p>
<p>下一轮迭代中，e指向next即A，next指向null，然后用头插法把A插到头，结果就变成这样了！！<br><img src="/fig9.gif" alt="enter description here"></p>
<p>虽然建表的过程就此结束了，但是新表中含有了环！！那么下次只要有查询的需求并且查到了这个环，那么就会一直查下去造成死循环！</p>
<hr>
<p>上边的图参考自其他的<code>blog</code>，现在再看有些复杂了，重新画下：</p>
<ol>
<li><p>首先是线程1过来想要<code>rehash()</code>，刚标好<code>e</code>和<code>next</code>:</p>
<p><img src="/fig10.png"></p>
</li>
<li><p>线程2抢占了线程1，也要操作这个<code>HashMap</code>，并且也需要<code>rehash()</code>，首先一点，<code>HashMap</code>是个对象，放在堆中，各个线程访问的都是一样：</p>
<p><img src="/fig11.png"></p>
</li>
<li><p>线程2执行完<code>rehash()</code>后，又到线程1接着跑，但是此时线程1不知道别的线程已经完成了<code>rehash()</code>，接着之前的工作，此时线程1之前做的标记还☞着原本的节点：</p>
<p><img src="/fig12.png"></p>
<p>采用头插法将<code>A:3</code>插到了前边，且<code>A:3</code>.<code>next</code>指向了<code>B:7</code>，需要注意的是<code>B:7</code>.<code>next</code>由于线程2的修改指向了<code>A:3</code>，此时环就形成了。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的说来，resize()会产生环主要是把元素放到新桶中用的头插法，在1.8中已经改进了，并且1.8一般不会再产生环了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html</a></p>
]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的nc</title>
    <url>/2018/07/20/nc/</url>
    <content><![CDATA[<p>NC，组内共享工具</p>
<p>用在linux下，主要有三个功能，扫描端口，传输文件，监控网速</p>
<p>这里主要说一下传输文件</p>
<span id="more"></span>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>由于是用在linux下的，我就用虚拟机来做实验，用Virtualbox建了两台Centos7</p>
<p>要求：</p>
<ul>
<li>这两台机子能互相ping通</li>
<li>最好可以联网，因为我的Centos7没有自带nc工具</li>
<li>如果能ping通主机就更好了，这样可以使用xshell等连接工具，操作更方便</li>
</ul>
<p>接下来先说说让这些机器相互ping通<br>看了教程，用两块网卡比较方便，一块NAT，一块Host-Only，我的弊见就是NAT用来访问外网，Host-Only和主机打交道<br><img src="/fig1.PNG" alt="enter description here"><br><img src="/fig2.PNG" alt="enter description here"><br>有一点要注意，启动网络连接是在你没启动虚拟机时选择的，虚拟机跑起来了就无法添加网卡了</p>
<h3 id="配置虚拟机中的网卡"><a href="#配置虚拟机中的网卡" class="headerlink" title="配置虚拟机中的网卡"></a>配置虚拟机中的网卡</h3><p>在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 下可以看到这样的两个网卡，ifcfg-enp0s3和ifcfg-enp0s8，分别代表NAT和Host-Only的网卡</p>
<p>两块网卡都要修改<br><img src="/fig3.PNG" alt="enter description here"><br><img src="/fig4.PNG" alt="enter description here"><br>画红框的是需要注意的地方，Host-Only网卡中需要配置静态ip，此ip需要根据主机中VirtualBox Host-Only Network网卡的ip设置，可以看到这两个ip是处于同一个网段中的。<br><img src="/fig5.PNG" alt="enter description here"></p>
<h3 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h3><p>service network restart </p>
<p>这时候可以尝试<code>ping baidu.com</code>和主机，注意ping主机时ping的是以太网适配器的ip而不是VirtualBox Host-Only Network的ip</p>
<h3 id="然后用同样的套路在造一个Centos7"><a href="#然后用同样的套路在造一个Centos7" class="headerlink" title="然后用同样的套路在造一个Centos7"></a>然后用同样的套路在造一个Centos7</h3><p>现在主机和虚拟机可以互相<code>ping</code>通，虚拟机可以<code>ping</code>通外网，但是我这里虚拟机之间不能ping通了，可能是两台虚拟机的主机名是一样的？我没有细查，修改了<code>/etc/hosts</code>文件<br><img src="/fig6.PNG" alt="enter description here"><br>然后再重启网络，虚拟机之间就可以ping通了</p>
<h3 id="环境终于好了，下面用nc，我主要试了文件传输功能"><a href="#环境终于好了，下面用nc，我主要试了文件传输功能" class="headerlink" title="环境终于好了，下面用nc，我主要试了文件传输功能"></a>环境终于好了，下面用nc，我主要试了文件传输功能</h3><p>这里需要注意的是我新造的虚拟机是开启了防火墙的，所以下边监听端口的话，要先开发该端口，所以有涉及到Centos7开放端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9999/tcp --permanent</span><br><span class="line">firewall-cmd reload              <span class="comment">#刷新规则</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 9999 &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>机器A监听9999端口，当有动静的时候，把收到的内容写到test.txt文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 192.168.56.100 9999 &lt; hello.txt</span><br></pre></td></tr></table></figure>
<p>机器B使用nc把hello.txt 传送给机器A，机器A把hello.txt中的内容写入到test.txt中</p>
<p>当然也可以翻转一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 9999 &lt; hello.txt</span><br></pre></td></tr></table></figure>
<p>这样当有人连接该端口时，就把hello.txt发给他</p>
<p>个人感觉传输功能比较使用，可能是我眼界现在还太狭隘了，没有理解其他功能的实际用处。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nc</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的static</title>
    <url>/2018/08/08/static-in-java/</url>
    <content><![CDATA[<p>java中的static想必很常见了，但是若要问到其具体的用法，你又能说出几种呢</p>
<span id="more"></span>

<h3 id="static修饰变量方法"><a href="#static修饰变量方法" class="headerlink" title="static修饰变量方法"></a>static修饰变量方法</h3><p>这应该是最常见的一种用法了，当类中的属性或方法被static修饰后，就变成了类属性，也就是说访问这些方法或属性不需要类的实例，直接 ClassName.fieldName&#x2F;ClassName.methodName<br>一般在访问这些静态变量或方法时，不推荐用类实例来访问<br><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StaticOne&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;hello=&#x27;&quot;</span> + hello + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;flag=&#x27;&quot;</span> + StaticOne.flag + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticOne</span> <span class="variable">staticOne1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticOne</span>();</span><br><span class="line">        staticOne1.setHello(<span class="string">&quot;staticOne1&quot;</span>);</span><br><span class="line">        System.out.println(staticOne1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">StaticOne</span> <span class="variable">staticOne2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticOne</span>();</span><br><span class="line">        staticOne2.setHello(<span class="string">&quot;staticOne2&quot;</span>);</span><br><span class="line">        System.out.println(staticOne2.toString());</span><br><span class="line"></span><br><span class="line">        StaticOne.flag = <span class="number">111</span>;</span><br><span class="line">        System.out.println(staticOne1.toString());</span><br><span class="line">        System.out.println(staticOne2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果:</strong></p>
<blockquote>
<p>StaticOne{hello&#x3D;’staticOne1’flag&#x3D;’123’}<br>StaticOne{hello&#x3D;’staticOne2’flag&#x3D;’123’}<br>StaticOne{hello&#x3D;’staticOne1’flag&#x3D;’111’}<br>StaticOne{hello&#x3D;’staticOne2’flag&#x3D;’111’}</p>
</blockquote>
<p>可以看到类实例共享类静态属性，类中的静态成员变量在jvm有特定的存放位置，叫做 <strong>方法区</strong></p>
<h3 id="static修饰代码块"><a href="#static修饰代码块" class="headerlink" title="static修饰代码块"></a>static修饰代码块</h3><p>static修饰的代码块在类被加载时就运行，而且只在类被加载到jvm中时运行一次，后续创建该类实例时不再运行<br><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTwo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static block in class StaticTwo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticTwo</span> <span class="variable">staticTwo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwo</span>();</span><br><span class="line">        <span class="type">StaticTwo</span> <span class="variable">staticTwo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果:</strong></p>
<blockquote>
<p>1533725267598<br> this is static block in class StaticTwo<br>1533725267598<br>1533725267598</p>
</blockquote>
<p>虽然时间都是一样的，但是还是可以看到，static代码块里的代码在实例化对象之前执行，我猜静态代码块一般用来初始化一些数据用</p>
<p>在面试题中也会出现，父类子类里边都有静态代码块、代码块、构造函数，让你说说他们的执行顺序<br><strong>让我们来改造一下示例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTwo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is constructor &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static block in class StaticTwo &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is current block in class StaticTwo &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticTwo</span> <span class="variable">staticTwo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwo</span>();</span><br><span class="line">        <span class="type">StaticTwo</span> <span class="variable">staticTwo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就加了一个普通的代码块，先来看看执行结果吧:</p>
<blockquote>
<p>this is static block in class StaticTwo 1533725730951<br>this is current block in class StaticTwo 1533725730951<br>this is constructor 1533725730951<br>this is current block in class StaticTwo 1533725730951<br>this is constructor 1533725730951</p>
</blockquote>
<p>很容易看出一些规律，在一个类中，每次新建类实例时，都会执行一遍普通代码块，再执行构造方法<br><strong>接着改造，加入父子类:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTwo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is StaticTwo constructor &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static block in class StaticTwo &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is current block in class StaticTwo &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTwoChild</span> <span class="keyword">extends</span> <span class="title class_">StaticTwo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticTwoChild</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is StaticTwoChild constructor &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static block in class StaticTwoChild &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is current block in class StaticTwoChild &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StaticTwoChild</span> <span class="variable">staticTwoChild1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwoChild</span>();</span><br><span class="line">        <span class="type">StaticTwoChild</span> <span class="variable">staticTwoChild2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTwoChild</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果:</strong></p>
<blockquote>
<p>this is static block in class StaticTwo 1533726245985<br>this is static block in class StaticTwoChild 1533726245986<br>this is current block in class StaticTwo 1533726245986<br>this is StaticTwo constructor 1533726245986<br>this is current block in class StaticTwoChild 1533726245986<br>this is StaticTwoChild constructor 1533726245986<br>this is current block in class StaticTwo 1533726245986<br>this is StaticTwo constructor 1533726245986<br>this is current block in class StaticTwoChild 1533726245986<br>this is StaticTwoChild constructor 1533726245986</p>
</blockquote>
<p><strong>分析:</strong></p>
<ol>
<li>java中扩展类的初始化过程是这样的，最初虚拟机会依次递推找到最上层的父类，执行完类加载与静态成员的初始化；当main函数中执行代码，产生某个子类对象时，再依次递归找到最上层的父类先进行成员初始化（对象引用没有直接赋值就初始化为Null）,再调用相应的构造器产生对象，然后逐层的进行对象初始化直到最底层的子类。</li>
<li>所以我们可以看到，jvm在加载StaticTwoChild时，能发现它有父类StaticTwo，所以先去加载他的父类，他的父类没有显示的父类，所以就直接加载，然后在下去加载StaticTwoChild，所以输出前两行是父类静态代码块-&gt;子类静态代码块</li>
<li>子类在执行构造函数时，会先找父类的非默认构造方法并执行，所以下边输出结果就是先父类即StaticTwo的构造方法，再是子类即StaticTwoChild的构造方法，上边也说过了，普通代码块在每次实例化对象时都会最先执行，所以是父类普通代码块-&gt;父类构造方法-&gt;子类普通代码块-&gt;子类构造方法</li>
</ol>
<h3 id="static修饰内部类"><a href="#static修饰内部类" class="headerlink" title="static修饰内部类"></a>static修饰内部类</h3><p>内部类就是在一个类的内部，像定义变量方法那样，定义一个类，就叫内部类。其实在JDK中就有很多的内部类，尤其是在集合类中，比如下边:<br><img src="/fig1.png" alt="enter description here"><br><img src="/fig2.png" alt="enter description here"><br>还有很多就不放图了。<br>这里有会涉及静态内部类和普通内部类的区别，这里简单的说几点基本的吧:</p>
<ol>
<li>创建实例方式不同</li>
<li>静态内部类中只能访问外部类中静态成员，普通内部类都行</li>
<li>普通内部类中不能有static关键字，但是静态内部内中静不静态都行</li>
</ol>
<p>静态类有什么用呢？我也不清楚，抄一下别人的</p>
<ol>
<li>内部类一般只为其外部类使用；</li>
<li>内部类提供了某种进入外部类的窗户；</li>
<li>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。<br>可能还是我阅读量太少，并没有体会到内部类的精髓。</li>
</ol>
<h3 id="静态引入"><a href="#静态引入" class="headerlink" title="静态引入"></a>静态引入</h3><p>想来这也是最不常见的吧，我也不记得第一次在哪看到的了，不过还有影响的是在一个测试类中引入的断言，应该是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br></pre></td></tr></table></figure>
<p>使用静态引入可以方便我们编码，比如下边的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用多说了吧。</p>
]]></content>
      <tags>
        <tag>static关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的transient</title>
    <url>/2018/08/10/transient-in-java/</url>
    <content><![CDATA[<h3 id="transient本意"><a href="#transient本意" class="headerlink" title="transient本意"></a>transient本意</h3><p>英 [ˈtrænziənt]   美 [ˈtrænziənt]<br>adj. 短暂的;转瞬即逝的;临时的<br>n. 临时旅客;瞬变现象;候鸟</p>
<span id="more"></span>

<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>要说transient，就要说序列化和反序列化<br><strong>维基百科的定义</strong></p>
<blockquote>
<p>序列化（serialization）在计算机科学的资料处理中，是指将数据结构或物件状态转换成可取用格式（例如存成档案，存于缓冲，或经由网络中传送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始物件相同语义的副本。对于许多物件，像是使用大量参照的复杂物件，这种序列化重建的过程并不容易。面向对象中的物件序列化，并不概括之前原始物件所关联的函式。这种过程也称为物件编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组,deserialization, unmarshalling）。</p>
</blockquote>
<blockquote>
<p>序列化在计算机科学中通常有以下定义:</p>
<ol>
<li>对同步控制而言，表示强制在同一时间内进行单一存取。</li>
<li>在数据储存与传送的部分是指将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等，或者透过网络传送资料时进行编码的过程，可以是字节或是XML等格式。而字节的或XML编码格式可以还原完全相等的对象。这程序被应用在不同应用程序之间传送对象，以及服务器将对象储存到档案或数据库。相反的过程又称为反序列化。</li>
</ol>
</blockquote>
<p>还不是很清楚，引用这篇<a href="https://www.cnblogs.com/szlbm/p/5504166.html">博客</a>说的:</p>
<blockquote>
<p>序列化：将一个对象转换成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的。 </p>
</blockquote>
<blockquote>
<p>反序列化：将字节数组重新构造成对象。</p>
</blockquote>
<h3 id="java实现序列化及反序列化"><a href="#java实现序列化及反序列化" class="headerlink" title="java实现序列化及反序列化"></a>java实现序列化及反序列化</h3><p>java中要实现对象序列化只需要实现java.io.Serializable接口，想要更深的了解Serializable接口，只需要看其相关API或javadoc即可，下面我们来捡一些我看得懂的重要内容看</p>
<blockquote>
<p>Serializability of a class is enabled by the class implementing the<br>java.io.Serializable interface. Classes that do not implement this<br>interface will not have any of their state serialized or deserialized.<br>All subtypes of a serializable class are themselves serializable. The<br>serialization interface has no methods or fields and serves only to<br>identify the semantics of being serializable.</p>
</blockquote>
<p>只有实现了Serializable接口才能序列化，所有实现了Serializable接口的类的子类也能序列化，该接口没有任何方法和属性，只是用作标识能够序列化，这种用法在java中应该还有其他的，现在没影响了。</p>
<blockquote>
<p>To allow subtypes of non-serializable classes to be serialized, the<br>subtype may assume responsibility for saving and restoring the state<br>of the supertype’s public, protected, and (if accessible) package<br>fields. The subtype may assume this responsibility only if the class<br>it extends has an accessible no-arg constructor to initialize the<br>class’s state. It is an error to declare a class Serializable if this<br>is not the case. The error will be detected at runtime.</p>
</blockquote>
<p>大意就是上面说的，实现了Serializable接口的类的子类(没有明确实现Serializable的)要想能够序列化，那么其父类必须要有一个没有参数的子类能够访问的构造方法，下面写个简单的示例:<br><img src="/fig1.png" alt="enter description here"><br>父类没有无参构造函数，子类直接报错了，下面在父类中添加无参构造函数<br><img src="/fig2.png" alt="enter description here"><br>可以看到没报错了</p>
<blockquote>
<p>Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures:<br> private void writeObject(java.io.ObjectOutputStream out) throws IOException;<br> private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;<br> private void readObjectNoData() throws ObjectStreamException;</p>
</blockquote>
<p>想要自定义序列化或反序列化的过程，需要在类中实现这些方法。</p>
<p>默认的序列化和反序列化的方法分别在java.io.ObjectInputStream&#x2F;java.io.ObjectOutputStream中方法名称分别为defaultReadObject&#x2F;defaultWriteObject</p>
<blockquote>
<p>The serialization runtime associates with each serializable class a<br>version number, called a <strong>serialVersionUID</strong>, which is used during<br>deserialization to verify that the sender and receiver of a serialized<br>object have loaded classes for that object that are compatible with<br>respect to serialization. If the receiver has loaded a class for the<br>object that has a different serialVersionUID than that of the<br>corresponding sender’s class, then deserialization will result in an<br><strong>InvalidClassException</strong>. A serializable class can declare its own<br>serialVersionUID explicitly by declaring a field named<br>“serialVersionUID” that must be <strong>static</strong>, <strong>final</strong>, and of type <strong>long</strong>:</p>
<p> <strong>ANY-ACCESS-MODIFIER static final long serialVersionUID &#x3D; 42L;</strong></p>
</blockquote>
<p>大意为每个可序列化的类必须要有一个叫做 serialVersionUID 的属性，接收端在进行反序列化时会判断序列化中对象的UID和本地的相应类的UID是否相同，如果不同会抛出<strong>InvalidClassException</strong>异常，该属性必须叫这个名字，而且是 static,final,long类型的</p>
<blockquote>
<p>If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class, as described in the Java(TM) Object Serialization Specification. However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on compiler implementations, and can thus result in unexpected InvalidClassExceptions during deserialization. Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the private modifier where possible, since such declarations apply only to the immediately declaring class–serialVersionUID fields are not useful as inherited members. Array classes cannot declare an explicit serialVersionUID, so they always have the default computed value, but the requirement for matching serialVersionUID values is waived for array classes.</p>
</blockquote>
<p>这一段很长，主要就是说这个UID很重要，如果你没有明确声明，那么jvm会在序列化时候，计算一个UID作为默认的，但是这个计算方式非常依赖编译器，并且产生的结果和这个类本身(即属性，方法什么的)有很大的关系，所以这样一来，不同的jvm对同一个类默认生成的UID可能不同，而且一旦修改了类内容，那么肯定新的UID非常可能会和旧UID不同，这样很容易导致反序列化失败，我这里做一个修改类的例子:<br><img src="/fig3.png" alt="enter description here"><br>很正常的一个类，下面是序列化和反序列化<br><img src="/fig4.png" alt="enter description here"><br><img src="/fig5.png" alt="enter description here"><br>反序列化结果:<br><img src="/fig6.png" alt="https://image.zero22.top/result.png"><br>然后我把Book类中的test字段删除，发送端的已经保存到dest1.txt中了，我现在修改Book类相当于是接收端修改了类，然后接收端再从dest1.txt反序列化，结果:<br><img src="/fig7.png" alt="enter description here"><br>可以看到报异常了，所以说，这个serialVersionUID还是自己声明一个比较好</p>
<h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>transient说来应该就是为序列化和反序列化服务的，当一个字段声明为transient时，在默认的序列化和反序列化过程中就会跳过该字段，但并不是说该字段就不能被序列化了，我们可以自定义序列化过程来使得其进行序列化，还记得前边的 writeObject&#x2F;readObject方法吧，我们可以在这些方法中自定义序列化过程。这样一来，我们对于序列化的掌握就更加深了，对于一般的字段，用默认序列化方法即可，对于一些特殊的字段，比如用户密码什么的，我们可以对其声明transient，然后在自定义序列化中对其进行一些加密或其他处理在序列化。其实在上边的示例中仔细看就会发现Book类中flag字段是 transient的，但是在反序列时我依然可以读取该字段，就是因为我自定义了序列化&#x2F;反序列化:<br><img src="/fig8.png" alt="enter description here"></p>
<h3 id="序列化扩展"><a href="#序列化扩展" class="headerlink" title="序列化扩展"></a>序列化扩展</h3><p>在上面引用的序列化定义中写道”将一个对象转换成一串二进制表示的字节数组”，那么如今我把这个二进制的字节数组写到了dest1.txt文件，那么我们为什么不看一看文件内容呢<br><img src="/fig9.png" alt="enter description here"><br>这里有两个文件，左边的dest.txt是没有自定义序列化的，右边的是自定义了序列化的，所以右边比左边多出了一个<strong>flag</strong>，值为1，下边对文件<strong>dest1.txt</strong>内容进行分析，还是参考了这篇<a href="https://www.cnblogs.com/szlbm/p/5504166.html">博客</a></p>
<h4 id="序列化文件头"><a href="#序列化文件头" class="headerlink" title="序列化文件头"></a>序列化文件头</h4><ul>
<li>AC ED：STREAM_MAGIC序列化协议</li>
<li>00 05：STREAM_VERSION序列化协议版本</li>
<li>73：TC_OBJECT声明这是一个新的对象</li>
</ul>
<h4 id="序列化的类的描述"><a href="#序列化的类的描述" class="headerlink" title="序列化的类的描述"></a>序列化的类的描述</h4><ul>
<li>72：TC_CLASSDESC声明这里开始一个新的class</li>
<li>00 04：十进制的4，表示class名字的长度是4个字节</li>
<li>42 6F 6F 6B：类名，包括包名，但是我这里没加包就没有</li>
<li>DB 46 ……85 65：八个字节，long类型的长度，表示serialVersionUID</li>
<li>03：</li>
<li>00 02：该类所包含的域的个数，可以看到这里不包括transient的字段</li>
</ul>
<h4 id="对象中各个属性项的描述"><a href="#对象中各个属性项的描述" class="headerlink" title="对象中各个属性项的描述"></a>对象中各个属性项的描述</h4><ul>
<li>49：字符”I”，表示该属性是一个基本类型</li>
<li>00 06：十进制的6，表示属性名的长度</li>
<li>62 6F 6F 6B 49 64：字符串“bookId”，属性名</li>
<li>4C：字符”L”，表示该属性是一个对象类型而不是基本类型</li>
<li>00 08：属性名长度</li>
<li>八个字节：”bookName”</li>
<li>74：TC_STRING，代表一个new String，用String来引用对象</li>
</ul>
<h4 id="该对象父类的信息-这里我不是很懂"><a href="#该对象父类的信息-这里我不是很懂" class="headerlink" title="该对象父类的信息(这里我不是很懂)"></a>该对象父类的信息(这里我不是很懂)</h4><ul>
<li>00 12：十进制的18，表示父类的长度</li>
<li>4C 6A 61 … 6E 67 3B：“L&#x2F;java&#x2F;lang&#x2F;String;”表示的是父类属性</li>
<li>78：TC_ENDBLOCKDATA，对象块结束的标志</li>
<li>70：TC_NULL，说明没有其他超类的标志</li>
</ul>
<h4 id="对象的属性项的实际值"><a href="#对象的属性项的实际值" class="headerlink" title="对象的属性项的实际值"></a>对象的属性项的实际值</h4><p>如果属性项是一个对象，这里还将序列化这个对象，规则和第2部分一样</p>
<ul>
<li>00 00 00 01：bookId的值，为1，我才基本类型就直接显示值</li>
<li>74：前边说是代表一个new String</li>
<li>00 05：应该是new String 的长度</li>
<li>62 6F 6F 6B 31：bookName的值”book1”</li>
</ul>
<p><em>在后边就是自定义序列化增加的内容了</em></p>
<ul>
<li>77：w，应该是标识write</li>
<li>04：表示写了4个字节</li>
<li>00 00 00 01：表示flag的值，为1</li>
<li>78：对象块结束的标志</li>
</ul>
<h4 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h4><ul>
<li>在自定义序列化中，可以看到上边我用的是writeInt，写4个字节，还有一个write(int)方法，只写一个字节，当参数超过一个字节时，只写低8位，看一个示例：<br> 我把上边的flag改为 77777777，很明显这个数超过8个字节了，其16进制为04a2cb71，我们看一下写到文件中的内容：<br> <img src="/fig10.png" alt="enter description here"><br> 只写了一个71</li>
<li><strong>static</strong>变量也不会被序列化</li>
</ul>
<h3 id="over"><a href="#over" class="headerlink" title="over"></a>over</h3>]]></content>
      <tags>
        <tag>transient关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Comparator/Comparable</title>
    <url>/2018/08/10/Comparator-Comparable/</url>
    <content><![CDATA[<p>关于java中的Comparator和Comparable，经常会看到，但是因为没有深入的研究，老是把这两个东西搞混淆，很烦，在这里总结一下。</p>
<span id="more"></span>
<h3 id="字面意思"><a href="#字面意思" class="headerlink" title="字面意思"></a>字面意思</h3><p>Comparator: 比较器，就像是一个工具一样。<br>Comparable: 可比较的，描述一个类本身的属性。</p>
<h3 id="java-util-Comparator"><a href="#java-util-Comparator" class="headerlink" title="java.util.Comparator"></a>java.util.Comparator</h3><h4 id="最主要的方法"><a href="#最主要的方法" class="headerlink" title="最主要的方法"></a>最主要的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o1 the first object to be compared.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> o2 the second object to be compared.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a negative integer, zero, or a positive integer as the</span></span><br><span class="line"><span class="comment">*         first argument is less than, equal to, or greater than the</span></span><br><span class="line"><span class="comment">*         second.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if an argument is null and this</span></span><br><span class="line"><span class="comment">*         comparator does not permit null arguments</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> ClassCastException if the arguments&#x27; types prevent them from</span></span><br><span class="line"><span class="comment">*         being compared by this comparator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>当有入参为null时就会抛出异常</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>新建比较类</li>
<li>实现此接口，重写方法</li>
<li>自己调用该方法进行比较或者作为Collections.sort等入参</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>代码:<br><img src="/fig1.png" alt="按照销量升序"><br>结果:<br><img src="/fig2.png" alt="enter description here"></p>
<h3 id="java-util-Comparable"><a href="#java-util-Comparable" class="headerlink" title="java.util.Comparable"></a>java.util.Comparable</h3><h4 id="只有一个方法"><a href="#只有一个方法" class="headerlink" title="只有一个方法"></a>只有一个方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>   o the object to be compared.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  a negative integer, zero, or a positive integer as this object</span></span><br><span class="line"><span class="comment">*          is less than, equal to, or greater than the specified object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NullPointerException if the specified object is null</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> ClassCastException if the specified object&#x27;s type prevents it</span></span><br><span class="line"><span class="comment">*         from being compared to this object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ol>
<li>实现接口，重写方法</li>
<li>调用该方法</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>代码:<br><img src="/fig3.png" alt="enter description here"><br>结果:<br><img src="/fig4.png" alt="enter description here"></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>java.util.Collections.sort最终还是会调用java.util.Arrays里的sort方法，我们跟着他在源码中跳几下，看看这个过程</p>
<h4 id="step0"><a href="#step0" class="headerlink" title="step0"></a>step0</h4><p><img src="/fig5.png" alt="程序中调用Collections.sort"></p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p><img src="/fig6.png" alt="调用List的sort"></p>
<h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><p><img src="/fig7.png" alt="List中调用Arrays.sort"></p>
<h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><p><img src="/fig8.png" alt="根据是否有比较器"></p>
<h5 id="没有比较器"><a href="#没有比较器" class="headerlink" title="没有比较器"></a>没有比较器</h5><p><img src="/fig9.png" alt="enter description here"></p>
<h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><blockquote>
<p>&#x2F;**<br>     * Sorts the specified array of objects into ascending order, according<br>     * to the {@linkplain Comparable natural ordering} of its elements.<br>     * All elements in the array must implement the {@link Comparable}<br>     * interface.  Furthermore, all elements in the array must be<br>     * <i>mutually comparable</i> (that is, {@code e1.compareTo(e2)} must<br>     * not throw a {@code ClassCastException} for any elements {@code e1}<br>     * and {@code e2} in the array).</p>
</blockquote>
<p><strong>数组中的元素必须实现Comparable接口</strong></p>
<h6 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h6><p><img src="/fig10.png" alt="enter description here"></p>
<h5 id="有比较器"><a href="#有比较器" class="headerlink" title="有比较器"></a>有比较器</h5><p>我这里看的是 <strong>TimSort.sort</strong><br><img src="/fig11.png" alt="enter description here"><br>继续看 <strong>binarySort</strong><br><img src="/fig12.png" alt="enter description here"></p>
<h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><p>哇，这里还有好多的sort啊，看的我脑袋都大了，over</p>
]]></content>
      <tags>
        <tag>comparator/comparable</tag>
      </tags>
  </entry>
  <entry>
    <title>原子类AtomicInteger的自增</title>
    <url>/2018/08/13/atomicInteger/</url>
    <content><![CDATA[<p>包 java.util.concurrent.atomic 下有很多原子类，可以在不使用锁的前提下实现并发，下面就AtomicInteger来深入看看原子类。</p>
<span id="more"></span>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset</span><br><span class="line">      (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>Unsafe类提供了像C&#x2F;C++那样操作内存的方法，在很多地方都有用到Unsafe类。由于Unsafe类中大多都是native方法，没有提供源码，连注释都没有(jdk1.8)，看起来有点不爽。</p>
<p>Unsafe.objectFieldOffset()方法返回成员变量相对于对象位置的偏移量(而且这个偏移量也有点意思)，举个例子，假设Book类有个成员变量bookName，且偏移量为12，那么当新建一个Book对象，对象地址为 0x1a3234c3(这地址我瞎举的)，那么bookName的地址就是(0x1a3234c3 + 12)。该方法需要一个java.lang.reflect.Field参数，和反射有关。</p>
<p>value变量保存了当前的对象的值，这个变量被volatile修饰了，即当有多个线程时，只要该变量修改了，能保证其他线程在用这个值得时候是最最最新的。后边也打算写一下volatile。</p>
<h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法实现了AtomicInteger的自增1操作，而且是原子的。我们知道，在多线程的环境下使用 num++，最终的结果可能会和预期有差异，这是由于num++不是原子性的，需要读取、加、写入，在这些过程中，可能会丢失掉一部分的写入操作，和数据库中的第二类丢失更新类似。那么这个方法为什么是原子性的呢? </p>
<p>把相关的方法都找出来:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">  <span class="type">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很不幸的是，getAndAddInt()里边的两个方法都是native，在java中没有源码。这里我们来实际用用这些方法。</p>
<h4 id="实例化Unsafe"><a href="#实例化Unsafe" class="headerlink" title="实例化Unsafe"></a>实例化Unsafe</h4><p>Unsafe使用了单例模式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然是单例模式，但不是你想getUnsafe就能得到Unsafe的，他被设计成只有引导类加载器(bootstrap class loader)加载才能返回 Unsafe实例。</p>
<p>这里看文章都写了两种方法，一种是加jvm参数，另一种是反射。加jvm参数我没成功，所以说说反射吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>这里有点反射的知识，当Field为成员变量时，field.get(not null)必须有个对象参数，否则会有空指针异常；如果Field是静态变量，那么就不需要对象作为参数了。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>先来试试getIntVolatile方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getIntVolatile</span><span class="params">(Object var1, <span class="type">long</span> var2)</span>;</span><br></pre></td></tr></table></figure>

<p>两个参数，var1为对象，var2为变量偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserTwo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fieldTwo</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticString</span> <span class="operator">=</span> <span class="string">&quot;static string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> UserTwo.class.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 域偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(field1);</span><br><span class="line">System.out.println(<span class="string">&quot;getInt: &quot;</span> + unsafe.getInt(userTwo, offset));</span><br></pre></td></tr></table></figure>

<p>上边用的getInt，和getIntVolatile大同小异，应该根据具体变量进行选择，输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getInt: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>所以这个方法作用为，<strong>根据变量的相对偏移量，得到具体对象的属性值</strong></p>
<p>再来看看compareAndSwapInt方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure>

<p>根据上面的分析，var1，var2用来获取对象属性值，var4为期望值，var5为目标值，写一些示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;getAndAddInt: &quot;</span> + unsafe.getAndAddInt(userTwo, offset, <span class="number">12</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;test=&quot;</span> + field1.get(userTwo));</span><br><span class="line">System.out.println(<span class="string">&quot;compareAndSwapInt: &quot;</span> + unsafe.compareAndSwapInt(userTwo, offset , <span class="number">24</span>, <span class="number">23</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;test=&quot;</span> + field1.get(userTwo));</span><br><span class="line">System.out.println(<span class="string">&quot;compareAndSwapInt: &quot;</span> + unsafe.compareAndSwapInt(userTwo, offset , <span class="number">45</span>, <span class="number">24</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;test=&quot;</span> + field1.get(userTwo));</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getAndAddInt: <span class="number">12</span></span><br><span class="line">test=<span class="number">24</span></span><br><span class="line">compareAndSwapInt: <span class="literal">true</span></span><br><span class="line">test=<span class="number">23</span></span><br><span class="line">compareAndSwapInt: <span class="literal">false</span></span><br><span class="line">test=<span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>getAndAddInt，当执行成功时，即实际属性值和期望值相同，即那段时间内内存中的值没有修改过，可以更新，则返回旧值，但其实这时实际内存中的值已经更新了，12+12，所以得到24；<br>而 compareAndSwapInt，当执行成功时返回true，并将内存中的值更新为目标值，否则返回false。</p>
<p>所以，getAndAddInt方法的大致流程为，取内存中的值，把该值当做目标值，在compareAndSwapInt中在此比较内存中的值和目标值是否相同，如果相同说明其他线程没有修改该变量，此线程可以进行修改，但是具体的修改过程我就不知道，可能还需要看下C++代码吧</p>
]]></content>
      <tags>
        <tag>unsafe</tag>
        <tag>automic</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 5. Longest Palindromic Substring</title>
    <url>/2018/08/14/manacher/</url>
    <content><![CDATA[<p>给你一个字符串，找到一个最长的回文子串，例如，”banana”字符串的最长回文子串为”anana”，这里说的找到一个是因为一个字符串可能有多个长度相同的回文子串，这里只用返回一个就可以了。另外要区分一下回文子串和回文子序列，其实就是子串和子序列的区别。<br>参考文章：<a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/">Longest Palindromic Substring Part II</a><br>维基百科：<a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring">Longest palindromic substring</a></p>
<span id="more"></span>

<h3 id="简化字符串"><a href="#简化字符串" class="headerlink" title="简化字符串"></a>简化字符串</h3><p>首先，为了避免奇数和偶数长度的影响，我们在字符串中增加特殊符号’#’，这里我自己想这一题的时候也用了这个方法，这样加完特殊符号后，新的字符串总是奇数长度，然后在求回文串的时候，每个字符都可以当做中间值，比较他两边的字符是否相同即可。<br>“ababa” –&gt; “#a#b#a#b#a#”</p>
<h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>在我的感觉中，算法应该就是把事物中的规律用语句表示出来，所以下面我们来看看计算最长回文子串中的规律。<br>用一个额外的数组记录每个点为中心时的对称长度。<br><img src="/fig1.png" alt="enter description here"><br>其中C表示当前回文串的中心，L、R分别表示当前回文串的左端和右端，i为待求，i’为i关于C的对称索引，现在让你求以i为中心的回文串的最大长度，你会怎么求。我们看到，以C为中心，他两边不超过L&#x2F;R的字符串都是对称的，所以我们可以直接确定P[i] &#x3D; p[i’]，这样就省了一部分求P的时间。<br><img src="/fig2.png" alt="enter description here"><br>我自己做的没有用到以求的数据，每个地方都是比较他两边的字符，这样显然很浪费时间，但是Manacher算法在计算回文串长度时，用到了前边的数据，这里我第一时间想到了KMP算法求子串的长度。<br>然后我们继续：<br><img src="/fig3.png" alt="enter description here"><br>当i&#x3D;15时，能直接说P[15] &#x3D; P[7] 吗，你要知道，我们前边能直接根据镜像求P有个条件，那就是我们的镜像的边界都没超过L&#x2F;R，也就是能确保C两边的字符串是一模一样的，但是这里，P[7] &#x3D; 7，超过了边界L，再看一张图<br><img src="/fig4.png" alt="enter description here"><br>绿色实线表示左右两边一定相同的并且P[i]一定会包含的，绿色虚线表示相同但是不一定包含在P[i]中，这里要取决于红色实线的部分，也就是说镜像得来的便利也就到R为止了，后边的就要靠自己去比较两边的字符了。<br><strong>总结规律：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> P[i<span class="string">&#x27;] &lt; R-i</span></span><br><span class="line"><span class="string">then P[i] = P[i&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span> P[i] &gt;= R-i</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transform S into T.</span></span><br><span class="line"><span class="comment">// For example, S = &quot;abba&quot;, T = &quot;^#a#b#b#a#$&quot;.</span></span><br><span class="line"><span class="comment">// ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></span><br><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;^$&quot;</span>;</span><br><span class="line">  string ret = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    ret += <span class="string">&quot;#&quot;</span> + s.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ret += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  string T = <span class="built_in">preProcess</span>(s);</span><br><span class="line">  <span class="type">int</span> n = T.<span class="built_in">length</span>();</span><br><span class="line">  <span class="type">int</span> *P = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">  <span class="type">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> i_mirror = <span class="number">2</span>*C-i; <span class="comment">// equals to i&#x27; = C - (i-C)</span></span><br><span class="line"></span><br><span class="line">    P[i] = (R &gt; i) ? <span class="built_in">min</span>(R-i, P[i_mirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to expand palindrome centered at i</span></span><br><span class="line">    <span class="keyword">while</span> (T[i + <span class="number">1</span> + P[i]] == T[i - <span class="number">1</span> - P[i]])</span><br><span class="line">      P[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If palindrome centered at i expand past R,</span></span><br><span class="line">    <span class="comment">// adjust center based on expanded palindrome.</span></span><br><span class="line">    <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">      C = i;</span><br><span class="line">      R = i + P[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the maximum element in P.</span></span><br><span class="line">  <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">      maxLen = P[i];</span><br><span class="line">      centerIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] P;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> s.<span class="built_in">substr</span>((centerIndex - <span class="number">1</span> - maxLen)/<span class="number">2</span>, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Manacher</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的Enum</title>
    <url>/2018/08/16/enum-in-java/</url>
    <content><![CDATA[<p>最近看java内存模型讲 volatile时候，举了一个DCL(Double Check Lock?)双重检测的单例模式，让我想到了之前看过的枚举实现单例模式，感觉很神奇而且陌生，讲道理，我基本上没怎么用过枚举，还是我见识太少了吧，所以我打算看看这个Enum是怎么回事。</p>
<span id="more"></span>

<h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>一般用枚举的话，我们一般用的是 “enum”，而不是”Enum”，就好比 “class” 和 “Class”一样。枚举是一种特殊的类，声明时用”enum”，就像接口用”interface”一样，写个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumTest</span>&#123;</span><br><span class="line">    ENUM1;</span><br><span class="line">    EnumTest()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is EnumTest()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nothing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;nothing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        EnumTest.ENUM1.nothing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来和一个类没什么区别，可以有 成员变量、方法什么的，但是这也只是看起来而已。</p>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><p>下面我们更加深入的看一看这个enum到底是什么玩意，直接反编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;EnumTest&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumTest ENUM1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumTest[] values();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">1</span>                  <span class="comment">// Field $VALUES:[LEnumTest;</span></span><br><span class="line">       <span class="number">3</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method &quot;[LEnumTest;&quot;.clone:()Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">6</span>: checkcast     #<span class="number">3</span>                  <span class="comment">// class &quot;[LEnumTest;&quot;</span></span><br><span class="line">       <span class="number">9</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EnumTest <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">4</span>                  <span class="comment">// class EnumTest</span></span><br><span class="line">       <span class="number">2</span>: aload_0</span><br><span class="line">       <span class="number">3</span>: invokestatic  #<span class="number">5</span>                  <span class="comment">// Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span></span><br><span class="line">       <span class="number">6</span>: checkcast     #<span class="number">4</span>                  <span class="comment">// class EnumTest</span></span><br><span class="line">       <span class="number">9</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">11</span>                 <span class="comment">// Field ENUM1:LEnumTest;</span></span><br><span class="line">       <span class="number">3</span>: invokespecial #<span class="number">12</span>                 <span class="comment">// Method nothing:()V</span></span><br><span class="line">       <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class EnumTest</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: ldc           #<span class="number">13</span>                 <span class="comment">// String ENUM1</span></span><br><span class="line">       <span class="number">6</span>: iconst_0</span><br><span class="line">       <span class="number">7</span>: invokespecial #<span class="number">14</span>                 <span class="comment">// Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V</span></span><br><span class="line">      <span class="number">10</span>: putstatic     #<span class="number">11</span>                 <span class="comment">// Field ENUM1:LEnumTest;</span></span><br><span class="line">      <span class="number">13</span>: iconst_1</span><br><span class="line">      <span class="number">14</span>: anewarray     #<span class="number">4</span>                  <span class="comment">// class EnumTest</span></span><br><span class="line">      <span class="number">17</span>: dup</span><br><span class="line">      <span class="number">18</span>: iconst_0</span><br><span class="line">      <span class="number">19</span>: getstatic     #<span class="number">11</span>                 <span class="comment">// Field ENUM1:LEnumTest;</span></span><br><span class="line">      <span class="number">22</span>: aastore</span><br><span class="line">      <span class="number">23</span>: putstatic     #<span class="number">1</span>                  <span class="comment">// Field $VALUES:[LEnumTest;</span></span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哇，可以看到我之前在枚举类中加入的 “ENUM1”竟然是这个类的静态实例，而且还是<strong>final</strong>的，那么这里有个问题，final变量在使用之前必须初始化，但是我们看到这里只是声明，并没有初始化。我们继续往下看，发现还有一个静态代码块！这一下应该能猜到<strong>ENUM1</strong>是在静态代码块里初始化的，我们来看看。</p>
<ul>
<li>new 在java堆上为EnumTest对象分配内存空间，并将地址压入操作数栈顶</li>
<li>dup 复制操作数栈顶值，并将其压入栈顶，也就是说此时操作数栈上有连续相同的两个对象地址</li>
<li>ldc 把常量池中 ENUM1 推送至栈顶</li>
<li>invokespecial 指令调用实例初始化方法”&lt;init&gt;”:(Ljava&#x2F;lang&#x2F;String;I)V</li>
</ul>
<p>看到这大概也就清楚了，静态代码块中确实会初始化ENUM1，这也解决了我的一个疑惑，看下面的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumOut</span>&#123;</span><br><span class="line">    ONE,TWO;</span><br><span class="line">    EnumOut()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接给出输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> is constructor</span><br><span class="line"><span class="built_in">this</span> is constructor</span><br><span class="line"><span class="built_in">this</span> is main</span><br></pre></td></tr></table></figure>

<p>在没有分析字节码之前，我不懂为什么会执行构造函数，但现在，豁然开朗。另外，要注意enum的构造方法只能是private的。</p>
<h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><p>下面看看如何使用枚举实现单例模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">single1</span> <span class="operator">=</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">single2</span> <span class="operator">=</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">        System.out.println(single1 == single2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在jvm第一次加载SingletonEnum类时，INSTANCE就已经被定死了，后边调用<strong>SingletonEnum.INSTANCE.getInstance()</strong> 方法时得到的都是INSTANCE对象中的Singleton，所以保证了单例。</p>
]]></content>
      <tags>
        <tag>enum</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap(一)</title>
    <url>/2018/08/17/hashmap1/</url>
    <content><![CDATA[<p>打算看看关于Collection&#x2F;Map的源码，先拿HashMap试试手吧，这一篇主要看看HashMap的put方法，把与其相关的方法都揪出来。注意，源码是<strong>jdk1.8版本</strong>的</p>
<span id="more"></span>

<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个计算key的hash值得方法，</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法简单说来就是，为了尽量减少冲突，并且还要考虑效率，在计算key的hash值时，也让hashCode的高位参与运算。</p>
<h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">      ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">          ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哇，怎么这么长，别着急，我们慢慢看，后边还有更长的呢。</p>
<ol>
<li>首先，如果当前的”篮子”为空或者长度为0，那么很明显需要初始化，用到了<strong>resize()</strong> ；</li>
<li>接下来，我们可以看到索引值得计算方法： <strong>(n-1) &amp; hash</strong><br>其中n为table的长度，都是2次幂，那么n-1 就是这样的了： 11…111<br>hash为前面计算的高位和低位都参与的hash值<br>从这里可以看出来，table的索引值是依靠hash值得低几位决定的。<br>如果当前索引没被占过，那么新Node直接放这就完事了。</li>
<li>下边就是更新值的操作了<br>如果老点的hash值和key值和新点相同，记录老点；<br>如果老点所在的”篮子”后边跟的太多了，导致变异成了树，把新点放到树里边<strong>putTreeVal(this, tab, hash, key, value)</strong> ，记录返回值；<br>最后来个循环，在”篮子”后边的链表中继续找，没找到就把新点加在链表的最后，注意，加完了要判断链表的长度是否大于树化的临界值8，可能要进行树化 <strong>treeifyBin(tab, hash)</strong> ；<br>上面三种可能都记录了老点，但是putTreeVal()目前不知道返回什么，先不管了，老点都被e记录了，如果e不为空，说明新点和老点重复了，要进行覆盖，最后返回老点的值，</li>
<li>如果没有更新值，说明新点被添加到table中了，接下来要判断table的大小有没有超过阀值，如果超过阀值又要resize()，最后返回null。</li>
</ol>
<p>下面再来看看putVal中涉及到的各种方法：</p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>初始化table或者table容器超过阀值都要进行resize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">          oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">          (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把table的长度、阀值什么的确定下来</p>
<ol>
<li>如果老table存在，即其长度大于0，如果长度大于2^30，那就不用重建了，因为长度已经是最大值了，把阀值调到Integer.MAX_VALUE；否则，老table长度扩大一倍，阀值也扩大一倍；</li>
<li>老table长度为0，新table长度为阀值；</li>
<li>如果老table长度为0，并且老阀值不大于0，那就按默认的来，长度16，阀值12</li>
</ol>
<p>下边就是把老table中的点放到新table中的过程了</p>
<ol>
<li>循环遍历每个老点</li>
<li>如果该点没有冲突，直接放新table中；</li>
<li>如果该点后面跟着树，那么((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)</li>
<li>否则该点后边就是不算长的冲突链表了；</li>
<li>创建两个链表，用来减少冲突，遍历链表时，划分某一点的依据是 (e.hash &amp; oldCap) &#x3D;&#x3D; 0，由于table的长度都是2的次幂，比如长度为16时，oldCap为00010000，产生冲突的点中，其hash值的低四位是一样的，比如这两个：e1.hash&#x3D;11010101，e2.hash&#x3D;10100101，他们最后四位是一样的，但是oldCap位就说不准了，比如e1是1，e2是0，这样他们就被放到不同的链表 loHead、hiHead中了。所以老table中的一条冲突链表到新table中变成两条冲突链表了；</li>
<li>最后是两个新冲突链表在新表中的位置，一个不变，一个在原位的基础上位移老table长度的距离。</li>
</ol>
<p>关于和树相关的操作，等我把红黑树那个了再说吧- -</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap与TreeSet</title>
    <url>/2018/08/20/TreeMap/</url>
    <content><![CDATA[<p>我们知道，map中的元素是由键值对组成的，TreeMap就是把这些键值对通过某个因素连接组成树的一种数据结构。其中TreeMap中的树是红黑树，在构造TreeMap对象时，可以选择传入一个比较器Comparator，如果没传的话，那么TreeMap中元素的key需要实现Comparable接口，这个规定是强制的，不然会有异常。下面看看常用的方法，说是常用我却没用过，还有一个TreeSet，放一起看看。jdk1.8版本的。</p>
<span id="more"></span>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  Entry&lt;K,V&gt; t = root;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">    compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cmp;</span><br><span class="line">  Entry&lt;K,V&gt; parent;</span><br><span class="line">  <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">  Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">  <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      parent = t;</span><br><span class="line">      cmp = cpr.compare(key, t.key);</span><br><span class="line">      <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      parent = t;</span><br><span class="line">      cmp = k.compareTo(t.key);</span><br><span class="line">      <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">  <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br><span class="line">  fixAfterInsertion(e);</span><br><span class="line">  size++;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不是很难，如果树为空，就新建root；否则根据Comparator&#x2F;Comparable比较key值，如果key值已经存在了，直接用新value覆盖之；不然就找到插入点进行插入，最后作调整。<br>TreeMap的作者也参与了HashMap的编写，但是其中红黑树调整的写法却不一样。</p>
<h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3><p>这里就写个最简单的get方法吧，里边还有各种get方法，比如模糊查找，找比特定值大的部分中的最小的，或者比特定值小的部分中最大的等等，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">  <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">  Entry&lt;K,V&gt; p = root;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">      p = p.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">      p = p.right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照Comparator或者Comparable来查找指定的key。</p>
<h3 id="successor"><a href="#successor" class="headerlink" title="successor"></a>successor</h3><p>个人认为这个方法也挺重要的，不过一般我们不用，他为TreeMap中其他方法提供，用来返回特定Entry的后继节点，即比他大的且最靠近他的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">    <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">      p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">    Entry&lt;K,V&gt; ch = t;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">      ch = p;</span><br><span class="line">      p = p.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比指定Entry大的值出现在两个地方，Entry的右孩子或者Entry所在的子树为另一子树的左孩子。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>什么都不说，让我们看看TreeSet的构造函数吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">  <span class="built_in">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以及一些成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>原来TreeSet就是把TreeMap包装一下? 你是对的</p>
<p>再来看看他的一些方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125; <span class="comment">// 哈哈，Entry不够，Object来凑</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他的方法就是 NavigableSet接口中的方法了，主要是给定搜索目标报告最接近匹配项的导航方法，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">ceiling</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等都是调用TreeMap中关于key的操作。</p>
<p>over</p>
]]></content>
      <tags>
        <tag>TreeMap</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap(二)</title>
    <url>/2018/08/20/hashmap2/</url>
    <content><![CDATA[<p>jdk1.8中的HashMap额外引用了红黑树，当冲突链表太长的话，就会把链表转化为红黑树的结构，避免了原来的当冲突太多了，查找效率可能会退化到O(n)的情况。红黑树在HashMap中表现为TreeNode，下面看一下主要的方法。</p>
<span id="more"></span>

<h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><p>具体的树化过程，但是里边有个地方我不是太明白：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">  <span class="type">int</span> dir, ph;</span><br><span class="line">  <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">  <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">    dir = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">    dir = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">        (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">  TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">  <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">    x.parent = xp;</span><br><span class="line">    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">      xp.left = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      xp.right = x;</span><br><span class="line">    root = balanceInsertion(root, x);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边是查找插入点的过程，这个<strong>h</strong>是链表中待插入的点的hash值，ph是树中的点的hash值，话说为什么要先比较这俩呢，既然在一条冲突链表里，hash值还能不一样吗?所以一般情况下，插入树中主要比较的是他们的<strong>key</strong>值，如果key值也一样就比较两个节点的原始hashcode，原始hashcode也相等被包含在-1中。</p>
<h3 id="untreeify"><a href="#untreeify" class="headerlink" title="untreeify"></a>untreeify</h3><p>解除树化，树中节点数小于等于6，就会转化为链表。主要操作就是把链表中的TreeNode变成Node。<br>链表中的点称为 Node，红黑树中的点称为 TreeNode，这个TreeNode最终还是继承的该Node，链表主要用pre、next等，树主要用left、right、parent等，所以这两种点可以相互转化。</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>只在resize时使用，首先根据next、pre把树分成lo和hi两条链表，放到新table中，如果长度大于6再树化。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树的规则：</p>
<ul>
<li>根节点是黑的</li>
<li>叶子是黑的</li>
<li>树中的节点是黑或红</li>
<li>红色节点的孩子是黑的</li>
<li>从任一节点开始到能到的叶子，经过的黑色节点数目是一样的</li>
</ul>
<p>具体看<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">wiki</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于HashMap其他的我认为没什么好看的了，最后把get也一起放这就结束吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">final <span class="title class_">Node</span>&lt;K,V&gt; <span class="title function_">getNode</span>(<span class="params">int hash, <span class="built_in">Object</span> key</span>) &#123;</span><br><span class="line">  <span class="title class_">Node</span>&lt;K,V&gt;[] tab; <span class="title class_">Node</span>&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.<span class="property">length</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.<span class="property">hash</span> == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">      ((k = first.<span class="property">key</span>) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="title function_">equals</span>(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">if</span> ((e = first.<span class="property">next</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> <span class="title class_">TreeNode</span>)</span><br><span class="line">        <span class="keyword">return</span> ((<span class="title class_">TreeNode</span>&lt;K,V&gt;)first).<span class="title function_">getTreeNode</span>(hash, key);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.<span class="property">hash</span> == hash &amp;&amp;</span><br><span class="line">          ((k = e.<span class="property">key</span>) == key || (key != <span class="literal">null</span> &amp;&amp; key.<span class="title function_">equals</span>(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.<span class="property">next</span>) != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过了put之后，我感觉get就没啥好说的，找到索引位置，从第一个开始往后找，如果是树的话就用红黑树的找法。</p>
<p>over.</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>NavigableMap/NavigableSet</title>
    <url>/2018/08/21/NavigableSet-NavigableMap%E5%8F%8ASortedSet-SortedMap/</url>
    <content><![CDATA[<p>navigation<br>英 [ˌnævɪˈgeɪʃn] 美[ˌnævɪˈɡeʃən]<br>noun<br>[U]<br>导航；领航<br>the skill or the process of planning a route for a ship or other vehicle and taking it there</p>
<span id="more"></span>

<p>前边大概看了 TreeMap和TreeSet，更多的细节今后有需求在研究吧，再来看看他们分别实现的接口NavigableSet&#x2F;NavigableMap，他们分别继承了SortedSet&#x2F;SortedMap。</p>
<h2 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h2><p>其中主要的方法都和其名称相符，即导航，查找和指定目标最接近的值，或是大于，或是小于；主要分为两类，找key或者找Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回key值大于或等于指定key的Entry或Key</span></span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">ceilingEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">ceilingKey</span><span class="params">(K key)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小于等于的</span></span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">floorEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">floorKey</span><span class="params">(K key)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不包括等于</span></span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">lowerEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">lowerKey</span><span class="params">(K key)</span>;</span><br><span class="line">Map.Entry&lt;K,V&gt; <span class="title function_">higherEntry</span><span class="params">(K key)</span>;</span><br><span class="line">K <span class="title function_">higherKey</span><span class="params">(K key)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NavigableSet&lt;K&gt; <span class="title function_">descendingKeySet</span><span class="params">()</span>;</span><br><span class="line">NavigableMap&lt;K,V&gt; <span class="title function_">descendingMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>返回按照key值降序的集合；返回的集合和原集合是相互联系的(The descending map is backed by this map)，修改任一集合都会对另外一个集合产生影响；用迭代器遍历集合的同时修改集合，那么遍历的结果是不确定的。下面写几个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDesc</span><span class="params">()</span> &#123;</span><br><span class="line">  NavigableMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="number">1</span>,<span class="string">&quot;one&quot;</span>);</span><br><span class="line">  map.put(-<span class="number">1</span>, <span class="string">&quot;negative one&quot;</span>);</span><br><span class="line">  map.put(<span class="number">56</span>, <span class="string">&quot;fifty six&quot;</span>);</span><br><span class="line">  map.put(<span class="number">9</span>, <span class="string">&quot;nine&quot;</span>);</span><br><span class="line">  map.put(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">  map.put(<span class="number">20</span>, <span class="string">&quot;twenty&quot;</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;before desc---------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; ele: map.entrySet()</span><br><span class="line">      ) &#123;</span><br><span class="line">    System.out.println(ele.getKey() + <span class="string">&quot; &quot;</span> + ele.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NavigableMap&lt;Integer, String&gt; descMap = map.descendingMap();</span><br><span class="line">  System.out.println(<span class="string">&quot;after desc-----------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; ele: descMap.entrySet()</span><br><span class="line">  ) &#123;</span><br><span class="line">    System.out.println(ele.getKey() + <span class="string">&quot; &quot;</span> + ele.getValue());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  descMap.put(<span class="number">100</span>, <span class="string">&quot;one hundred&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;after desc put-------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; ele: map.entrySet()</span><br><span class="line">  ) &#123;</span><br><span class="line">    System.out.println(ele.getKey() + <span class="string">&quot; &quot;</span> + ele.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">before desc---------------------</span><br><span class="line">-<span class="number">1</span> negative one</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">9</span> nine</span><br><span class="line"><span class="number">20</span> twenty</span><br><span class="line"><span class="number">56</span> fifty six</span><br><span class="line">after desc-----------------------</span><br><span class="line"><span class="number">56</span> fifty six</span><br><span class="line"><span class="number">20</span> twenty</span><br><span class="line"><span class="number">9</span> nine</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line">-<span class="number">1</span> negative one</span><br><span class="line">after desc put-------------------</span><br><span class="line">-<span class="number">1</span> negative one</span><br><span class="line"><span class="number">0</span> zero</span><br><span class="line"><span class="number">1</span> one</span><br><span class="line"><span class="number">9</span> nine</span><br><span class="line"><span class="number">20</span> twenty</span><br><span class="line"><span class="number">56</span> fifty six</span><br><span class="line"><span class="number">100</span> one hundred</span><br></pre></td></tr></table></figure>

<p>当我在逆序集合中插入新Entry后，在遍历原来的map也打印了新加入的Entry，所以是相互影响的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回key值小于toKey的Entry组成的Map，也是相互关联的，需要注意的是，在headMap中新增Entry时，新Entry的key值同样不能大于toKey，否则会抛出异常；inclusive用来表示是否包括toKey</span></span><br><span class="line">NavigableMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line"><span class="comment">//对应于headMap，返回大于fromKey的</span></span><br><span class="line">NavigableMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey, <span class="type">boolean</span> inclusive)</span>;</span><br></pre></td></tr></table></figure>

<p>突然感觉没有写的必要？</p>
<h2 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h2><p>set中的操作基本上就是map中对于key的操作，下面放一些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">lower</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">floor</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">ceiling</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">higher</span><span class="params">(E e)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">descendingSet</span><span class="params">()</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement, <span class="type">boolean</span> inclusive)</span>;</span><br></pre></td></tr></table></figure>

<p>唯一有点区别的就是Set中多了迭代器iterator，毕竟Collection继承了Iterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>至于他们的父类Sorted一族也是接口，没什么好看的。在jdk1.8中，为集合新增了Spliterator(并行迭代器?)这个玩意，后边再看吧 - -</p>
]]></content>
      <tags>
        <tag>NavigableMap</tag>
        <tag>NavigableSet</tag>
      </tags>
  </entry>
  <entry>
    <title>一次WEB请求全过程</title>
    <url>/2018/08/21/web-request/</url>
    <content><![CDATA[<h2 id="输入URL"><a href="#输入URL" class="headerlink" title="输入URL"></a>输入URL</h2><p>首先，用户在Web浏览器（如IE）地址栏输入URL，比如：<a href="https://zero22.top/">https://zero22.top</a> 前面的https是协议类型，后面的zero22.top指定被访问的服务器的域名，没有加冒号和端口号表示访问的是默认的端口号80。</p>
<span id="more"></span>

<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>由于所发出的数据要通过被访问主机的IP地址进行传输和路由，所以要先通过DNS服务器将域名解析为IP地址：</p>
<ol>
<li>主机产生一个DNS请求，传递给传输层，通过UDP产生一个UDP报文；再传递给网络层产生一个IP报文，目的地址是DNS服务器的IP地址；在数据链路层通过ARP协议得到到达DNS服务器的下一跳的MAC地址；把数据帧通过以太网传输给DNS服务器。</li>
<li>DNS服务器将收到的帧向上传给传输层，得到UDP报文。通过UDP报文中指定的端口号传给DNS应用程序。这里，由于是内网域名和内网DNS服务器，DNS服务器中有相应的表项，如果不在当地，本地DNS服务器还要向上级的DNS服务器发出DNS查询请求，如此递归直到查到要解析的域名的IP地址。</li>
<li>DNS把通过DNS应答将得到的IP地址返回给请求的主机。</li>
</ol>
<h2 id="HTTP嘶挞哆"><a href="#HTTP嘶挞哆" class="headerlink" title="HTTP嘶挞哆"></a>HTTP嘶挞哆</h2><p>现在，浏览器得到对方的IP地址了，即进入HTTP流程。HTTP的工作流程分为以下四步：</p>
<ol>
<li>通过三次握手建立TCP连接。</li>
<li>客户端发送请求给服务器。</li>
<li>服务器收到请求后，给予相应的响应消息，并传输相应的响应数据给客户端。</li>
<li>客户端接收完服务器返回的信息后，与服务器断开连接。</li>
</ol>
<h3 id="THREE-WAY-HANDSHAKE"><a href="#THREE-WAY-HANDSHAKE" class="headerlink" title="THREE-WAY HANDSHAKE"></a>THREE-WAY HANDSHAKE</h3><p>用Wireshark来看看三次握手：</p>
<p><img src="/fig1.png" alt="总的"></p>
<p>首先我给服务器发送一个TCP报文：<br><img src="/fig2.png" alt="第一次握手"><br>随后服务器端回我一个：<br><img src="/fig3.png" alt="第二次握手"><br>最后我再给服务器发一个：<br><img src="/fig4.png" alt="第三次握手"><br>由上边可以知道，客户端和服务器端发送的Sequence number是没有关系的，各自算各自的。</p>
<p>至于建立连接之后，客户端与服务器端数据的传送，现在不想看了，大概根据对方的ip和mac地址，传到相应的主机？解析后主机在给相应的应用程序？不很清楚，再看吧 - -</p>
]]></content>
      <tags>
        <tag>web请求</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashtable</title>
    <url>/2018/08/22/Hashtable/</url>
    <content><![CDATA[<p>基本上不会用到了，在官方API中这样写道：</p>
<blockquote>
<p>Unlike the new collection implementations, Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable.</p>
</blockquote>
<span id="more"></span>

<p>如果必须需要线程安全，请用HashMap；如果高并发线程安全是必要的，请用ConcurrentHashMap。不过还是来了解一下吧，看看Hashtable为啥被抛弃了。</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">// Make sure the value is not null</span></span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">  <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">      entry.value = value;</span><br><span class="line">      <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEntry(hash, key, value, index);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从put中我们可以知道下面几点：</p>
<ol>
<li>value不能为null，其实key也不能为null；</li>
<li>索引的计算方法 <code>(hash &amp; 0x7FFFFFFF) % tab.length</code> ，这个叫做<strong>除留余数法</strong>，用到了取模，可能会影响效率。</li>
<li>当产生冲突时，用<strong>链地址法</strong>解决冲突，并且采用头插法把新来的插在首位。</li>
</ol>
<p>当经过上面的步骤还没有处理新来的key-value，就交给<code>addEntry</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">  modCount++;</span><br><span class="line"></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">    <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">    rehash();</span><br><span class="line"></span><br><span class="line">    tab = table;</span><br><span class="line">    hash = key.hashCode();</span><br><span class="line">    index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates the new entry.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">  tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>modCount</code>后面再说</p>
<p>首先判断hashtable中的键值对的数量是否超过了阀值，超过了要先扩容再重新计算index，否则直接插入。<br>要注意的是这种情况，在put的过程中，hash冲突了，但是key值不一样，这时候也还是要到<code>addEntry</code>中，但是我们看好像并没有把这个新的key-value插入到链表呀，但其实看看这个<code>new Entry&lt;&gt;(hash, key, value, e)</code> 就会发现key-value是在这个时候被放到<code>e</code>的前边了，还是头插法。</p>
<p>再来继续看<code>rehash</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">  Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">      <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">  table = newMap;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; e = old;</span><br><span class="line">      old = old.next;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">      e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">      newMap[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单：<br> 1.容量扩大一倍加一，最多能有<code>0x7fffffff-8</code>个桶<br> 2.按照新容量重建一个hashtable<br> 3.计算阀值<br> 4.把旧table中的点按照新table的长度重新计算索引，放到新table中，采用头插法</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>很简单，就看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (V)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个其实就是判断是否包含某个value，看下边的containsValue就知道</span></span><br><span class="line"><span class="comment">//判断包含value比判断包含key的代价更高，因为直接判断包含value需要遍历整个hashtable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> contains(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">  Objects.requireNonNull(action);     <span class="comment">// explicit check required in case</span></span><br><span class="line">                    <span class="comment">// table is empty.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">  Entry&lt;?, ?&gt;[] tab = table;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;?, ?&gt; entry : tab) &#123;</span><br><span class="line">    <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">      action.accept((K)entry.key, (V)entry.value);</span><br><span class="line">      entry = entry.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是jdk1.8新增的，支持lambda表达式，下次要遍历时可以<code>.</code>一下看看有没有forEach， 有的话就可以这样遍历了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable&lt;Integer, String&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">hashtable.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">hashtable.put(<span class="number">0</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">hashtable.put(<span class="number">5</span>, <span class="string">&quot;five&quot;</span>);</span><br><span class="line">hashtable.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">hashtable.put(<span class="number">100</span>, <span class="string">&quot;hundred&quot;</span>);</span><br><span class="line">hashtable.put(<span class="number">55</span>, <span class="string">&quot;fifty five&quot;</span>);</span><br><span class="line"></span><br><span class="line">hashtable.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;key: &quot;</span> + key + <span class="string">&quot; value: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line"><span class="comment">//output----------------------------------------------</span></span><br><span class="line">key: <span class="number">55</span> value: fifty five</span><br><span class="line">key: <span class="number">0</span> value: two</span><br><span class="line">key: <span class="number">100</span> value: hundred</span><br><span class="line">key: <span class="number">1</span> value: one</span><br><span class="line">key: <span class="number">2</span> value: two</span><br><span class="line">key: <span class="number">5</span> value: five</span><br></pre></td></tr></table></figure>

<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h4><p>上面看到了一个变量，叫做<code>modCount</code>，我理解为<strong>修改次数</strong>，在绝大多数集合或Map中都能看到这个值(至于是不是绝大多数我也不太确定，后面看的多了在作修改)，看一下官方对这个值的解释：</p>
<blockquote>
<p>The number of times this Hashtable has been structurally modified<br>Structural modifications are those that change the number of entries in<br>the Hashtable or otherwise modify its internal structure (e.g.,<br>rehash).  This field is used to make iterators on Collection-views of<br>the Hashtable fail-fast.  (See ConcurrentModificationException).</p>
</blockquote>
<p>大概就是当<code>Hashtable</code>发生结构变化(比如增删entry、<code>rehash</code>等)时，这个值就会自加一表示<code>Hashtable</code>被修改了。这个值主要用于<code>iterator</code>的<code>fail-fast</code>机制，对于该机制<code>Hashtable</code>也作了解释：</p>
<blockquote>
<p>if the Hashtable is structurally modified at any time<br>after the iterator is created, in any way except through the iterator’s own<br>remove method, the iterator will throw a ConcurrentModificationException.</p>
</blockquote>
<p>当迭代器创建后，任何非迭代器产生的结构变化都会抛出<code>ConcurrentModificationException</code>异常，再找找具体的使用吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">  Objects.requireNonNull(function);     <span class="comment">// explicit check required in case</span></span><br><span class="line">                      <span class="comment">// table is empty.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">  Entry&lt;K, V&gt;[] tab = (Entry&lt;K, V&gt;[])table;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">    <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">      entry.value = Objects.requireNonNull(</span><br><span class="line">        function.apply(entry.key, entry.value));</span><br><span class="line">      entry = entry.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上边的<code>forEach</code>也有用到，来分析一下：</p>
<ol>
<li>首先在任何操作之前，记录此时的<code>modCount</code>值</li>
<li>遍历hashtable进行替换操作</li>
<li>每当替换一个<code>entry.value</code>后，都要比较现在的<code>modCount</code>和刚在记录的<code>expectedModCount</code>是否一致，如果不一致就会抛出异常。</li>
</ol>
<p>看起来似乎可以保证并发安全? 不！再来看看官方说明：</p>
<blockquote>
<p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.<br>the fail-fast behavior of iterators should be used only to detect bugs.</p>
</blockquote>
<p><code>fail-fast</code>机制只用来检测程序bug！</p>
<h4 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h4><p>参考<a href="https://www.nowcoder.com/questionTerminal/95e4f9fa513c4ef5bd6344cc3819d3f7?pos=101&mutiTagIds=570&orderByHotValue=1">这里</a><br>除了<code>fail-fast</code>，还有另一种机制<code>fail-safe</code>，简单说来就是：</p>
<blockquote>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>fail-fast</tag>
        <tag>Hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap与Hashtable的异同点</title>
    <url>/2018/08/23/hashmap-hashtable/</url>
    <content><![CDATA[<p>总结一下<code>HashMap</code>和<code>Hashtable</code>的区别，可能会不全，后面有发现了再补充。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>这应该是最明显的一点不同了，<code>HashMap</code>不是线程安全的，但是<code>Hashtable</code>是的，看一下Hashtable中的方法，基本上都加了<code>synchronized</code>，但是呢，这种同步实在是太粗糙了，所以在并发的情况下才会推荐使用<code>ConcurrentHashMap</code>吧。</p>
<span id="more"></span>

<h3 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h3><h4 id="默认容量"><a href="#默认容量" class="headerlink" title="默认容量"></a>默认容量</h4><p>在构建相应的实例时，如果没有指定<code>initialCapacity</code>，<code>HashMap</code>默认指定为16，<code>Hashtable</code>默认指定为11：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Hashtable默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建桶"><a href="#创建桶" class="headerlink" title="创建桶"></a>创建桶</h4><p>他们两个实际创建<strong>桶</strong>的时机也是不一样的，HashMap应该是懒加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                        initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">    initialCapacity = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">  table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];     <span class="comment">// 在这里就为桶分配内存了</span></span><br><span class="line">  threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是在HashMap的构造函数中，找不到类似的为桶分配内存的命令，</span></span><br><span class="line"><span class="comment">//因为在分配内存是在resize()方法中，这里截取部分</span></span><br><span class="line">Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;    <span class="comment">// 由于没有分配内存，所以此时table还是null，因此oldCap == 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line"><span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)     <span class="comment">// 注意如果新建HashMap时指定了initialCapacity，那么会根据这个值初始化 threshold</span></span><br><span class="line">  newCap = oldThr;</span><br><span class="line"><span class="keyword">else</span> &#123;     <span class="comment">// 这里就是啥都没指定的</span></span><br><span class="line">  newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">  newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;    <span class="comment">// 确定新阀值</span></span><br><span class="line">  <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">  newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">       (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">threshold = newThr;</span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];     <span class="comment">// 呐呐，在这分配内存</span></span><br><span class="line">table = newTab;     <span class="comment">// 我们的table不为null了</span></span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><code>Hashtable</code>计算元素的hash值是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>

<p>而<code>HashMap</code>就比较精致了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个是求余，一个是位运算，效率肯定也不一样。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>虽然从整体上来看，<code>HashMap</code>和<code>Hashtable</code>都是用链地址法解决冲突，但是1.8的<code>HashMap</code>作了优化，当冲突超过一定时，会将链表进行树化。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>两个数据结构扩容的方式也不同，<code>Hashtable</code>就比较简单了，扩大容量后，把旧table中的点遍历一遍，重新计算hash值采用<strong>头插法</strong>放到新table中；而<code>HashMap</code>就不一样了，除了要考虑树的情况，在从旧table放到新table的过程中，是先把旧table中的冲突链表或树，分成两份，放进新table中(具体的可以看这：<a href="https://zero22.top/2018/08/17/HashMap-%E4%B8%80/">https://zero22.top/2018/08/17/HashMap-%E4%B8%80/</a>)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比一下<code>HashMap</code>和<code>Hashtable</code>，不得不佩服Josh Bloch、Arthur van Hoff、Neal Gafter、Doug Lea等作者，总是在不断的优化、创新，让我看到这么漂亮的<strong>code</strong>，感谢。 - -</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
        <tag>Hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra-单源最短路径问题</title>
    <url>/2018/09/08/dijkstra/</url>
    <content><![CDATA[<p>关于图论中的算法大多还是数据结构课上讲的, 过了这么久突然想起来, 就来复习复习吧。这里看一下<code>Dijkstra</code>算法再有向图中的使用。具体的需求就是给定一个图和一个点, 求出从该点出发到各个点的最短距离。下边放一张从<code>wiki</code>拿来的图:</p>
<span id="more"></span>
<p><img src="/fig1.gif" alt="来自wiki"></p>
<p>不过这张是无向图, 但是大致的流程是类似的。</p>
<p>下面通过一个更具体是示例来说明, 我们的图如下所示:<br><img src="/fig2.png" alt="example"></p>
<p>需求: 从1开始, 到各个点的最短距离<br>准备: 我们可以利用三个数组存储相关的信息</p>
<ul>
<li>sign[] 记录已经被访问过的点</li>
<li>shortest[] 保存当前点到<code>1</code>的最短距离</li>
<li>precursor[] 记录<code>1</code>到当前点的路径中, 当前点的前驱点</li>
</ul>
<p>初始化:<br>根据图将三个数组分别初始化为, 规定-1为无穷远<br>sign[] 1, 0, 0, 0, 0<br>shortest[] -1, 3, -1, -1, 30<br>precursor[] 1, 1, 1, 1, 1</p>
<p>过程:</p>
<ol>
<li>找到距离<code>1</code>最短的点, 一看是<code>2</code>, 距离为3, 把<code>2</code>标记为访问过的, 更新<code>sign</code>数组;</li>
<li>然后从<code>2</code>找没标记过的点<code>x</code>, 看<code>2</code>到<code>x</code>的距离加上<code>0</code>到<code>2</code>的距离是否小于<code>0</code>到<code>x</code>的距离, 如果小于的话, 就更新<code>shortest</code>数组;</li>
<li>把<code>x</code>的前缀改为<code>2</code>, 更新<code>precursor</code>数组。</li>
</ol>
<p>经过这些操作后, 三个数组变成这样了:</p>
<p>sign[] 1, 1, 0, 0, 0<br>shortest[] -1, 3, 28, 11, 30<br>precursor[] 1, 1, 2, 2, 1</p>
<p>接下来最短距离是11, 为<code>4</code>, 再从<code>4</code>开始重复上述步骤:</p>
<p>sign[] 1, 1, 0, 1, 0<br>shortest[] -1, 3, 15, 11, 23<br>precursor[] 1, 1, 4, 2, 4</p>
<p>直到所有的点都标记为访问过的, 最终结果为:</p>
<p>sign[] 1, 1, 1, 1, 1<br>shortest[] -1, 3, 15, 11, 23<br>precursor[] 1, 1, 4, 2, 4</p>
<p>根据这些记录我们可以得出<code>1</code>到各个点的最短距离以及路径:<br>1-&gt;2 3 1-&gt;2<br>1-&gt;3 15 1-&gt;2-&gt;4-&gt;3<br>1-&gt;4 11 1-&gt;2-&gt;4<br>1-&gt;5 23 1-&gt;2-&gt;4-&gt;5</p>
<p>这里说一下路径的计算过程, 以1-&gt;3为例, 根据<code>precursor</code>记录的前驱, 我们看到3的前驱是<code>precursor[3]=4</code>, 即4-&gt;3, 4的前驱<code>precursor[4]=2</code>, 即2-&gt;4-&gt;3, 再看2的前驱<code>precursor[2]=1</code>, 即1-&gt;2-&gt;4-&gt;3, 这样就求出了完整的路径。</p>
<p>下面贴份code, 写的不好看请原谅- -:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Dijstra 算法 有向图，有权值，求一个点到各个点的最短距离</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 边的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 保存图的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span>[][] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                a[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">            a[start][end] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">(<span class="type">int</span>[][] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length; j ++) &#123;</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本思路:</span></span><br><span class="line"><span class="comment">     * 1. 从0开始, 找到最短的一条边, 假设为k点, 即0-k最短</span></span><br><span class="line"><span class="comment">     * 2. 从k点开始, 找k到各个点的距离, 如果比0到它更短, 则更新最短距离, 并且更新前驱节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doDijkstra</span><span class="params">(<span class="type">int</span>[][] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">// 标记已经访问过的点</span></span><br><span class="line">        <span class="type">int</span>[] sign = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 存放当前0到个点的最短距离</span></span><br><span class="line">        <span class="type">int</span>[] shortest = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 存放当前节点的前驱</span></span><br><span class="line">        <span class="type">int</span>[] precursor = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">// 循环次数?</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最短距离</span></span><br><span class="line">        System.arraycopy(a[<span class="number">0</span>], <span class="number">0</span>, shortest, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// 0开始的, 所以0默认已经访问过了</span></span><br><span class="line">        sign[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 从shortest中找到没标记过的点, 且距离最小的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sign[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shortest[i] &gt; <span class="number">0</span> &amp;&amp; shortest[i] &lt; min) &#123;</span><br><span class="line">                        min = shortest[i];</span><br><span class="line">                        pos = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记访问</span></span><br><span class="line">            sign[pos] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 修改最短路径</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[pos][i] &gt; <span class="number">0</span> &amp;&amp; sign[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// -1标识无穷远, 能到达肯定比无穷远要好</span></span><br><span class="line">                    <span class="keyword">if</span> (shortest[i] == -<span class="number">1</span> || a[pos][i] + shortest[pos] &lt; shortest[i]) &#123;</span><br><span class="line">                        shortest[i] = a[pos][i] + shortest[pos];</span><br><span class="line">                        <span class="comment">// 修改前驱</span></span><br><span class="line">                        precursor[i] = pos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;shortest: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span> + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">            System.out.print(<span class="number">0</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            dfs(precursor, i);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归输出, 为了从头输出, 好看一点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end != <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(a, a[end]);</span><br><span class="line">            System.out.print(end + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        Dijkstra.input(n, k, edges);</span><br><span class="line">        <span class="comment">// 打印图</span></span><br><span class="line">        <span class="comment">//Dijkstra.printEdges(edges);</span></span><br><span class="line">        <span class="comment">// 计算过程</span></span><br><span class="line">        doDijkstra(edges);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>高级同步结构</title>
    <url>/2018/09/07/juc/</url>
    <content><![CDATA[<p>这些同步结构都在<code>java.util.concurrent</code>并发包下，这里只看一下基础的用法。</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>直接用API来介绍吧</p>
<blockquote>
<p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
</blockquote>
<span id="more"></span>
<p>简单说来就是让一些线程等待其他线程的操作完成</p>
<p>写一个示例程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.countdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);      <span class="comment">// 这里一般对应的操作数，这是几，就要有几次countDown操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;                              <span class="comment">// 新建5个线程跑起来</span></span><br><span class="line">             <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(i, countDownLatch);</span><br><span class="line">             myThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;prepare to wait for other thread finish work...&quot;</span>);</span><br><span class="line">        countDownLatch.await();                                     <span class="comment">// 要点1</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;all threads have finish work!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tId;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(<span class="type">int</span> tId, CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tId = tId;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * (<span class="number">5</span>-tId));                           <span class="comment">// 模拟工作, 不要介意为啥这样写</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread i=&quot;</span> + tId + <span class="string">&quot; has finish work&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();                                 <span class="comment">// 要点2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上运行结果:<br><img src="/fig1.gif" alt="CountDownLatch"></p>
<p>注意我注释中标记了要点的地方，<code>CountDownLatch</code>主要操作方式就是<code>await/countDown</code>，在该程序中，<code>await</code>在<code>main</code>方法中执行，从线程方面来看，就是我们的<code>main</code>线程在等待5个<code>MyThread</code>线程执行结束，就是这样</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>再来看看API中的第一句</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.<br>允许一堆线程在<code>barrier</code>互相等待</p>
</blockquote>
<p>看个示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.cyclicbarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, ()-&gt;&#123;            <span class="comment">// 要点1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;all thread arrive barrier !! &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;let&#x27;s rest a while&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++) &#123;</span><br><span class="line">            <span class="type">Mythread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mythread</span>(cyclicBarrier, j);</span><br><span class="line">            mythread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> j;                                                          <span class="comment">// 休息时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mythread</span><span class="params">(CyclicBarrier cyclicBarrier, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="built_in">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(j*<span class="number">1000</span>);                                       <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run i=&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();                                      <span class="comment">// 要点2</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:<br><img src="/fig2.gif" alt="CyclicBarrier"></p>
<p>先说一下要点1，在创建<code>CyclicBarrier</code>对象时可以传递一个<code>Runnable</code>对象，这个<code>Runnable</code>会在所有的相互等待的线程都到达<code>barrier</code>时执行，从运行结果可以看出来，当我们的5个线程都做完了工作执行<code>await</code>之后，<code>Runnable</code>定义的操作就会运行。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>这里简单写一下二者的区别</p>
<ol>
<li><code>CountDownLatch</code>是一次性的, 因为初始化中传递的<code>count</code>在<code>CountDownLatch</code>中是无法被恢复的; 但是<code>CyclicBarrier</code>是可以用多次的，从运行结果我们也可以看出来, 这是因为<code>CyclicBarrier</code>内部把最初的值保留在<code>parties</code>中, 每次执行减法的是它的拷贝<code>count</code>, 当<code>CyclicBarrier</code>运行完一轮后, 通常会自动调用<code>nextGeneration</code>方法, 在该方法内部又把<code>parties</code>赋值给<code>count</code>了</li>
<li>逻辑上来讲, <code>CountDownLatch</code>是让A组线程等待B组线程全部执行完, 然后A组线程继续做该做的; <code>CyclicBarrier</code>是A组线程中的每个线程都做一些事到达<code>barrier</code>, 即进入等待状态后, <code>CyclicBarrier</code>可以做个总结之类的, 然后A组线程中的每一个又开始继续做事, 这样循环下去</li>
</ol>
]]></content>
      <tags>
        <tag>CountDownLatch</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的流</title>
    <url>/2018/09/12/stream-in-java/</url>
    <content><![CDATA[<p>Java类库中的I&#x2F;O类分成<strong>输入</strong>和<strong>输出</strong>两部分, 可以在JDK文档的类层次结构中看到。通过继承, 任何自<code>InputStream</code>和<code>Reader</code>派生而来的类都含有名为<code>read</code>的基本方法, 用于读取单个字节或字节数组。同样, 任何继承自<code>OutputStream</code>和<code>Writer</code>而来的类都含有名为<code>write</code>的基本方法, 用于写单个字节或字节数组。我们很少使用单一的类来创建流对象, 而是通过叠合多个对象来提供所期望的功能, 也就是类外套上其他的类, 即装饰器设计模式。</p>
<span id="more"></span>

<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p><code>InputStream</code>的作用是用来表示那些从不同数据源产生输入的类。这些数据源包括但不限于:</p>
<ol>
<li>字节数组</li>
<li>String对象</li>
<li>文件</li>
<li>管道, 工作方式和实际管道类似, 从一端输入, 从另一端输出</li>
</ol>
<p>这些数据源都有对应的<code>InputStream</code>子类, 一般称为<strong>介质流</strong>:</p>
<ol>
<li>ByteArrayInputStream</li>
<li>StringBufferInputStream(Deprecated)</li>
<li>FileInputStream</li>
<li>PipedInputStream</li>
</ol>
<p>可以把以上输入流归为<strong>介质流</strong>, 因为这些流是和具体的源数据打交道的。<br>另外, <code>FilterInputStream</code>也是一种输入流, 只不过它是套在<em>介质流</em>之外的, 可以称作<strong>包装流&#x2F;过滤流</strong>, 主要有以下几种:</p>
<ol>
<li>BufferedInputStream</li>
<li>DataInputStream</li>
<li>PushbackInputStream</li>
</ol>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>和<code>InputStream</code>对应, <code>OutputStream</code>流中的<em>介质流</em>也主要有以下几种:</p>
<ol>
<li>ByteArrayOutputStream</li>
<li>FileOutputStream</li>
<li>PipedOutputStream</li>
</ol>
<p><em>包装流&#x2F;过滤流</em>主要有:</p>
<ol>
<li>BufferedOutputStream</li>
<li>DataOutputStream</li>
<li>PrintStream</li>
</ol>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><h4 id="如何按照指定编码读取文件"><a href="#如何按照指定编码读取文件" class="headerlink" title="如何按照指定编码读取文件?"></a>如何按照指定编码读取文件?</h4><p> 读取文件一般就想到用<code>FileInputStream</code>, 但是我们看下它的构造方法, 并没有提供”编码”这项功能, 其实基本上字节流都没有指定编码这项功能, 在一番查找下, 才最终在<code>InputStreamReader</code>中找到了<code>charset</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span></span><br><span class="line">    <span class="keyword">throws</span> UnsupportedEncodingException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;charsetName&quot;</span>);</span><br><span class="line">    sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, Charset cs)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;charset&quot;</span>);</span><br><span class="line">    sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, CharsetDecoder dec)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (dec == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;charset decoder&quot;</span>);</span><br><span class="line">    sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, dec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到编码, 其实<code>String</code>类的构造函数中也提供了指定编码的功能:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], <span class="type">int</span> offset, <span class="type">int</span> length, Charset charset)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;charset&quot;</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="built_in">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InputStreamReader</code>和<code>OutputStreamWriter</code>是连接<em>字节流</em>和<em>字符流</em>的桥梁:<br><code>InputStreamReader</code>用指定的编码或者默认平台编码从字节中读取数据并把他们解码为字符<br><code>OutputStreamWriter</code>用指定的编码或默认平台编码把写入的字符编码为相应的字节</p>
<h4 id="如何采用”追加”方式向文件中写东西"><a href="#如何采用”追加”方式向文件中写东西" class="headerlink" title="如何采用”追加”方式向文件中写东西?"></a>如何采用”追加”方式向文件中写东西?</h4><p>这个平时还真没注意, 但是在<code>c</code>或<code>python</code>我还记得是以<code>a</code>方式打开文件, 然后翻了<code>FileOutputStream</code>发现<code>java</code>中并没有所谓的”方式”, 在<code>write</code>方法中会隐藏一个<code>append</code>字段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    writeBytes(b, <span class="number">0</span>, b.length, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    writeBytes(b, off, len, append);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len, <span class="type">boolean</span> append)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>那么这个字段值是在哪指定的呢? 再看它的构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file, <span class="type">boolean</span> append)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name, <span class="type">boolean</span> append)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在构造文件输出流时就会让你选择是否以追加的模式构建流.</p>
]]></content>
      <tags>
        <tag>io</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Huffman Code</title>
    <url>/2018/09/17/huffman-code/</url>
    <content><![CDATA[<p>前两天做笔试题时碰到了久违的哈夫曼编码, 想当初还用c实现过了, 但是做题的时候突然就忘了哈夫曼的实现过程- -，下面记录一下具体的步骤。</p>
<span id="more"></span>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>计算各个待编码字符出现的频率. 比如<code>HELLOWORLD</code>，一共10个字符，<code>H</code> <code>E</code> <code>W</code> <code>R</code> <code>D</code>各1次，<code>L</code>3次，<code>O</code>2次，各自出现的频率就是<strong>次数&#x2F;总数</strong>。</li>
<li>在频率中找最小的两个值，相加，结果放进频率集中。这样做的目的是，频率越小，说明出现的次数相对越少，那么在进行<code>Huffman</code>编码时，这些小频率的字符就在<code>Huffman</code>树的底层，则生成的编码就越长，相对的，频率高的就出现在<code>Huffman</code>树的高层，生成的编码越短，这样就可能起到压缩的效果。例如当前的频率集为<code>0.1, 0.1, 0.1, 0.1, 0.1, 0.2, 0.3</code>，选取两个0.1进行操作，新的频率集为<code>0.1, 0.1, 0.1, 0.2, 0.2, 0.3</code>。</li>
<li>构造<code>Huffman</code>树:<br><img src="/fig1.png" alt="enter description here"></li>
<li>重复第二步直到构造出完整的<code>Huffman</code>树，接下来就是编码了，很简单，左右子树分别标记为0&#x2F;1，如下图:<br><img src="/fig2.png" alt="enter description here"><br>每个字符的编码就是从根节点到该节点路径上的标识，比如<code>W</code>为<code>000</code>，<code>H</code>为<code>1010</code>。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>流程大概就是这样，从图中也可以看出来，<code>Huffman</code>编码是一种前缀编码，即每个编码不会是另外编码的前缀，因为每个字符都是叶子节点，如果有一个编码是其他编码的前缀，那么该编码的字符一定不是叶子节点。</p>
]]></content>
      <tags>
        <tag>huffman</tag>
        <tag>哈夫曼</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7开放防火墙端口</title>
    <url>/2018/09/17/open-firewall-in-centos7/</url>
    <content><![CDATA[<p>Centos7之前一般是用<code>iptables</code>管理防火墙相关内容的，一般用到的就是开放一个端口供我们的应用使用，其命令如下:<br><code>iptables -I INPUT -p tcp --dport 11111 -j ACCEPT</code></p>
<span id="more"></span>

<p>添加端口:<br><img src="/fig1.png" alt="enter description here"></p>
<p>删除端口:<br><img src="/fig2.png" alt="enter description here"></p>
<p>Centos7一般新增了<code>firewall-cmd</code>，用来管理防火墙<br>首先开启<br><code>systemctl start firewalld</code></p>
<p>查看状态<br><code>firewall-cmd --state</code></p>
<p>添加端口<br><code>firewall-cmd --add-port=11111/tcp --zone=public --permanent</code></p>
<p>查看端口<br><code>firewall-cmd --list-ports</code></p>
<p><img src="/fig3.png" alt="enter description here"></p>
<p>添加端口后一般是用 <code>firewall-cmd --reload</code>来更新使其生效</p>
<p><code>firewall</code>中的<code>zone</code>，不知道和<code>iptables</code>中的<code>chain</code>有没有关系，用<code>firewall-cmd</code>添加的端口在<code>iptables -L -n</code>中也可以看到(好像是废话- -)<br><img src="/fig4.png" alt="enter description here"></p>
<p>删除端口<br><code>firewall-cmd --remove-port=11111/tcp</code></p>
<p>基本的使用over.</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 51. N-Queens I</title>
    <url>/2019/03/30/n-queens/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p>
</blockquote>
<span id="more"></span>

<hr>
<p>Analysis:</p>
<p>皇后问题是一个比较经典的递归回溯类的问题，一般思路就是从第一排第一列开始放，判断是否会冲突，如果可以放就递归到下一排第一列继续放，否则就到下一列，如果这一列都不行，就回溯到上一排的下一列。</p>
<hr>
<p>Answer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 数组下标表示行, 值表示列</span></span><br><span class="line">        <span class="type">int</span>[] pos = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            pos[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(pos, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] pos, <span class="type">int</span> row, <span class="type">int</span> line)</span> &#123;</span><br><span class="line">        <span class="comment">// 跳出条件, pos[n-1] != -1</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt;= pos.length) &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pos.length; i ++) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pos.length; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != pos[i]) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sb.toString());</span><br><span class="line">                temp.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> line; j &lt; pos.length; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isValid(pos, row, j)) &#123;</span><br><span class="line">                    pos[row] = j;</span><br><span class="line">                    dfs(pos, row+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    pos[row] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span>[] pos, <span class="type">int</span> row, <span class="type">int</span> line)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] == line &amp;&amp; pos[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (((row-i) == (line-pos[i])) || ((i-row) == (line-pos[i]))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>More:</p>
<p>这种递归回溯的效率还是比较低的，我认为主要耗时的操作就是判断当前摆放的<code>皇后</code>是否会和前排摆好的<code>皇后</code>产生冲突，在看了别人的解答后，学到了一种快速判断的方法。</p>
<p>这种方法非常巧妙，利用了<code>棋盘</code>(二维数组)坐标的特点，例如下边分别把各个点的横纵坐标进行相加和相减:</p>
<table>
<thead>
<tr>
<th>横</th>
<th>纵</th>
<th>相</th>
<th>加</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>横</th>
<th>纵</th>
<th>相</th>
<th>减</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>-2</td>
<td>-1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>-3</td>
<td>-2</td>
<td>-1</td>
<td>0</td>
</tr>
</tbody></table>
<p>可以发现相加后值相等的都在同一左斜对角线，相减则相反，利用这一特性，可以快速判断<code>皇后</code>们是不是在对角线上!!!</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 60. Permutation Sequence</title>
    <url>/2019/04/11/permutation-sequence/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.<br>By listing and labeling all of the permutations in order, we get the following sequence for n &#x3D; 3:<br>1.”123”<br>2.”132”<br>3.”213”<br>4.”231”<br>5.”312”<br>6.”321”<br>Given n(1~9) and k, return the k<sup>th</sup> permutation sequence.  </p>
</blockquote>
<span id="more"></span>

<hr>
<p>Analysis:  </p>
<p>通过观察示例我们会发现，当<code>n=3</code>时，第一位上每个数字重复的个数为2，这个重复的个数其实是由后边几位有多少种排列方式决定的。比如当<code>n=4</code>时，第一位上的重复的个数是由后边<code>3</code>位全拍列个数决定的，那就是第一位上会重复<code>6</code>次。也就是说，所有的全拍列已经被各个位上相同的数字分好了组，通过这种方式，我们可以从第一位开始，只用循环判断<code>n</code>次就能找到指定位置的排列组合。</p>
<p>Answer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] fac=&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            nums.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            index = k / fac[i];</span><br><span class="line">            res += nums.remove(index);</span><br><span class="line">            k = k % fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>More:</p>
<p>这里的k为什么要提前减1呢?</p>
<p>举个例子，当<code>n=3</code>时，比如说我们要求第二个，此时<code>k=2</code>。</p>
<p>如果我们不把k减1，得到的<code>index</code>为1，余数为0，那么按照<code>123</code>来取，第一位取到的就是<code>2</code>了。进一步归纳一下，如果k不减1，当余数为0时，其实是上一组（index-1）的最后一个。这样就会使得处理起来不那么方便。</p>
<p>如果我们把k减1，就是把全拍列的组合是从0开始计数的。按照上边的例子，此时<code>index</code>为0，余数为1，也就是第1组的第二个，要知道我们存储<code>nums</code>的数组也是从0开始计算的，这样就不用考虑当余数为0时是<code>index</code>还是<code>index-1</code>的问题，可以统一处理，比较方便。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76. Minimum Window Substring</title>
    <url>/2019/04/25/Minimum-Window-Substring/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
</blockquote>
<span id="more"></span>

<hr>
<p>Analysis:</p>
<p>在S串中找到一个子串，包含T中所有的字符。可以通过滑动窗口来求解，所谓的窗口在这就可以理解为S的子串。利用数组分别保存窗口中各个字符的个数和T串中字符的个数，同时设置一个计数器，用来统计窗口中的符合T串的字符的个数。那么如何判断哪些字符是在T串中的呢，只需要判断在窗口中该字符出现的次数是否小于T串中该字符出现的次数就好了。</p>
<p>Answer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 在s中找一个子串，包含t中所有的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenS</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenT</span> <span class="operator">=</span> t.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sFre = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">58</span>];</span><br><span class="line">        <span class="type">int</span>[] tFre = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">58</span>];</span><br><span class="line">        <span class="comment">// 窗口边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小窗口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lenS + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录当前窗口匹配的字符个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lenT; i ++) &#123;</span><br><span class="line">            tFre[t.charAt(i) - <span class="string">&#x27;A&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如 s=&quot;adceba&quot; t=&quot;abc&quot;, 那么 l &lt;= 3, 如果l超过3,后边所有字符长度也不够t的长度了</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lenS - lenT) &#123;</span><br><span class="line">            <span class="comment">// 窗口右标没有越界, 并且还没有把t串完全包含</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; lenS &amp;&amp; count &lt; lenT) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">                sFre[temp - <span class="string">&#x27;A&#x27;</span>] ++;</span><br><span class="line">                <span class="comment">// 当s频率小于t中的频率, 说明该字符包含在t中 </span></span><br><span class="line">                <span class="keyword">if</span> (sFre[temp - <span class="string">&#x27;A&#x27;</span>] &lt;= tFre[temp - <span class="string">&#x27;A&#x27;</span>]) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                r ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count &gt;= lenT) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s.charAt(l);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; end - start) &#123;</span><br><span class="line">                    start = l;</span><br><span class="line">                    end = r;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sFre[temp - <span class="string">&#x27;A&#x27;</span>] &lt;= tFre[temp - <span class="string">&#x27;A&#x27;</span>]) &#123;</span><br><span class="line">                    count --;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sFre[temp - <span class="string">&#x27;A&#x27;</span>] --;</span><br><span class="line">                l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">return</span> <span class="variable">start</span> <span class="operator">=</span>= -<span class="number">1</span>? <span class="string">&quot;&quot;</span>: s.substring(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 50. Pow(x, n)</title>
    <url>/2019/03/27/leetcode50/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Implement pow(x, n), which calculates x raised to the power n (x<sup>n</sup>).</p>
</blockquote>
<span id="more"></span>

<hr>
<p>Analysis:</p>
<p>首先观察幂的格式，例如：</p>
<p>100<sup>5</sup> &#x3D; 100<sup>(0101)<sub>2</sub></sup> &#x3D; 100<sup>(0100)<sub>2</sub></sup> * 100<sup>(0001)<sub>2</sub></sup></p>
<p>这样一来，我们只用从低位到高位遍历一遍指数的大小，就能计算出结果.</p>
<hr>
<p>Answer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> n;</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">                x = x * x;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>注意:  </p>
<ol>
<li><p>把指数从<code>int</code>转化为<code>long</code>类型是由于这里指数的范围是[-2<sup>31</sup>, 2<sup>31</sup>-1]，当指数为负数时，处理方法是按指数绝对值计算最后结果求倒数，如果不转化为<code>long</code>类型，当指数值为-2<sup>31</sup>时，取其绝对值就会超过<code>int</code>类型范围.</p>
</li>
<li><p>在判断指数各个位的值时，要注意 <code>&amp;</code>&#x2F;<code>==</code> 的优先级关系，因此这里与操作需要加括号.</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 84. Largest Rectangle in Histogram</title>
    <url>/2019/05/18/Largest-Rectangle-in-Histogram/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
</blockquote>
<span id="more"></span>

<p>Analysis:</p>
<p>暴力循环是可以求出来，但是超时。通过观察可以发现，最大的面积一般不是由最高的柱决定，但是往往都会把它包含起来。所以，在找最大面积时，可以在找到了一个顶点时，再往前扫描计算面积。拿示例来说，0位置的2是一个顶点，计算面积；往后到了3位置的6又是一个顶点，往前扫描分别得到6， 10等。如此一来，就避免了很多无谓的计算。由于是在找到顶点时再计算面积，所以需要保存前面的值来判断哪个值是顶点，使用单调递增栈这一数据结构可以保存这些信息。单调递增栈，首先是个栈，其次保存的数据是递增的，当入栈的值小于栈顶时，对栈顶元素做出栈操作，直到当前值可以作为栈顶元素。</p>
<p>Answer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存最大的长方形</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出的栈顶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nowH</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单调递增栈</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里循环到 heights.length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= heights.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((stack.isEmpty()) || (i &lt; heights.length &amp;&amp; heights[stack.peekLast()] &lt;= heights[i])) &#123;</span><br><span class="line">                <span class="comment">// 栈里边放的是位置，便于计算宽</span></span><br><span class="line">                stack.offerLast(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 取出的栈顶当做当前矩形的高</span></span><br><span class="line">                nowH = stack.pollLast();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 由于栈中是递增顺序的，取出栈顶nowH后，栈如果为空且nowH前边原本是有元素的，说明nowH比前边的都要小，也就是以[nowH]为高时可以</span></span><br><span class="line">                <span class="comment">//      把前边的也包含住，所以宽为 i</span></span><br><span class="line">                <span class="comment">// 2. 如果取出nowH后，栈不为空，根据相应位置计算宽</span></span><br><span class="line">                maxR = Math.max(maxR, heights[nowH]*(stack.isEmpty()? i: (i - <span class="number">1</span> - stack.peekLast())));</span><br><span class="line"></span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 44. Wildcard Matching</title>
    <url>/2019/03/27/Wildcard-Matching/</url>
    <content><![CDATA[<p>Question:  </p>
<blockquote>
<p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;?&#x27; Matches any single character.</span><br><span class="line">&#x27;*&#x27; Matches any sequence of characters (including the empty sequence).</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<hr>
<p>Analysis:  </p>
<p><code>*</code>可以匹配任意内容包括空字符串，所以这个<code>*</code>要匹配多少就是最根本的问题。</p>
<hr>
<p>Answer:</p>
<ol>
<li>动态规划</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="comment">// value[i][j] 表示前i个模式串字符 和 前j个匹配串是否匹配</span></span><br><span class="line">        <span class="type">boolean</span> value[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[p.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        value[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s.length(); j ++) &#123;</span><br><span class="line">            value[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历模式串进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= p.length(); i ++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> p.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                value[i][<span class="number">0</span>] = value[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s.length(); j ++) &#123;</span><br><span class="line">                    value[i][j] = value[i - <span class="number">1</span>][j] || value[i][j - <span class="number">1</span>] || value[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                value[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s.length(); j ++) &#123;</span><br><span class="line">                    value[i][j] = value[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                value[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s.length(); j ++) &#123;</span><br><span class="line">                    value[i][j] = (value[i - <span class="number">1</span>][j - <span class="number">1</span>]) &amp;&amp; (p.charAt(i - <span class="number">1</span>) == s.charAt(j - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value[p.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双指针</li>
</ol>
<p>通过指针记录<code>*</code>匹配的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pstar_idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sstar_idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sp &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pp &lt; p.length() &amp;&amp; (s.charAt(sp) == p.charAt(pp) || p.charAt(pp) == <span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">                sp ++;</span><br><span class="line">                pp ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pp &lt; p.length() &amp;&amp; p.charAt(pp) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                pstar_idx = pp;</span><br><span class="line">                sstar_idx = sp;</span><br><span class="line">                pp ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录&#x27;*&#x27;的位置，当后面不匹配时，就把不匹配的字符归到&#x27;*&#x27;里，从下一个在进行匹配操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pstar_idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                pp = pstar_idx + <span class="number">1</span>;</span><br><span class="line">                sp = ++ sstar_idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pp &lt; p.length() &amp;&amp; (p.charAt(pp) == <span class="string">&#x27;*&#x27;</span>)) &#123;</span><br><span class="line">            pp ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pp == p.length() &amp;&amp; sp == s.length()) &#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当模式串中有多个<code>*</code>时，只会保存最新遇到的<code>*</code>，这样做可行吗，举个例子:  </p>
<blockquote>
<p><code>s:abcdabcd</code> <code>p:ab*da*d</code></p>
</blockquote>
<p>这个模式串的格式为<code>ab...da...d</code>, 当模式串匹配到第二个<code>*</code>时，说明前面的<code>ab*da</code>都已经匹配到了，那么就不用再考虑了，也就只用记录最新碰到的<code>*</code>.</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>通配符匹配</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 85.Maximal Rectangle</title>
    <url>/2019/06/21/Maximal-Rectangle/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
</blockquote>
<span id="more"></span>

<p>Example:</p>
<p>Input:</p>
<p>[</p>
<p>  [“1”,”0”,”1”,”0”,”0”],</p>
<p>  [“1”,”0”,”1”,”1”,”1”],</p>
<p>  [“1”,”1”,”1”,”1”,”1”],</p>
<p>  [“1”,”0”,”0”,”1”,”0”]</p>
<p>]</p>
<p>Output: 6</p>
<p>Analysis:</p>
<p>除了循环使用单调栈的方法，看到了一种很有趣的方法，即采用二进制运算。根据多行数据之间的<code>&amp;</code>运算计算高度，同行数据和移位后数据的<code>&amp;</code>运算计算宽度。但是这种方法需要对输入数据做预处理，将字符数组转化为二进制数。</p>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设数据处理后 datas = &#123;10100, 10111, 11111, 10010&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  temp = data[i]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">4</span>):</span><br><span class="line">    temp = temp &amp; data[j]</span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> none:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    height = j - i + <span class="number">1</span></span><br><span class="line">    move = temp</span><br><span class="line">    width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> move != <span class="number">0</span>:</span><br><span class="line">      width = width + <span class="number">1</span></span><br><span class="line">      move = move &amp; move &gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> height * width &gt; <span class="built_in">max</span>:</span><br><span class="line">      <span class="built_in">max</span> = height * width</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 91.Decode ways</title>
    <url>/2019/07/03/decode-ways/</url>
    <content><![CDATA[<p>Question</p>
<blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
</blockquote>
<span id="more"></span>
<p>‘A’ -&gt; ‘1’<br>‘B’ -&gt; ‘2’<br>…<br>‘Z’ -&gt; ‘26’</p>
<blockquote>
<p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
</blockquote>
<p>Analysis:<br>刚开始想的是把字符串中不用分开的保留出来，比如’12134621’可以分成’1213|4|6|21’，然后把’1213’和’21’能分的种数相乘，现在的问题就是考虑’1213’和’21’有多少分法。这其实也是一种斐波拉契数列，例如:</p>
<pre><code>f(&#39;1&#39;) = 1
f(&#39;12&#39;) = 2
f(&#39;121&#39;) = f(&#39;12|1&#39;) + f(&#39;1|21&#39;) = f(&#39;12&#39;) + f(&#39;1&#39;)
...
f(n) = f(n-1) + f(n-2)
</code></pre>
<p>另一种解法，直接遍历字符串，根据上述公式进行计算，感觉更加简洁明了。</p>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDecodings</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 当前n个字符分好后，n+1个字符长度有dp[n]+dp[n-1]</span></span><br><span class="line">        <span class="comment"># 比如 &#x27;12212&#x27; = &#x27;122&#x27;|&#x27;12&#x27; + &#x27;1221&#x27;|&#x27;2&#x27;</span></span><br><span class="line">        <span class="comment"># 当然要注意能分开的条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i]表示前i个字符可分的方法数</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="comment"># 先假设&#x27;0&#x27;不能和前边的划分在一起, 那么这个&#x27;0&#x27;是无法处理的</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 把s[i]单独划分</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i]</span><br><span class="line">            <span class="comment"># 把s[i]和s[i-1]分一起</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> (s[i-<span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> s[i] &lt; <span class="string">&#x27;7&#x27;</span>):</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[length]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 97.Interleaving_String</title>
    <url>/2019/07/13/Interleaving-String/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
</blockquote>
<span id="more"></span>

<p>Example:</p>
<pre><code>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true
</code></pre>
<p>Analysis:</p>
<p>刚开始的想法是回溯，用三个游标分别记录当前字符串遍历到的字符，当<code>s1</code>和<code>s2</code>中只有一个字符和<code>s3</code>相同，那么该字符串和<code>s3</code>的游标移动到下一个，这是比较好处理的情况；另一种情况<code>s1</code>、<code>s2</code>、<code>s3</code>的当前游标字符都相同，这时候是用<code>s1</code>的还是<code>s2</code>的呢，我把当前三个游标的位置记录下来，先默认使用<code>s1</code>的，当后续出现不匹配的情况时，选择和当前判断最近的这种情况，在用<code>s2</code>进行处理。当然最后超时了。</p>
<p>比较好的方法就是动态规划了，<code>dp[i][j]</code>表示<code>s1</code>串前<code>i</code>个字符和<code>s2</code>串前<code>j</code>个字符能否组成<code>s3</code>串前<code>i+j</code>个字符，其核心规律为:</p>
<pre><code>dp[i][j] = (dp[i-1][j] and s1[i] == s3[i+j-1]) or (dp[i][j-1] and s2[j] == s3[i+j-1]) 
</code></pre>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isInterleave</span>(<span class="params">self, s1, s2, s3</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :type s3: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dp[i][j] 前i个s1和前j个s2能否组成前i+j个s3</span></span><br><span class="line">        len1 = <span class="built_in">len</span>(s1)</span><br><span class="line">        len2 = <span class="built_in">len</span>(s2)</span><br><span class="line">        len3 = <span class="built_in">len</span>(s3)</span><br><span class="line">        <span class="keyword">if</span> len1 + len2 != len3:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len2+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># j = 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">            <span class="keyword">if</span> dp[i][<span class="number">0</span>] <span class="keyword">and</span> s1[i] == s3[i]:</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># i = 0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len2):</span><br><span class="line">            <span class="keyword">if</span> dp[<span class="number">0</span>][j] <span class="keyword">and</span> s2[j] == s3[j]:</span><br><span class="line">                dp[<span class="number">0</span>][j+<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len2+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] <span class="keyword">and</span> s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]) <span class="keyword">or</span> (dp[i][j-<span class="number">1</span>] <span class="keyword">and</span> s2[j-<span class="number">1</span>] == s3[j+i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 115.Distinct Subsequences</title>
    <url>/2019/07/25/Distinct-Subsequences/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
</blockquote>
<span id="more"></span>

<p>Example:</p>
<pre><code>Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;
Output: 3
Explanation:

As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
</code></pre>
<p>Analysis:</p>
<p>动态规划，<code>dp[i][j]</code>表示前<code>i</code>个<code>S</code>串能组成前<code>j</code>个<code>T</code>串的字串个数。</p>
<p>如果<code>S[i] == T[j]</code>，那么<code>dp[i][j]</code>就有两种组成字串的可能，一种是由于<code>S[i]</code>和<code>T[j]</code>相同，直接用<code>S[i-1]</code>和<code>T[j-1]</code>组成的字串在分别加上<code>S[i]</code>和<code>T[j]</code>；另一种是直接把<code>S[i]</code>删掉不考虑。</p>
<p>因此<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code></p>
<p>当<code>S[i] != T[j]</code>，直接把<code>S[i]</code>删掉不考虑，</p>
<p>因此<code>dp[i][j] = dp[i-1][j]</code></p>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        lens = <span class="built_in">len</span>(s)</span><br><span class="line">        lent = <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">if</span> lens &lt; lent:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> lent == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lens == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lent+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lens+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># init</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lens+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lent+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lens+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lent+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t[j-<span class="number">1</span>] == s[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[lens][lent]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 124.Binary Tree Maximum Path Sum</title>
    <url>/2019/07/25/Binary-Tree-Maximum-Path-SUm/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given a non-empty binary tree, find the maximum path sum.</p>
</blockquote>
<span id="more"></span>

<p>Example:</p>
<pre><code>Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
</code></pre>
<p>Analysis:</p>
<p>因为是只用求最大路径长度，所以可以优先设置一个全局变量记录此最大长度。当遍历到某一点时，需要知道它左右各自最长的长度用作比较，所以这里选用后序遍历。在该点有三种路径，该点及左边、该点及右边、该点及两边；分别比较它们与全局最大长度比较，更新全局最大长度。</p>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxS = -sys.maxsize</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> maxS</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            maxl = helper(root.left)</span><br><span class="line">            maxr = helper(root.right)</span><br><span class="line">            oneSide = <span class="built_in">max</span>(maxl, maxr, <span class="number">0</span>) + root.val</span><br><span class="line">            connect = maxl+maxr+root.val</span><br><span class="line">            maxS = <span class="built_in">max</span>(maxS, oneSide, connect)</span><br><span class="line">            <span class="keyword">return</span> oneSide</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> maxS</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 95.Unique Binary Search Trees II</title>
    <url>/2019/07/06/Unique-Binary-Search-Trees/</url>
    <content><![CDATA[<p>Question:</p>
<blockquote>
<p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
</blockquote>
<span id="more"></span>

<p>Example:</p>
<pre><code>Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST&#39;s shown below:

  1         3     3      2      1
   \       /     /      / \      \
    3     2     1      1   3      2
   /     /       \                 \
  2     1         2                 3
</code></pre>
<p>Analysis:</p>
<p>二叉搜索树，其任一节点的左子树都小于该节点，右子树都大于该节点。由于节点的值从1到n，所以可以考虑将每个值都当做根节点，然后该值左边的放在左边，右边的放右边，比如<code>5</code>作为根节点时，<code>1~4</code>就作为左子树，<code>5~n</code>作为右子树。</p>
<p>Answer:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateTrees</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            root = TreeNode(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> [root]</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, start, end</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># only one node</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            s = TreeNode(start)</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 由于i是从start开始的，在第一轮递归时，其范围为(start, i-1)，这时候会有start &gt; end</span></span><br><span class="line">        <span class="comment"># 比如说是1~3，在1作为根节点时，其左子树为None，因此这里是这样处理的</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            res.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make i as the root node</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>):</span><br><span class="line">            left = self.helper(start, i - <span class="number">1</span>)</span><br><span class="line">            right = self.helper(i + <span class="number">1</span>, end)</span><br><span class="line">            <span class="comment"># combine each left and right</span></span><br><span class="line">            <span class="keyword">for</span> le <span class="keyword">in</span> left:</span><br><span class="line">                <span class="keyword">for</span> ri <span class="keyword">in</span> right:</span><br><span class="line">                    root = TreeNode(i)</span><br><span class="line">                    root.left = le</span><br><span class="line">                    root.right = ri</span><br><span class="line">                    res.append(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Hexo中的分类名称</title>
    <url>/2019/09/10/change-categories-name/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>某天突然发现我的<code>categories</code>中英文名称首字母是小写的，所以想把它们改为首字母大写，但是在文章里边改了之后，页面中的类别确实是变了，但是点进去会出现<code>404</code>.</p>
<span id="more"></span>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由于写好<code>md</code>后，是由<code>hexo</code>进行部署等工作生成<code>public</code>文件，即具体的<strong>页面</strong>，在此过程可能是由于<code>git</code>大小写不敏感的原因，导致<code>categories</code>名称只修改首字母大小写并不能产生新的分类，也就使得<code>github</code>上的<code>public</code>文件中包含的类别名称还是原来的样子，比如<code>java</code>，但是在具体的文章页面中该分类已经变成了<code>Java</code>，且对应的<code>url</code>也变更了，所以会出现访问<code>404</code>的问题.</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>通过手动修改<code>github</code>中<code>public</code>下的分类文件名称.</p>
<pre><code>由于`git`大小写不敏感，所以无法直接修改：
$ git mv haha Haha
Rename from &#39;haha&#39; to &#39;Haha/haha&#39; failed. Should I try again? (y/n) n
fatal: renaming &#39;haha&#39; failed: Permission denied

可以采用间接临时文件名作为中转就行了:
$ git mv java/ temp/
$ git mv temp/ Java
</code></pre>
<p>&#x3D;&#x3D;&#x3D;</p>
<p>现在已经不用分类了，太麻烦了，直接用<code>tag</code></p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Minhash</title>
    <url>/2019/11/25/minhash/</url>
    <content><![CDATA[<p><code>Minhash</code>可以用来降维，其最重要的特点是，<strong>降维之后，数据之间的相似度可认为保持不变</strong>，要注意的是这里的相似度是用<code>Jaccard</code>计算的。</p>
<p><code>Stanford</code>的<a href="https://image.zero22.top/minhash/03-lsh.pdf">课件</a>讲的非常清楚。</p>
<span id="more"></span>

<p>最近真是越来越懒的，不想码字?</p>
]]></content>
      <tags>
        <tag>minhash</tag>
      </tags>
  </entry>
  <entry>
    <title>Levenshtein distance</title>
    <url>/2019/11/26/Levenshtein-distance/</url>
    <content><![CDATA[<p><code>Levenshtein distance</code>就是编辑距离，简单说就是将一个字符串A通过删除、插入、替换三种操作转化为字符串B，最少的操作数就称为编辑距离。可以通过DP实现编辑距离求解.</p>
<span id="more"></span>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>假设我们现在要求字符串A的前i个字符转化为字符串B的前j个字符的最小操作数，如<strong>图1</strong>所示</p>
<p><img src="/fig1.png" alt="图1"></p>
<p>图中的箭头表示这个状态矩阵填写的顺序，因此我们也已经有了<code>T[i-1][j]</code>, <code>T[i][j-1]</code>, <code>T[i-1][j-1]</code>等知识</p>
<p>那么能否利用这些已经计算的值，来计算<code>T[i][j]</code>呢?</p>
<p>在两个字符串都进行扩充时，新增加的字符有两种可能:</p>
<ol>
<li><code>A[i] == B[j]</code></li>
</ol>
<p>这种情况比较好，说明当前新增的两个字符已经是匹配的，就不用再操他们的心了，此时<code>T[i][j] = T[i-1][j-1]</code></p>
<ol start="2">
<li><code>A[i] != B[j]</code></li>
</ol>
<p>这时就不好办了，肯定要对字符串A进行三种操作中的一种才能得到字符串B，此时<code>T[i][j] = min(三种操作) + 1</code></p>
<p>那么这个<code>min(三种操作)</code>怎么理解呢?</p>
<ul>
<li><code>T[i][j-1]</code>表示前i个转化为前j-1个，然后A通过<strong>插入</strong>一个和B[j]一样的字符到i+1处，完成转化过程</li>
<li><code>T[i-1][j]</code>表示前i-1个转化为前j个，然后通过<strong>删除</strong>A中第i个字符，完成转化过程</li>
<li><code>T[i-1][j-1]</code>表示前i-1个转化为前j-1个，然后通过<strong>替换</strong>A中第i个字符为B中的第j个字符，完成转化过程</li>
</ul>
<p>因此第二种情况下的转移方程可以写为<code>T[i][j] = min(T[i][j-1], T[i-1][j], T[i-1][j-1]) + 1</code></p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_dis</span>(<span class="params">keyword1, keyword2</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	@keyword1: </span></span><br><span class="line"><span class="string">	@keyword2:</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	len1 = <span class="built_in">len</span>(keyword1)</span><br><span class="line">	len2 = <span class="built_in">len</span>(keyword2)</span><br><span class="line">	<span class="keyword">if</span> len1 == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> len2</span><br><span class="line">	<span class="keyword">elif</span> len2 == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> len1</span><br><span class="line"></span><br><span class="line">	<span class="comment"># state matrix</span></span><br><span class="line">	T = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len1+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># initial T</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">		T[i][<span class="number">0</span>] = i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len2):</span><br><span class="line">		T[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len2):</span><br><span class="line">		char1 = keyword2[i]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len1):</span><br><span class="line">			char2 = keyword1[j]</span><br><span class="line">      <span class="comment"># case 1</span></span><br><span class="line">			<span class="keyword">if</span> char1 == char2:</span><br><span class="line">				T[j+<span class="number">1</span>][i+<span class="number">1</span>] = T[j][i]</span><br><span class="line">      <span class="comment"># case 2</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				T[j+<span class="number">1</span>][i+<span class="number">1</span>] = <span class="built_in">min</span>(<span class="built_in">min</span>(T[j-<span class="number">1</span>][i], T[j][i-<span class="number">1</span>]), T[j-<span class="number">1</span>][i-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> T[len1][len2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	cal_ = cal_dis(<span class="string">&#x27;kitten&#x27;</span>, <span class="string">&#x27;sitting&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;cal =&#x27;</span>, cal_)</span><br></pre></td></tr></table></figure>

<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>感觉之前做了好一些关于字符串的题，大多是用DP求解的，自己还是太垃圾了，经常会混淆不同目的下的转移过程，唉。。。</p>
<p>比如说<a href="https://zero22.top/2019/07/25/Distinct-Subsequences/">这一题</a>，其目的是计算从A串到B串有多少种转移方式，哎。</p>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>编辑距离</tag>
      </tags>
  </entry>
  <entry>
    <title>Mount disk automatically when start up</title>
    <url>/2019/11/29/mount-disk-automatically-when-start-up/</url>
    <content><![CDATA[<p>其实不用手动操作，<code>deepin</code>也会自动挂载磁盘，只不过它的路径看起来太长了。</p>
<span id="more"></span>

<p>主要分为3步:</p>
<ol>
<li>创建挂载点</li>
</ol>
<p>说白了就是从哪个路径访问到你的磁盘，这里边也有大学问，我不懂</p>
<ol start="2">
<li>查看磁盘的UUID</li>
</ol>
<p>可以使用命令<code>blkid</code>，或者是<code>lsblk --fs</code><br><img src="/fig1.jpg" alt="haha"></p>
<p><img src="/fig2.jpg" alt="xixi"></p>
<ol start="3">
<li>编辑文件</li>
</ol>
<p><code>/etc/fstab</code>这个文件应该就是控制系统启动时所加载的磁盘，仿照上边规范的写法，加上自定的加载磁盘就好。<br><img src="/fig3.jpg" alt="heihei"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PC in JVM</title>
    <url>/2019/12/28/PC-in-JVM/</url>
    <content><![CDATA[<p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5.2">PC(Program Counter Register)</a>: The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its <strong>own pc</strong> (program counter) register. At any point, each Java Virtual Machine thread is executing the code of <strong>a single method</strong>, namely the <strong>current method</strong> (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine’s pc register is undefined. The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.</p>
<span id="more"></span>

<p>从上面的说明中可以提炼出一下几点信息：</p>
<ol>
<li>程序计数器是线程私有的</li>
<li>程序计数器指向的是当前线程中正在被执行方法的地址(行号)</li>
<li>如果执行的本地方法，则计数器值为<code>undefined</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String method add...</span></span><br><span class="line">        <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">8</span>: iload_0</span><br><span class="line">        <span class="number">9</span>: iload_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        <span class="number">11</span>: ireturn</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">3</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String method sub...</span></span><br><span class="line">        <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">8</span>: iconst_1</span><br><span class="line">        <span class="number">9</span>: istore_0</span><br><span class="line">        <span class="number">10</span>: iconst_2</span><br><span class="line">        <span class="number">11</span>: istore_1</span><br><span class="line">        <span class="number">12</span>: iload_0</span><br><span class="line">        <span class="number">13</span>: iload_1</span><br><span class="line">        <span class="number">14</span>: invokestatic  #<span class="number">6</span>                  <span class="comment">// Method add:(II)I</span></span><br><span class="line">        <span class="number">17</span>: pop</span><br><span class="line">        <span class="number">18</span>: iload_0</span><br><span class="line">        <span class="number">19</span>: iload_1</span><br><span class="line">        <span class="number">20</span>: isub</span><br><span class="line">        <span class="number">21</span>: ireturn</span><br></pre></td></tr></table></figure>

<p>如上代码段，可以简单理解<code>PC</code>中存储的是每条<code>jvm</code>指令开头的数字。</p>
<h3 id="特定"><a href="#特定" class="headerlink" title="特定"></a>特定</h3><p>此内存区域是唯一一个在<code>Java</code>虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/index.html">The Java® Virtual Machine Specification</a></li>
<li>周志明. (2014). 深入理解 Java 虚拟机一 JVM 高级特性与最佳实践.</li>
</ol>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>insert into a red-black tree</title>
    <url>/2019/12/24/insert-into-a-red-black-tree/</url>
    <content><![CDATA[<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>每个节点是红的或黑的</li>
<li>根节点是黑的</li>
<li>所有的叶子节点(NIL)是黑的</li>
<li>红色节点的孩子只能是黑的</li>
<li>从任一节点到叶子节点所经过的黑色节点个数相同</li>
</ol>
<span id="more"></span>
<p>就像这样:<br><img src="/fig1.png"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>不管是插入还是删除，只要能理出节点插入时其周围节点颜色的情况，就能对操作有个整体的认识。</p>
<p>还要注意的是，在插入时，把待处理的节点默认为红色会更方便，破坏的规则更少。</p>
<p>整体流程图：<br><img src="/fig2.png"></p>
<h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><p>如果根节点为空，则待插入节点当作根节点，并设置为黑色。</p>
<h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><p>如果父节点为黑色，那么插入一个红节点不会破坏任何性质，ok</p>
<h4 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h4><p>如果父节点为红色，这时候就需要考虑叔叔节点了，如果叔叔也是红色，那么就把父亲和叔叔变为黑色，爷爷变为红色，这样保持遍历该棵树时黑色节点数目不变，然后把爷爷当作待插入节点，递归处理。(因为在这里是爷爷，可能是别人的儿子)</p>
<p><img src="/fig3.png"></p>
<h4 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h4><p>还是父节点为红，叔叔为黑色或没有，这时就需要旋转操作了，如果待插入节点和父亲节点在同一边，就绕着父亲节点做一次对应的旋转:</p>
<p><img src="/fig4.png"></p>
<p>如果不在同一边，就需要先做一次旋转转到同一边，再继续。</p>
<p><img src="/fig5.png"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的主要思想是用待删除节点的前继或后继节点替换该节点，再删除原前&#x2F;后继节点，这里考虑用后继节点替换该待删除节点，(那么可知后继节点左孩子是叶子节点)，把后继节点的值copy到待删除节点上，然后只用考虑把后继节点删除就行了。因此后边的待删除节点都是☞原节点的后继节点了，不要搞错对象咯。</p>
<p>主要流程图：<br><img src="/fig6.png"></p>
<h4 id="自己为红"><a href="#自己为红" class="headerlink" title="自己为红"></a>自己为红</h4><p>那么它已经没得孩子了，直接删除就好。</p>
<p><img src="/fig7.png"></p>
<h4 id="右孩子为红"><a href="#右孩子为红" class="headerlink" title="右孩子为红"></a>右孩子为红</h4><p>把自己删了之后，用右孩子顶上，并改为黑色。</p>
<p><img src="/fig8.png"></p>
<h4 id="兄弟为红"><a href="#兄弟为红" class="headerlink" title="兄弟为红"></a>兄弟为红</h4><p>通过旋转往这边均个点改为黑的。</p>
<p><img src="/fig9.png"></p>
<h4 id="兄弟同边孩子为红"><a href="#兄弟同边孩子为红" class="headerlink" title="兄弟同边孩子为红"></a>兄弟同边孩子为红</h4><p><img src="/fig10.png"></p>
<h4 id="兄弟异边孩子为红"><a href="#兄弟异边孩子为红" class="headerlink" title="兄弟异边孩子为红"></a>兄弟异边孩子为红</h4><p><img src="/fig13.png"></p>
<h4 id="父亲为黑"><a href="#父亲为黑" class="headerlink" title="父亲为黑"></a>父亲为黑</h4><p>删除后把兄弟节点改为红的，这时候这个子树是没问题的，但是它作为更大的树的一部分，经过<code>P</code>的路径就会比原来少一个黑点，所以要再递归平衡<code>P</code>点。<br><img src="/fig11.png"></p>
<h4 id="父亲为红"><a href="#父亲为红" class="headerlink" title="父亲为红"></a>父亲为红</h4><p><img src="/fig12.png"></p>
]]></content>
      <tags>
        <tag>红黑树</tag>
        <tag>RedBlackTree</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda in java and python</title>
    <url>/2019/12/28/lambda-in-java-and-python/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Anonymous_function">Anonymous function</a>: In computer programming, an anonymous function (function literal, lambda abstraction, or lambda expression) is a function definition that is not bound to an identifier. </p>
<span id="more"></span>
<p>可以简单的理解为去掉了标识符的匿名函数，下面记下自己用到的为数不多的地方&#x3D; &#x3D;</p>
<h3 id="using-in-java"><a href="#using-in-java" class="headerlink" title="using in java"></a>using in java</h3><p>就我菜鸡而言，在<code>java</code>中<code>Lambda</code>主要在线程以及比较时见的多，比如下面新创建一个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello from: &quot;</span> + Thread.currentThread());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// hello from: Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure>

<p>或者实现一个自定义的比较:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections.sort(strings, (a, b) -&gt; b.length() - a.length());</span></span><br><span class="line">strings.sort((a, b) -&gt; b.length() - a.length());</span><br></pre></td></tr></table></figure>

<h3 id="using-in-python"><a href="#using-in-python" class="headerlink" title="using in python"></a>using in python</h3><p>在<code>python</code>中，我主要在排序中用到，比如说按照<code>key-value</code>中的<code>key</code>或<code>value</code>来进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照value进行升序排序</span></span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">0</span>&#125;</span><br><span class="line">d = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [(&#x27;c&#x27;, 0), (&#x27;a&#x27;, 1), (&#x27;d&#x27;, 2), (&#x27;g&#x27;, 3)]</span></span><br></pre></td></tr></table></figure>

<p>在<code>map</code>中作为映射使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*x, l))</span><br><span class="line"><span class="built_in">print</span>(ll)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI in linux</title>
    <url>/2020/01/10/JNI-in-linux/</url>
    <content><![CDATA[<p>在复习<code>JVM</code>时又看到了本地方法栈, 那么本地方法是个什么方法呢。<code>JNI</code>即<code>java native interface</code>, 通过这个东西可以实现在<code>Java</code>中调用其他编程语言实现的功能，在和系统底层交互时<code>Java</code>大都通过<code>JNI</code>调用<code>C/C++</code>来实现的。</p>
<span id="more"></span>

<p>下面用个实例来说明本地方法是如何实现的。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><code>jdk-11.0.5</code>: 在10之后就看不到<code>javap</code>这个命令了，这个命令的主要功能是根据<code>java</code>源码中声明的<code>native</code>方法，生成对应的<code>c/c++</code>头文件，其中的主要内容就是对<code>native</code>方法的声明。现在这个功能集成到了<code>javac</code>下，使用<code>javac -h target_dic src_dic</code></p>
<p><code>centos7</code>: 在后续的编译过程中需要用到<code>gcc</code>, <code>gcc-c++</code>等包</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="1-java源码"><a href="#1-java源码" class="headerlink" title="1. java源码"></a>1. java源码</h4><p>首先写一点简单的<code>java</code>源码，其中包含一<code>native</code>方法就行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJni</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;HelloJni&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-生成头文件"><a href="#2-生成头文件" class="headerlink" title="2. 生成头文件"></a>2. 生成头文件</h4><p>使用命令<code>javac -h HelloJni.java</code>, 得到的头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;jni.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloJni */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_HelloJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_HelloJni</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJni</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_HelloJni_sayHello</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到这里自动生成的头文件中需要<code>jni.h</code>, 在<code>jni.h</code>中又需要<code>jni_md.h</code>。</p>
<h4 id="3-C-实现"><a href="#3-C-实现" class="headerlink" title="3. C++实现"></a>3. C++实现</h4><p>对头文件中方法进行实现，我用的<code>c++</code>，不晓得头文件中的<code>_cplusplus</code>是不是在暗示用<code>c++</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HelloJni.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_HelloJni_sayHello</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World By Jni\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h4><p>我觉得比较绕的地方就是编译的过程了。</p>
<p>首先进行预处理，编译，汇编过程，不搞链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -I/root/jdk-11.0.5/include </span><br><span class="line">    -I/root/jdk-11.0.5/include/linux -fPIC -c HelloJni.cpp</span><br></pre></td></tr></table></figure>

<p><code>-Idir</code>: Add the directory dir to the list of directories to be searched for header files.<br>前边提到的<code>jni.h</code>在<code>include</code>目录下，<code>jni_md.h</code>在目录<code>include/linux</code>目录下。</p>
<p><code>-fPIC</code>: 当编译的时候不用这个指令的话，在后边生成动态库会出问题：</p>
<pre><code>/usr/bin/ld: HelloJni.o: relocation R_X86_64_32 against .rodata can not be used when making a shared object; recompile with -fPIC
/usr/bin/ld: final link failed: Nonrepresentable section on output
</code></pre>
<p>编译好后得到<code>HelloJni.o</code>文件，做进一步处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -shared -o libHelloJni.so HelloJni.o</span><br></pre></td></tr></table></figure>
<p>就能得到<code>linux</code>下动态链接库文件<code>libHelloJni.so</code>，这个文件在生成时需要规定其名字，由于在<code>java</code>代码中指定的加载库名为<code>HelloJni</code>，在生成链接库文件时需要命名为<code>libHelloJni.so</code>，否则会找不到库文件。</p>
<p>  Exception in thread “main” java.lang.UnsatisfiedLinkError: no HelloJni in java.library.path: [&#x2F;root&#x2F;test, ., &#x2F;usr&#x2F;java&#x2F;packages&#x2F;lib, &#x2F;usr&#x2F;lib64, &#x2F;lib64, &#x2F;lib, &#x2F;usr&#x2F;lib]</p>
<h4 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h4><p>如果直接运行，还是会报错，</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no HelloJni in java.library.path: [/usr/java/packages/lib, /usr/lib64, /lib64, /lib, /usr/lib]
</code></pre>
<p>会发现我们得到的链接文件不在后边的<code>path</code>中，可以选择把得到的链接文件拷一份，或者使用命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>把当前目录加到<code>path</code>中，这个变量应该是运行时生成的还是怎样，直接在<code>linux</code>中查看该变量啥也没有。</p>
<p>最后直接运行<code>java</code>代码，当然首先要<code>javac</code>。</p>
]]></content>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>.tar and .gz</title>
    <url>/2020/01/13/tar-and-gz/</url>
    <content><![CDATA[<p>在使用<code>Linux</code>时经常会涉及到文件的压缩与解压，这里对遇到的情况进行记录，后续继续补充。</p>
<p><code>tar</code>应该是最常用的一个压缩&#x2F;解压命令。这个命令可以用附加选项来支持解压其他后缀的文件。</p>
<ol>
<li><code>tar -z</code>可以解压涉及<code>gzip, gunzip, ungzip</code>的文件，比如<code>xxxx.tar.gz</code></li>
<li><code>tar -j</code>可以解压涉及<code>bzip2</code>的文件，比如<code>xxxx.tar.bz2</code>，当然也可以先用<code>unzip2</code>把外面一层套脱了，再处理<code>tar</code></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>tar</tag>
        <tag>bunzip</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--基础数据</title>
    <url>/2020/02/23/Redis-1/</url>
    <content><![CDATA[<p>各种数据类型的应用场景以及一些小问题。</p>
<span id="more"></span>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ol>
<li>单数据操作与多数据操作，考虑指令在应用服务器和<code>Redis</code>之间的传输消耗。<code>set</code>,<code>mset</code></li>
<li><code>redis</code>用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表主键的唯一性。<code>incr</code></li>
<li><code>redis</code>用于控制数据的生命周期。<code>setex</code>,<code>psetex</code> 投票</li>
<li><code>redis</code>用于各种结构型和非结构型高热度数据的加速访问。</li>
<li>分布式锁。<code>setnx</code></li>
</ol>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ol>
<li><code>value</code>字段只能存储字符串，不能套娃。</li>
<li>每个<code>hash</code>最多可存2<sup>32</sup>-1个键值对.</li>
<li><code>hash</code>设计的初衷不是为了存储大量对象数据，不可滥用。</li>
<li><code>hgetall</code>可能成为性能瓶颈。</li>
<li><code>redis</code>用于抢购，限购，限量，激活码等业务的数据存储设计。</li>
</ol>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ol>
<li><p>底层使用双向链表存储结构实现。</p>
</li>
<li><p>获取数据大多是从左操作的。<code>lrange</code>, <code>lindex</code>, <code>llen</code></p>
</li>
<li><p>消息队列&#x2F;任务队列。 <code>blpop</code>, <code>brpop</code></p>
</li>
<li><p><code>redis</code>用于具有操作先后顺序的数据控制。点赞</p>
</li>
<li><p><code>list</code>中存储的数据都是<code>string</code>类型，最多存2<sup>32</sup>-1个。</p>
</li>
<li><p><code>redis</code>实现最新消息的展示。</p>
</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol>
<li>与<code>hash</code>存储结构完全相同，<code>field</code>即为值, <code>value</code>为空nil。</li>
<li>随机推送。 <code>srandmember</code>, <code>spop</code></li>
<li><code>redis</code>用于同类信息的关联搜索，二度&#x2F;深度关联搜索。<code>sinter</code>, <code>sunion</code>, <code>sdiff</code> 关注模型</li>
<li><code>redis</code>用于同类型不重复数据的合并操作。权限验证</li>
<li><code>redis</code>用于同类型数据的快速去重。统计访问量</li>
<li><code>redis</code>基于黑白名单的服务控制。</li>
</ol>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted_set"></a>sorted_set</h3><ol>
<li><code>redis</code>用于计数器组合排序功能对应的排名。 </li>
<li><code>score</code>数据的存储空间是64位的。</li>
<li><code>redis</code>用于定时任务执行顺序管理或任务过期管理。</li>
<li><code>redis</code>应用于及时任务&#x2F;消息队列执行管理。 <code>zrevrange</code></li>
</ol>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--通用指令</title>
    <url>/2020/02/24/redis-2/</url>
    <content><![CDATA[<p>针对<code>redis</code>中的<code>key</code>的相关应用。</p>
<span id="more"></span>

<h2 id="Key通用指令"><a href="#Key通用指令" class="headerlink" title="Key通用指令"></a>Key通用指令</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ol>
<li><code>EXISTS key [key ...]</code></li>
<li><code>DEL key [key ...]</code></li>
<li><code>TYPE key</code></li>
</ol>
<h3 id="时效性控制"><a href="#时效性控制" class="headerlink" title="时效性控制"></a>时效性控制</h3><ol>
<li><code>EXPIRE key seconds</code></li>
<li><code>PEXPIRE key milliseconds</code></li>
<li><code>EXPIREAT key timestamp</code></li>
<li><code>PEXPIREAT key milliseconds-timestamp</code></li>
<li><code>TTL key</code><ol>
<li>当<code>key</code>不存在(过期)返回<code>-2</code></li>
<li><code>key</code>未设置失效时间返回<code>-1</code></li>
</ol>
</li>
<li><code>PTTL key</code></li>
<li><code>PERSIST key</code></li>
</ol>
<h3 id="查询模式"><a href="#查询模式" class="headerlink" title="查询模式"></a>查询模式</h3><ol>
<li><code>KEYS pattern</code></li>
</ol>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ol>
<li><code>help @generic</code></li>
</ol>
<h2 id="数据库通用指令"><a href="#数据库通用指令" class="headerlink" title="数据库通用指令"></a>数据库通用指令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li><code>SELECT index</code></li>
<li><code>PING [message]</code></li>
<li><code>QUIT -</code></li>
<li><code>ECHO message</code></li>
<li><code>help @connection</code></li>
</ol>
<h3 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h3><ol>
<li><code>MOVE key db</code></li>
</ol>
<h3 id="数据清除"><a href="#数据清除" class="headerlink" title="数据清除"></a>数据清除</h3><ol>
<li><code>FLUSHDB</code></li>
<li><code>FLUSHALL</code></li>
<li><code>DBSIZE</code></li>
<li><code>help @server</code></li>
</ol>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--jedis</title>
    <url>/2020/02/24/redis-3/</url>
    <content><![CDATA[<p>在<code>java</code>项目中使用<code>jedis</code>对<code>redis</code>进行交互操作。</p>
<span id="more"></span>

<h3 id="使用maven"><a href="#使用maven" class="headerlink" title="使用maven"></a>使用maven</h3><ol>
<li>使用maven命令构建项目：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=&#123;package&#125; -DartifactId=&#123;project&#125; </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>或者直接用IDE更方便。</li>
</ol>
<p>导入<code>Jedis</code>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">redisAdd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.56.101&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//string</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;theshy&quot;</span>);</span><br><span class="line">    <span class="comment">//hash</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;hash1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;rookie&quot;</span>);</span><br><span class="line">    <span class="comment">//list</span></span><br><span class="line">    jedis.lpush(<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;jacklove&quot;</span>);</span><br><span class="line">    <span class="comment">//set</span></span><br><span class="line">    jedis.sadd(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;ning&quot;</span>, <span class="string">&quot;baolan&quot;</span>, <span class="string">&quot;leyan&quot;</span>);</span><br><span class="line">    <span class="comment">//sorted_set</span></span><br><span class="line">    jedis.zadd(<span class="string">&quot;zset1&quot;</span>, <span class="number">5.3</span>, <span class="string">&quot;first&quot;</span>);</span><br><span class="line">	<span class="comment">//close</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--事务</title>
    <url>/2020/02/25/redis-5/</url>
    <content><![CDATA[<p>事务：一个队列中，一次性，顺序性，排他性的执行一系列命令</p>
<span id="more"></span>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li><code>multi</code> 开启事务，后面的指令暂时加入任务队列</li>
<li><code>exec</code> 执行事务</li>
<li><code>discard</code>  取消事务</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>开启事务后，如果输入错误命令，不存在的指令，形式不对，则报错且关闭事务</li>
<li>开启事务后，如果语法格式正确，但操作类型错误，形式正确，执行事务时不会影响其他指令的运行，即不会回滚</li>
</ol>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ol>
<li>添加监视锁：<code>watch key (check-and-set)</code>乐观锁机制</li>
<li>一个客户端<code>watch</code>某个键后，不管其后的事务是否涉及到该键，只要其他客户端修改了该键，则本客户端的事务都会失败，返回<code>(nil)</code></li>
<li>在事务中不能<code>watch</code>, 但是可以<code>unwatch</code></li>
<li>取消监视的情况：<ol>
<li>当<code>exec</code>被调用，无论事务是否成功执行，对所有键的监视都会取消</li>
<li>某客户端断开连接时，该客户端对键的监视也会取消</li>
<li>使用无参数指令<code>unwatch</code>取消该客户端对所有键的监视</li>
</ol>
</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>考虑一些问题：</p>
<ol>
<li>保证锁总能释放掉 ——-&gt;设置失效时间</li>
<li>失效时间设置多久合适 ——–&gt; 延长锁机制，每隔<code>1/3</code>的失效时间进行检测，如果还在执行，则延迟锁时间</li>
<li>避免解掉别人的锁 ——-&gt;解锁时对随机标识串进行校验</li>
<li>如果不能保证<code>redis</code>总是可用的———&gt;<code>Redlock</code>算法，整多个<code>redis</code>，至少获取到<code>N/2+1</code>个<code>redis</code>的锁且未失效</li>
</ol>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--配置管理</title>
    <url>/2020/02/24/redis-4/</url>
    <content><![CDATA[<p>通过<code>redis</code>的配置文件更加深入的了解<code>redis</code>.</p>
<span id="more"></span>

<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol>
<li><p><code>port 6379</code> 可以自定启动端口</p>
</li>
<li><p><code>daemonize yes</code> 以守护进程的方式启动<code>redis</code></p>
</li>
<li><p><code>logfile &quot;&quot;</code> 指定日志文件，如果为空，输出到标准输出</p>
</li>
<li><p><code>dir</code> 指定工作目录，会将比如日志文件，数据库备份等存放在该目录下，需要先手动创建</p>
</li>
</ol>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p>
<p>持久化的方式：</p>
<ol>
<li>数据（快照）—–&gt; RDB</li>
<li>过程（日志）—–&gt; AOF</li>
</ol>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>命令 ：<code>save</code> 手动执行一次保存操作</p>
<p>效果 ：在指定的<code>dir</code>目录下生成<code>dump.rdb</code>文件</p>
<p>注意 ：<code>save</code>指令的执行会阻塞当前<code>redis</code>服务器，线上环境不建议使用</p>
<p>命令 ：<code>bgsave</code> 异步执行快照操作</p>
<p>效果 ：调用<code>fork()</code>产生一个子进程完成具体的<code>save</code>操作，完成后给<code>redis</code>返回消息，可以在日志文件中查看</p>
<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><ol>
<li><code>rdbcompression yes</code> 采用<code>LZF</code>压缩字符串对象</li>
<li><code>rdbchecksum yes</code> <code>redis5</code>之后采用<code>CRC64</code>对数据文件进行校验，会影响<code>10%</code>左右的性能，如果关闭，数据末尾的校验数据会被设置为<code>0</code>，跳过验证</li>
<li><code>dbfilename dump.rdb</code> 设置<code>dump</code>数据库生成的文件名</li>
<li><code>stop-writes-on-bgsave-error yes</code> 持久化出现问题时是否停止备份</li>
</ol>
<h4 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h4><p>先只考虑没有冲突的情况（没有额外的<code>saving/rewrite</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If there is not a background saving/rewrite in progress check if</span></span><br><span class="line"><span class="comment">         * we have to save/rewrite now. */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;   <span class="comment">// 循环所有的 save seconds changes 配置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">sp</span> =</span> server.saveparams+j;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save if we reached the given amount of changes,</span></span><br><span class="line"><span class="comment">             * the given amount of seconds, and if the latest bgsave was</span></span><br><span class="line"><span class="comment">             * successful or if, in case of an error, at least</span></span><br><span class="line"><span class="comment">             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span><br><span class="line">        server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span><br><span class="line">        (server.unixtime-server.lastbgsave_try &gt;</span><br><span class="line">         CONFIG_BGSAVE_RETRY_DELAY ||          <span class="comment">// 默认是5秒</span></span><br><span class="line">         server.lastbgsave_status == C_OK))    </span><br><span class="line">    <span class="comment">// 前边两个条件是 如果所作的修改大于指令指定次数并且距离上次保存时间也大于指定的时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;%d changes in %d seconds. Saving...&quot;</span>,</span><br><span class="line">                  sp-&gt;changes, (<span class="type">int</span>)sp-&gt;seconds);</span><br><span class="line">        rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">        rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">        rdbSaveBackground(server.rdb_filename,rsiptr);  <span class="comment">// 在这里边调用了fork创建子进程进行bgsave</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果操作没有<code>error</code>的话：</p>
<ol>
<li>两次保存之间至少要间隔<code>sp-&gt;seconds</code>秒，即使到目前为止写的次数已经超过了<code>sp-&gt;changes</code></li>
<li>经过<code>sp-&gt;seconds</code>秒并不会重置<code>server.dirty</code>已经写的次数</li>
</ol>
<p>之前还在想如果设置的<code>save 10 2</code>，那么只要我不在<code>10s</code>内做两次写操作，那不就不会<code>save</code>了？  </p>
<p>&#x3D; &#x3D;。</p>
<h4 id="特殊启动形式"><a href="#特殊启动形式" class="headerlink" title="特殊启动形式"></a>特殊启动形式</h4><ol>
<li>全量复制</li>
<li>服务器运行过程中重启 <code>debug reload</code> （在客户端运行指令，下同）</li>
<li>关闭服务器时指定保存数据 <code>shutdown save</code></li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>能进行压缩，是一个紧凑的二进制文件，存储效率高</li>
<li>其数据是<code>redis</code>在某个时间点的快照，适合于数据备份，全量复制等场景</li>
<li>恢复速度比<code>AOF</code>快</li>
<li>用于灾难恢复</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>无法做到实时持久化，可能会丢失数据</li>
<li><code>bgsave</code>由于需要创建子进程，会消耗一定的性能</li>
<li>多版本<code>RDB</code>文件格式可能不同意，有无法兼容的现象</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><code>Append only file</code>持久化：以独立日志的方式记录每次写命令，重启时，重新执行<code>AOF</code>文件中的命令达到恢复数据的目的。能够解决数据持久化的实时性问题。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ol>
<li><code>appendonly yes/no</code></li>
<li><code>appendfilename &quot;filename.aof&quot;</code></li>
<li><code>appendfsync always/everysec/no</code></li>
</ol>
<h4 id="三种策略-appendfsync"><a href="#三种策略-appendfsync" class="headerlink" title="三种策略(appendfsync)"></a>三种策略(appendfsync)</h4><ol>
<li><code>no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.</code></li>
<li><code>always: fsync after every write to the append only log. Slow, Safest</code></li>
<li><code>everysec: fsync only one time every second. Compromise.</code>      —————&gt;default</li>
</ol>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>将<code>redis</code>进程内的数据转化为写命令同步到新<code>AOF</code>文件的过程。将对同一个数据的若干条命令执行结果转化为最终结果数据对应的指令进行记录，省去无效指令。</p>
<p>作用：</p>
<ol>
<li>降低磁盘占用量</li>
<li>提高持久化效率</li>
<li>降低数据恢复用时</li>
</ol>
<p>重写规则：</p>
<ol>
<li>进程内已超时的数据不写</li>
<li>忽略无效指令，只保留最终数据的写入命令</li>
<li>对同一数据的多条写命令进行合并—————&gt;每条指令最多写64个元素</li>
</ol>
<p>重写配置：</p>
<ol>
<li><code>auto-aof-rewrite-percentage 100</code></li>
<li><code>auto-aof-rewrite-min-size 64mb</code></li>
<li>涉及到的数据可以通过<code>info persistence</code>查看——-&gt; <code>aof_current_size</code> , <code>aof_base_size</code></li>
</ol>
<p><img src="/fig1.png" alt="rewrite process by itheima"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/fig2.png" alt="compare by itheima"></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--删除策略</title>
    <url>/2020/02/25/redis-6/</url>
    <content><![CDATA[<p>包含两个部分，一是内存空间还有剩余，但是执行<code>DEL</code>等删除键的操作；二是内存空间不够了，类似<code>GC</code>随机删除某些键。</p>
<span id="more"></span>

<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>配置文件中的<code>LAZY FREEING</code>部分讲述了两种删除键的机制：</p>
<ol>
<li><p>定时删除<code>blocking deletion</code></p>
<p>即删除键时是一个阻塞操作，调用的时候就必须要进行删除，等不得，相当于<strong>时间换空间</strong></p>
<ul>
<li><code>DEL</code> 操作</li>
<li>内存不够，需要阻塞删除 <code>maxmemory 60Mb</code></li>
<li>设置过期时间，到时间阻塞删除 <code>expire</code></li>
<li>更新值时，会阻塞删除旧值，比如 <code>rename</code> ,<code>sunionstore</code>, <code>set</code></li>
<li>主从复制时，加载主机的<code>RDB</code>文件时要先删除所有库的内容</li>
</ul>
</li>
<li><p>惰性删除 <code>non-blocking</code></p>
<p>数据到期时并不一定马上删除，等下次访问时，先判断是否过期，未过期返回，已过期再删除，<strong>空间换时间</strong></p>
<ul>
<li><code>unlink</code> 非阻塞删除</li>
<li><code>async</code>选项，如<code>flushdb async</code></li>
<li>配置文件中提供配置选项 <code>lazyfree-lazy-eviction|expire|server-del no</code>, <code>replica-lazy-flush no</code></li>
</ul>
<p>在查询键时，首先会调用<code>expireIfNeeded</code>方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, instead of</span></span><br><span class="line"><span class="comment">     * evicting the expired key from the database, we return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">// 如果是slave的话</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span>      </span><br><span class="line">    server.stat_expiredkeys++;                 <span class="comment">// 在master中进行删除</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : <span class="comment">//可配置</span></span><br><span class="line">                                         dbSyncDelete(db,key);   <span class="comment">//的关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定期删除</p>
<p><code>serverCron()</code>是一个定期执行的函数，需要执行一系列的任务，由<code>server.hz</code>设定工作周期，即每秒执行<code>server.hz</code>次，默认是<code>10</code>,</p>
<p>其完成的工作中第一项：<code>Active expired keys collection (it is also performed in a lazy way on lookup)</code>,具体工作在<code>databasesCron()</code>中进行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">databasesCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Expire keys by random sampling. Not required for slaves</span></span><br><span class="line"><span class="comment">     * as master will synthesize DELs for us. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;    <span class="comment">// 如果是master的话，执行删除</span></span><br><span class="line">            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            expireSlaveKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续到<code>activeExpireCycle()</code>方法中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></span><br><span class="line"><span class="comment">     * incrementally across calls. */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dbs_per_call = CRON_DBS_PER_CALL;        <span class="comment">// 默认是16</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We usually should test CRON_DBS_PER_CALL per iteration, with</span></span><br><span class="line"><span class="comment">     * two exceptions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Don&#x27;t test more DBs than we have.</span></span><br><span class="line"><span class="comment">     * 2) If last time we hit the time limit, we want to scan all DBs</span></span><br><span class="line"><span class="comment">     * in this iteration, as there is work to do in some DB and we don&#x27;t want</span></span><br><span class="line"><span class="comment">     * expired keys to use memory for too much time. */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;         <span class="comment">// 如果设置库大于16个，并且</span></span><br><span class="line">									      <span class="comment">// 检验超时了，下次循环就设为16次？</span></span><br><span class="line">    <span class="comment">/* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span></span><br><span class="line"><span class="comment">     * per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span> <span class="comment">// cpu时间的1/4</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;<span class="comment">//250ms</span></span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accumulate some global stats as we expire keys, to have some idea</span></span><br><span class="line"><span class="comment">     * about the number of keys that are already logically expired, but still</span></span><br><span class="line"><span class="comment">     * existing inside the database. */</span></span><br><span class="line">    <span class="type">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;<span class="comment">// 遍历16次库</span></span><br><span class="line">        <span class="type">int</span> expired;</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum); <span class="comment">// 接着上次的跑</span></span><br><span class="line">        </span><br><span class="line">        current_db++;         <span class="comment">// 记录当前的遍历到的库</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></span><br><span class="line"><span class="comment">         * of the keys were expired. */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	...</span><br><span class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When there are less than 1% filled slots getting random</span></span><br><span class="line"><span class="comment">             * keys is expensive, so stop here waiting for better times...</span></span><br><span class="line"><span class="comment">             * The dictionary will be resized asap. */</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;  <span class="comment">// 过期的太少了先跳过</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. */</span></span><br><span class="line">		   ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP; <span class="comment">//默认20</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line">			    <span class="comment">// 从当前库中的expire中随机挑选一个key</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;<span class="comment">//实际删除</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* We want the average TTL of keys yet not expired. */</span></span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">                total_sampled++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We can&#x27;t block forever here even if there are many keys to</span></span><br><span class="line"><span class="comment">             * expire. So after a given amount of milliseconds return to the</span></span><br><span class="line"><span class="comment">             * caller waiting for the other active expire cycle. */</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* We don&#x27;t repeat the cycle if there are less than 25% of keys</span></span><br><span class="line"><span class="comment">             * found expired in the current DB. */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>摘自<code>itcast</code></p>
<p><img src="/fig1.png" alt="*"></p>
</li>
</ol>
<h3 id="数据逐出"><a href="#数据逐出" class="headerlink" title="数据逐出"></a>数据逐出</h3><p>当内存不够时，删除哪些数据</p>
<p>有以下相关配置：</p>
<ol>
<li><p>设置最大内存：<code>maxmemory &lt;bytes&gt;</code></p>
</li>
<li><p>设置逐出策略：<code>maxmemory-policy noeviction</code>———&gt;默认</p>
<ul>
<li><code>volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</code></li>
<li><code>volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</code></li>
<li><code>volatile-random -&gt; Remove a random key among the ones with an expire set.</code></li>
<li><code>volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</code></li>
<li><code>allkeys-lru -&gt; Evict any key using approximated LRU.</code></li>
<li><code>allkeys-lfu -&gt; Evict any key using approximated LFU.</code></li>
<li><code>allkeys-random -&gt; Remove a random key, any key.</code></li>
<li><code>noeviction -&gt; Don&#39;t evict anything, just return an error on write operations.</code></li>
</ul>
</li>
<li><p>设置抽样数目：<code>maxmemory-samples 5</code></p>
<p>注意上述某些策略是<code>approximated</code>,主要就体现在抽样数量上，不是从所有的键中进行选择</p>
</li>
</ol>
<p><code>lru means least recently used</code>：简单理解就是按<strong>时间</strong>来说，<strong>最久</strong>没有使用的</p>
<p><code>lfu means least frequently used</code>：简单说就是按<strong>次数</strong>来说，<strong>最少</strong>使用的 </p>
<p>说是可以通过<code>info stats</code>中记录的<code>keyspace_hits:1</code>和<code>keyspace_misses:2</code>来调整策略 &#x3D; &#x3D;。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--主从复制</title>
    <url>/2020/02/26/redis-7/</url>
    <content><![CDATA[<p>主从复制：</p>
<ol>
<li>读写分离</li>
<li>负载均衡</li>
<li>故障恢复</li>
<li>数据冗余</li>
<li>高可用基石</li>
</ol>
<span id="more"></span>

<h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>主从复制过程大致可分为三个阶段：</p>
<ol>
<li>建立连接阶段</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ol>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>有三种方式完成连接：（设有两台<code>redis</code>服务器，一台叫<code>master</code>，一台叫<code>slave</code>）</p>
<ol>
<li>在<code>slave</code>客户端使用命令 <code>slaveof masterhost masterport</code></li>
<li>在<code>slave</code>服务器端启动时，附加<code>--slaveof masterhost masterport</code></li>
<li>在<code>slave</code>的配置文件中加上<code>slaveof masterhost masterport</code>   ————&gt; 提供的<code>redis.conf</code>中并没有该选项，改为<code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code>了，而且示意图中也变为<code>Master----&gt;Replica</code></li>
</ol>
<p><code>redis</code>服务器有两种方式设置密码：</p>
<ol>
<li>在配置文件中<code>requirepass &lt;password&gt;</code></li>
<li>在运行时通过客户端设置：<code>config set requirepass &lt;password&gt;</code>, 重启服务器会失效</li>
</ol>
<p>设置密码后，如果没有进行认证，在客户端的大部分操作（没有验证所有的）都会：<code>NOAUTH Authentication required.</code></p>
<p>两种认证方式：</p>
<ol>
<li>启动<code>redis</code>客户端时附加<code>-a | -u &lt;password&gt;</code>，会提示可能不安全</li>
<li>连接后在客户端使用命令<code>auth &lt;password&gt;</code></li>
</ol>
<p>如果<code>master</code>设置了密码，<code>slave</code>想要连接<code>master</code>,需要在配置文件中提前设置<code>masterauth &lt;password&gt;</code>，应该只有这一种方式。</p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>数据同步是由<code>slave</code>端发起的，可以通过<code>master</code>日志看出：<code>Replica [::1]:6379 asks for synchronization</code></p>
<p>数据同步大致分为两个阶段：</p>
<ol>
<li>全量复制，<code>master</code>进行<code>bgsave</code>，把得到的<code>RDB</code>文件通过<code>socket</code>发送给<code>slave</code></li>
<li>增量&#x2F;部分复制，在<code>master</code>进行<code>bgsave</code>时，可能又修改了某些数据，会将这些修改数据的<strong>指令</strong>存储在<strong>复制缓冲区</strong>中，全量复制完成后，在发送给<code>slave</code>，可以看作<code>AOF</code></li>
</ol>
<p>​    注意：复制缓冲区存在溢出的情形，如果溢出，会再次进行全量复制，可能会陷入死循环</p>
<p>相关指令：</p>
<ol>
<li><p>设置该缓冲区的大小：<code>repl-backlog-size 1mb</code></p>
</li>
<li><p>进行复制时<code>slave</code>是否提供读服务：<code>replica-serve-stale-data yes</code>——-&gt;default</p>
</li>
<li><p><code>slave</code>是否提供写服务：<code>replica-read-only yes</code>———-&gt;default</p>
</li>
</ol>
<p><img src="/fig1.png" alt="by itcast"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>第⑤步中使用的指令为：<code>replconf ack &lt;offset&gt;</code></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--集群(cluster)</title>
    <url>/2020/02/28/redis-9/</url>
    <content><![CDATA[<p>集群的作用：</p>
<ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<span id="more"></span>

<h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ol>
<li>计算<code>key</code>应该放在哪个槽位<code>slot</code> —–&gt; <code>CRC16(key)</code>—–&gt;<code>%16384</code> </li>
<li>集群就是对<code>16384</code>个槽位的分配，每台机器上都有记录所有槽位的分配</li>
<li>对多两次就可命中</li>
</ol>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><ol>
<li><p>开启集群 —–&gt; <code>cluster-enabled yes</code></p>
</li>
<li><p>集群配置文件 —-&gt; <code>cluster-config-file nodes-6379.conf</code></p>
<p>这个文件是由<code>redis</code>自己管理的，如果一个机器上跑了多个集群节点注意文件名不要一样，否则会覆盖，影响集群</p>
</li>
<li><p>超时时间 —-&gt;<code>cluster-node-timeout 15000</code></p>
</li>
</ol>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>用的<code>5.0.5</code>版本已经不推荐使用<code>redis-trib.rb</code>脚本来启动集群了。</p>
<p><code>redis-cli --cluster help</code>会显示详细的使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create         host1:port1 ... hostN:portN</span><br><span class="line">               --cluster-replicas &lt;arg&gt;</span><br></pre></td></tr></table></figure>

<p>创建集群 —-&gt; <code>./src/redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1</code></p>
<p>端口号后边跟的参数表明一个<code>master</code>会有几个<code>slave</code>，从前往后排，前面的是<code>master</code>，后边的为<code>slave</code>，当指定的个数有误时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*** ERROR: Invalid configuration for cluster creation.</span><br><span class="line">*** Redis Cluster requires at least 3 master nodes.</span><br><span class="line">*** This is not possible with 6 nodes and 3 replicas per node.</span><br><span class="line">*** At least 12 nodes are required.</span><br></pre></td></tr></table></figure>

<p>成功启动集群：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-5.0.5]# ./src/redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 --cluster-replicas 1</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:6383 to 127.0.0.1:6379</span><br><span class="line">Adding replica 127.0.0.1:6384 to 127.0.0.1:6380</span><br><span class="line">Adding replica 127.0.0.1:6382 to 127.0.0.1:6381</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 8608aea70c528e8f632c083b79e44a4782630437 127.0.0.1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 82829a4cfa624c3d658e33d66b67d7cfb374d5ea 127.0.0.1:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: ee723da8dfb10b775570b9069f2fb17bff291e9f 127.0.0.1:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: c5ea0e80c1597c349753b7191cf9bc529e6c5b56 127.0.0.1:6382</span><br><span class="line">   replicates ee723da8dfb10b775570b9069f2fb17bff291e9f</span><br><span class="line">S: 03ff774a84676e19076bd93327ec00c85c6ee015 127.0.0.1:6383</span><br><span class="line">   replicates 8608aea70c528e8f632c083b79e44a4782630437</span><br><span class="line">S: 3867efa8d6dd57f7688f0e78e3f7c098d5b0654f 127.0.0.1:6384</span><br><span class="line">   replicates 82829a4cfa624c3d658e33d66b67d7cfb374d5ea</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">......</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6379)</span><br><span class="line">M: 8608aea70c528e8f632c083b79e44a4782630437 127.0.0.1:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: ee723da8dfb10b775570b9069f2fb17bff291e9f 127.0.0.1:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: c5ea0e80c1597c349753b7191cf9bc529e6c5b56 127.0.0.1:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ee723da8dfb10b775570b9069f2fb17bff291e9f</span><br><span class="line">M: 82829a4cfa624c3d658e33d66b67d7cfb374d5ea 127.0.0.1:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 03ff774a84676e19076bd93327ec00c85c6ee015 127.0.0.1:6383</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8608aea70c528e8f632c083b79e44a4782630437</span><br><span class="line">S: 3867efa8d6dd57f7688f0e78e3f7c098d5b0654f 127.0.0.1:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 82829a4cfa624c3d658e33d66b67d7cfb374d5ea</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>若要使用集群，再连接的时候需要加上<code>-c</code>参数</p>
<h3 id="下线"><a href="#下线" class="headerlink" title="下线"></a>下线</h3><ol>
<li><p>如果<code>slave</code>掉线，和其相连的<code>master</code>过了超时时间后会将其标记—&gt;</p>
<p><code>Marking node c5ea0e80c1597c349753b7191cf9bc529e6c5b56 as failing (quorum reached).</code></p>
<p>且会通知其他的所有节点，其他节点会收到一个消息: </p>
<p><code>FAIL message received from ee723da8dfb10b775570b9069f2fb17bff291e9f about c5ea0e80c1597c349753b7191cf9bc529e6c5b56</code></p>
</li>
<li><p>在实验的时候发现一个也会这样，停掉一台<code>slave</code>，有<strong>两台</strong><code>master</code>进行标记，该<code>slave</code>重连后，其中一台<code>master</code>(该从机的)是正常的和它进行同步，另外一台<code>master</code>和其他节点一样清除该标记</p>
<p><code>Clear FAIL state for node c5ea0e80c1597c349753b7191cf9bc529e6c5b56: replica is reachable again.</code></p>
</li>
<li><p>所以说并不一定是<code>slave</code>的<code>master</code>进行标记通知，也可能是其他的<code>master</code>发现该<code>slave</code>掉线进行标记通知</p>
</li>
<li><p>如果是<code>master</code>掉线，其<code>slave</code>会变为<code>master</code>：</p>
<p><code>1995:S 08 Mar 2020 01:22:34.810 # Start of election delayed for 791 milliseconds (rank #0, offset 1722). 1995:S 08 Mar 2020 01:22:34.810 # Cluster state changed: fail 1995:S 08 Mar 2020 01:22:35.214 * Connecting to MASTER 127.0.0.1:6379 1995:S 08 Mar 2020 01:22:35.215 * MASTER &lt;-&gt; REPLICA sync started 1995:S 08 Mar 2020 01:22:35.215 # Error condition on socket for SYNC: Connection refused 1995:S 08 Mar 2020 01:22:35.620 # Starting a failover election for epoch 7. 1995:S 08 Mar 2020 01:22:37.208 # Failover election won: I&#39;m the new master.</code></p>
</li>
<li><p>原<code>master</code>重连后，会变为新<code>master</code>的<code>slave</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--哨兵(sentinel)</title>
    <url>/2020/02/27/redis-8/</url>
    <content><![CDATA[<p>哨兵（监视别人工作）的作用：</p>
<ol>
<li><p>监控：</p>
<p>不断检测<code>master</code>和<code>slave</code>是否正常运行</p>
</li>
<li><p>通知：</p>
<p>当被监控的服务器出现问题时，通知其他哨兵，客户端</p>
</li>
<li><p>自动故障转移</p>
<p>断开<code>master</code>与<code>slave</code>连接，选取一个<code>slave</code>作为<code>master</code>，将其他<code>slave</code>连接到新的<code>master</code>，并告知客户端新的服务器地址</p>
</li>
</ol>
<span id="more"></span>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>redis</code>提供的默认哨兵配置文件为<code>sentinel.conf</code>，常用配置包括：（部分和<code>redis</code>相同配置忽略）</p>
<ol>
<li><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p>
<p>其中<code>mymaster</code>为自定义的名称，后面地址和端口号是要监视的<code>master</code>的，最后的<code>2</code>表示后面的<strong>投票</strong>至少<code>2</code>票就通过</p>
</li>
<li><p><code>sentinel down-after-milliseconds mymaster 30000</code></p>
<p>经过多久<code>master</code>没有反应就认为它<code>S_DOWN</code>（主观掉线）了，因为这是是某一个哨兵发现的，是这个哨兵的主观行为，后续这个哨兵会通知其他哨兵，其他哨兵也会去<code>hello</code>这<code>master</code>，当有<code>2</code>个哨兵都认为它<code>S_DOWN</code>了之后，就确定该<code>master</code>为<code>O_DOWN</code>（客观掉线），大众的看法</p>
</li>
<li><p><code>sentinel parallel-syncs mymaster 1</code></p>
<p>设定一次可以有多少的<code>slave</code>能同时和新<code>master</code>进行同步</p>
</li>
<li><p><code>sentinel failover-timeout mymaster 180000</code></p>
<p>故障转移超时时间，同步超时时间？配置文件里的注释有点看不懂</p>
</li>
</ol>
<h3 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h3><ol>
<li><code>sentinel</code>首先会查询<code>master</code>相关信息（<code>info</code>），随后建立<code>cmd</code>连接，根据得到的信息再去获取<code>slave</code>的信息</li>
<li><code>sentinel</code>之间通过<code>pub/sub</code>分享自己获取的信息</li>
</ol>
<h3 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h3><ol>
<li><code>sentinel</code>向<code>master</code>及<code>slave</code>发送消息<code>publish sentinel:hello......</code>，来确认这些点工作是否正常</li>
<li><code>sentinel</code>向其他<code>sentinel</code>通知上述得到的结果</li>
</ol>
<h3 id="故障转移阶段"><a href="#故障转移阶段" class="headerlink" title="故障转移阶段"></a>故障转移阶段</h3><ol>
<li>某个<code>sentinel</code>发现和<code>master</code>失去了连接，判断为<code>S_DOWN</code>，通知其他<code>sentinel</code></li>
<li>其他<code>sentinel</code>也去尝试联系<code>master</code>，半数以上的<code>sentinel</code>认为<code>master</code>挂了后，判定为<code>O_DOWN</code></li>
<li><code>sentinel</code>们竞选出一个负责处理此次事件的负责人，大家投票</li>
<li>负责人进行处理，挑选备选<code>master</code><ul>
<li>在线的</li>
<li>响应快的</li>
<li>和原<code>master</code>通信较近，丢失数据少的</li>
<li>优先原则（优先级&#x2F;<code>offset</code>&#x2F;<code>runid</code>）</li>
</ul>
</li>
<li><code>sentinel</code>向新的<code>master</code>发送<code>replicaof no one</code>， 向其他的<code>slave</code>发送<code>replicaof &lt;newmasterip&gt; &lt;newmasterport&gt;</code></li>
</ol>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>install mysql</title>
    <url>/2020/03/09/install-mysql/</url>
    <content><![CDATA[<p>在<code>windows</code>中使用数据库，首先下载，太慢的话可以去<a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-8.0/mysql-8.0.17-winx64.msi">TUNA</a></p>
<p>以<strong>管理员</strong>身份到安装目录下的<code>bin</code>目录下：</p>
<ol>
<li><p><code>mysqld --initialize --console</code></p>
<p>会生成一个随机密码</p>
</li>
<li><p><code>mysqld --install</code></p>
<p>安装服务</p>
</li>
<li><p><code>net start MySQL</code></p>
<p>启动服务</p>
</li>
<li><p><code>alter user root@localhost identified by &#39;new pass&#39;</code></p>
</li>
</ol>
<p>   登陆后修改密码</p>
<ol start="5">
<li><code>set global time_zone=&#39;+8:00&#39;</code></li>
</ol>
<p>   设置时区</p>
<p>其他的设置可以查下配置文件<code>my.ini</code></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型中的extend和super</title>
    <url>/2020/04/29/generics/</url>
    <content><![CDATA[<p>在<code>java</code>中经常会看到泛型中使用<code>&lt;? extends T&gt;/&lt;? super T&gt;</code> ，这个<a href="https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java">回答</a>很好，这里记下我看后的思考。</p>
<span id="more"></span>

<h3 id="lt-extends-T-gt"><a href="#lt-extends-T-gt" class="headerlink" title="&lt; ? extends T&gt;"></a>&lt; ? extends T&gt;</h3><p>当声明了这样的一个泛型后，实际上其可以指向<code>T</code>或其子类的泛型，主要的一个点是<strong>在运行之前，无法确定到底指向的是哪个类型的泛型</strong>：</p>
<ol>
<li>这时<code>JVM</code>为了避免实际指向的类型<code>Tsub1</code>和你想放进去的类型<code>Tsub2</code>产生冲突，所以干脆就<strong>不让</strong><code>put</code>了。</li>
<li>但是读取的时候，完全可以按照<code>T</code>来读取所有的内容，可以理解为多态，父类型引用指向子类型对象，一样可以操作，所以<strong>可以</strong><code>get</code>.</li>
</ol>
<h3 id="lt-super-T-gt"><a href="#lt-super-T-gt" class="headerlink" title="&lt;? super T&gt;"></a>&lt;? super T&gt;</h3><p>这样声明的话，实际上可以指向<code>T</code>或其父类的泛型，同样<strong>运行之前无法确定实际指向的类型</strong>：</p>
<ol>
<li>不论指向的是<code>T</code>或其父类型，都能保证<code>T</code>或其子类<strong>可以</strong><code>put</code>进去，同样是父类引用指向子类对象，没毛病。</li>
<li>但是读取的时候就出现问题了，如果不考虑根父类<code>Object</code>，不同类型的东西读出来的时候没有一个统一的类型，不像上边可以统一按照类型<code>T</code>读取。真的想拿出的话就只能按<code>Object</code>拿了。</li>
</ol>
<h3 id="PECS"><a href="#PECS" class="headerlink" title="PECS"></a>PECS</h3><p>一般这个东西都会带一起看，是<code>Producer Extends， Consumer Super</code>的简称，这句话站在<strong>集合</strong>的角度看比较容易理解</p>
<ol>
<li>如果集合作为<code>Producer</code>，那么其他的消费者就要从这个集合中拿东西，相当与<code>get</code>多，就选用<code>extends</code></li>
<li>如果集合作为<code>Consumer</code>，那么它就要从别的生产者那里拿东西放到自己里边，相当于<code>put</code>多，就选用<code>super</code></li>
</ol>
]]></content>
      <tags>
        <tag>泛型</tag>
        <tag>generics</tag>
      </tags>
  </entry>
  <entry>
    <title>创建其他类中非静态内部类</title>
    <url>/2020/07/30/create-not-static-inner-class-instance/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JHSDB_TestCase</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NoStaticTest</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JHSDB_TestCase</span> <span class="variable">jhsdb_testCase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JHSDB_TestCase</span>();</span><br><span class="line">        JHSDB_TestCase.<span class="type">NoStaticTest</span> <span class="variable">noStaticTest</span> <span class="operator">=</span></span><br><span class="line">                jhsdb_testCase.<span class="keyword">new</span> <span class="title class_">NoStaticTest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的String</title>
    <url>/2020/07/31/String-in-Java/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看看最后判断的结果是什么 -----------jdk1.8之后-------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>).append(<span class="string">&quot;str&quot;</span>).toString();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(str == str.intern());</span><br><span class="line">    System.out.println(str1 == str1.intern());</span><br><span class="line">    System.out.println(str2 == str1.intern());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(str == str.intern());           <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str1.intern());         <span class="comment">// false</span></span><br><span class="line">System.out.println(str2 == str1.intern());         <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>看到<code>JVM</code>中提到的各种常量池，我真是</p>
<p>其中当然也包括<strong>字符串常量池</strong>(<strong>StringTable</strong>)，看了网上众说纷，我真是</p>
<p>下面用几个简单的示例，来看看用<code>JHSDB</code>看到的东西，先看</p>
<h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>).append(<span class="string">&quot;str&quot;</span>).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述输出语句打上断点，用<code>jps</code>查看进程id，用<code>jhsdb hsdb --pid id</code>连上该进程</p>
<p>依次点击<code>Tools-&gt;Object Histogram</code>, 在列出来的类中双击<code>String</code>类型，然后找到上边写的<code>str</code>串，如下图</p>
<p><img src="/fig1.png"></p>
<p>发现如下三点：</p>
<ol>
<li>字符串已经排好序了</li>
<li>只有一个<code>str</code></li>
<li>只有一个<code>strstr</code></li>
</ol>
<p>通过依次点击<code>Tools-&gt;Heap Parameters</code>，可以看到当前堆的地址范围，比较得知，上述提到的两个字符串的地址是在堆范围内的。</p>
<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次只修改了字符串的声明，仍然按照上述步骤，看到的信息如下</p>
<p><img src="/fig2.png"></p>
<p>发现这里出现了两个<code>str1</code>，继续</p>
<h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>).append(<span class="string">&quot;str1&quot;</span>).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<strong>case1</strong>进行修改，<code>append</code>一个不一样的串，结果如下</p>
<p><img src="/fig3.png"></p>
<p>在类似的地址上找到了三个串，继续变</p>
<h3 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;str&quot;</span>).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次也不追加了，就一个，结果如下</p>
<p><img src="/fig4.png"></p>
<p>结果和<strong>case2</strong>一样，继续</p>
<h3 id="case5"><a href="#case5" class="headerlink" title="case5"></a>case5</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str2&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，只有一个串</p>
<p><img src="/fig5.png"></p>
<hr>
<p>下面对上边五种情况作个小结，含有<strong>猜</strong>的成分</p>
<ul>
<li>字符串还是放在堆上的，至于<strong>字符串常量池</strong>这个概念，里边放的到底是什么，就上边几个简单例子来看，是不会放字符串本身的，也就只能放引用了</li>
<li>程序中被双引号引起来的字符串，都会先到堆中，重复的不会重复放(对比<strong>case1</strong>和<strong>case3</strong>)</li>
<li>对于<code>new</code>操作，会把最终合成的字符串(<code>new String(&quot;a&quot;)+new String(&quot;b&quot;)</code>, <code>new StringBuilder(&quot;a&quot;).append(&quot;b&quot;)</code>, 以及<code>new String(&quot;a&quot;).concat(&quot;b&quot;)</code>生成的<code>&quot;ab&quot;</code>或单纯的<code>new String(&quot;ab&quot;)</code>)在堆中创建一遍(对比<strong>case1&#x2F;2&#x2F;3&#x2F;4</strong>)</li>
<li><strong>字符串常量池</strong>中放的引用其实是指向堆中的字符串的，而且不会重复(即使堆中有多个字面量相同的字符串，<strong>字符串常量池</strong>中也只会有一个指向该字面量的引用)</li>
</ul>
<hr>
<p>这样一来，在对开头的示例进行解释</p>
<ol>
<li><code>str == str.intern()</code> 在为<code>str</code>赋值时，加引号的<code>&quot;str&quot;</code>先被创建且其对应的引用也放到<strong>字符串常量池</strong>中了，然后在堆上创建<code>&quot;strstr&quot;</code>对象，此时还没放到<strong>字符串常量池</strong>中，在调用<code>str</code>的<code>intern()</code>方法时将其引用放到了<strong>字符串常量池</strong>中，因此<code>str</code>和<code>str.intern()</code>实际上都指向的是同样一个对象, 返回<code>true</code></li>
<li><code>str1 == str1.intern()</code> 根据前边的小结，在执行<code>String str1 = new String(&quot;str1&quot;);</code>时，首先根据双引号，在堆中创建了一个<code>&quot;str1&quot;</code>串，记为<strong>H1</strong>, 然后将其引用放入<strong>字符串常量池</strong>中，接着又在堆中<code>new</code>了另外一个<code>&quot;str1&quot;</code>, 记为<strong>H2</strong>, 此时<strong>H2</strong>可不会再放到<strong>字符串常量池</strong>中了，结果<code>str1 ---&gt; H2</code>，<code>str1.intern() ---&gt; H1</code>，他们指向不同的地址，返回<code>false</code></li>
<li><code>str2 == str1.intern()</code> 由于<code>str2</code>在创建时，发现<strong>字符串常量池</strong>已经有指向<code>&quot;str1&quot;</code>字面值的引用了，因此直接返回了，相当与<code>str2 ---&gt; H1 &lt;--- str1.intern()</code>，指向相同的地址，返回<code>true</code></li>
</ol>
<p>再对这个例子画个小图</p>
<p><img src="/fig6.png"></p>
<hr>
<p>最后再引用一些其他说法</p>
<p><a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a> </p>
<p>提到了一句话：全局字符串池里的内容是在<strong>类加载完成，经过验证，准备阶段</strong>之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中</p>
<p>再结合上图，如果这句话没错的话，那么灰色的字符串是在准备阶段后生成的，而白色的则是在程序运行过程中生成的</p>
<p><a href="https://www.zhihu.com/question/57109429">https://www.zhihu.com/question/57109429</a></p>
<p>根据<a href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a>的回答，<code>StringTable</code>放置于<code>native memory</code>中，且只存放引用</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>字符串常量池</tag>
        <tag>StringTable</tag>
      </tags>
  </entry>
  <entry>
    <title>poj2411</title>
    <url>/2020/10/12/poj2411/</url>
    <content><![CDATA[<p>用<code>1*2</code>的长方形, 可以横着放，也能竖着放，填充高为<code>h</code>，宽为<code>w</code>的面积，问有多少种铺法? <a href="http://poj.org/problem?id=2411">原址</a></p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>理解他人的思想后，我画几张图进行补充</p>
<p>1）考虑最后一块的情况，如图1，其中黑色的表示已经覆盖了的，白色的表示还没覆盖的（先不要考虑黑色部分是如何覆盖的）</p>
<p><img src="/image-20201012204456612.png" alt="image-20201012204456612"></p>
<p>在这种情况下，是没法把全部方块覆盖完的。</p>
<p>接着最后一块的另一种情况，如图2， 如果最后一块被覆盖了，说明任务完成。</p>
<p><img src="/image-20201012204617877.png" alt="image-20201012204617877"></p>
<p>2）在考虑最后两块没填的情况，一共有四种可能（<code>00，01，10，11/0表示没填，1表示填了</code>），这里先看<code>00</code>的情况，图3:</p>
<p><img src="/image-20201012205647529.png" alt="image-20201012205647529"></p>
<p>这时候刚好可以横着放下一块，因此存在一种覆盖方法。如果是<code>01</code>，图4：这种情况也没法填满了。</p>
<p><img src="/image-20201012210011138.png" alt="image-20201012210011138"></p>
<p>（<strong>注意这里的状态表示是从最先的未填充的格子开始记的，因此状态码转换为二进制后，最低位表示的是最先未填充的格子，是反着来的，比如虽然上述状态为<code>01</code>，但其实记为状态2，究其原因是倒着从右往左，从下到上导致的，既然这样可以，那顺着从上到下，从左到右也是可以的，那样状态码就不用逆着了</strong>）</p>
<p>如果是<code>10</code>，如图5，该填的倒数第二个各自已经填过了，这时候就看倒数第一个格子在当前状态下(没填)，它有几种填充方案，会发现，此时就到了图1的情况了。</p>
<p><img src="/image-20201012211214894.png" alt="image-20201012211214894"></p>
<p>因此可以考虑将前面的状态保存起来，让后面的遍历可以直接查询值就好（前提是后边的状态在处理过程中和前边的状态一致了）。</p>
<p>那么要保存多少个状态呢，需要保存一行的状态，每个格子两种状态，一行就是<code>pow(2, w)</code>中状态。（为什么要保存一行的状态呢，保存半行，两行行不行呢）</p>
<p>就是说，对于图6箭头所指的方块来说，它要考虑紫线覆盖的方格的所有的状态。</p>
<p><img src="/image-20201012212507459.png" alt="image-20201012212507459"></p>
<p>当遍历到的状态，该格子为<code>0</code>（没填）时，就需要看能不能横着放，能不能竖着放；如果该格子为<code>1</code>，说明填过了，那么该状态下可能的填充方案就取决于前边格子在当前状态下填充的方案。</p>
<p>下面分别考虑这三种情况：</p>
<ol>
<li>横着放，判断右边是否超边界，且右边的格子状态为<code>0</code>，不然右边格子都填过了，还怎么填。假设当前判断的状态为<code>00000000</code>，那么可以横着放，放下去之后如下图所示：</li>
</ol>
<p><img src="/image-20201012213156621.png" alt="image-20201012213156621"></p>
<p>这样一来，就多了好多种摆放的方法了，具体多少种呢，只要去查右边的格子，处于状态<code>10000000</code>有多少种填充方法即可。</p>
<ol start="2">
<li>竖着放，竖着放只需要看竖着是否超边界就行，至于当前格子下边那个格子的状态是不用考虑的，因为就保存的一行状态来说，也没保存到它，不如就默认下边的没填，然后更新状态后再去处理，比如这里选择状态为<code>00110101</code>，如下图所示：</li>
</ol>
<p><img src="/image-20201012213926610.png" alt="image-20201012213926610"></p>
<p>这样一来，又多了几种摆放方法，多了右边格子处于状态<code>01101011</code>（就是去掉当前状态的低位，最高位置为<code>1</code>）</p>
<ol start="3">
<li>已填，比如处理到状态<code>11000011</code>时，如下图所示，（此时处理的格子为绿色箭头指的）此时该状态下的填充方法，取决于下一个格子（也就是右边，到了边界就是下一行的开头格子）处于<code>10000110</code>状态下的填充方法，注意这时候可不用加了，因为这种情况，本质上并没有引入新的摆放方法。可以考虑图3所示的情况，假如此时处理的是第三个格子（及两白色左边的黑格子），那么状态就为<code>100</code>了，由于第三个格子状态为<code>1</code>，已经填过了，此状态下，具体有多少种填充方法就看两个白格子了（就一种咯）。</li>
</ol>
<p><img src="/image-20201012214348453.png" alt="image-20201012214348453"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poj2411</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(filledWithRec(<span class="number">4</span>, <span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">filledWithRec</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((h*w &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[h][w][<span class="number">1</span> &lt;&lt; w];</span><br><span class="line">        <span class="comment">// dp[i][j][k] represent how many different ways to cover the remainder place after (i, j) at status k</span></span><br><span class="line">        dp[h - <span class="number">1</span>][w - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[h - <span class="number">1</span>][w - <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> hasNext(i, j, h, w, next);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; w); k++) &#123;</span><br><span class="line">                    <span class="comment">// if (i, j) is filled</span></span><br><span class="line">                    <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hasNext)</span><br><span class="line">                            dp[i][j][k] = dp[next[<span class="number">0</span>]][next[<span class="number">1</span>]][k&gt;&gt;&gt;<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// fill (i, j) with a 1*2 row, with status 00...</span></span><br><span class="line">                        <span class="keyword">if</span> (j+<span class="number">1</span>&lt;w &amp;&amp; ((k&amp;<span class="number">2</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">                            dp[i][j][k] += dp[next[<span class="number">0</span>]][next[<span class="number">1</span>]][(k|<span class="number">2</span>)&gt;&gt;&gt;<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// fill (i, j) with a 2*1 column</span></span><br><span class="line">                        <span class="keyword">if</span> (i+<span class="number">1</span> &lt; h) &#123;</span><br><span class="line">                            dp[i][j][k] += dp[next[<span class="number">0</span>]][next[<span class="number">1</span>]][(k&gt;&gt;&gt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;(w-<span class="number">1</span>))];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> h, <span class="type">int</span> w, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == h - <span class="number">1</span> &amp;&amp; j == w - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        next[<span class="number">1</span>] = (j + <span class="number">1</span>) % w;</span><br><span class="line">        next[<span class="number">0</span>] = j == w - <span class="number">1</span> ? i + <span class="number">1</span> : i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>poj</tag>
        <tag>状态dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kong Kim in plane</title>
    <url>/2020/10/14/Kong-Kim-in-plane/</url>
    <content><![CDATA[<p>金刚坐飞机问题，有一班飞机要起飞，乘客们正准备按机票号码（1，2，…，N）依次登机。突然来了个金刚，他也有飞机票，但是他插队第一个上了飞机，随机选个座位坐下了。其他乘客有两种反应：</p>
<ol>
<li>他们也随意找个位置坐下；</li>
<li>如果自己座位没有被占领，就坐自己的位置，否则随意找个位置坐下。</li>
</ol>
<p>在这两种情况下，第<code>i</code>个乘客（除去金刚外）坐到自己原机票位置的概率分别是多少？</p>
<span id="more"></span>

<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>要保证第<code>i</code>个乘客坐到自己的位置上，则前<code>i-1</code>个乘客包括金刚都别坐到第<code>i</code>个人的座位，第<code>i</code>个人就有机会坐到自己的位置，得到概率公式为：<br>$$<br>f(i)&#x3D;\frac{N-1}{N}*\frac{N-2}{N-1}<em>\dots</em>\frac{N-i+1}{N-i+2}*\frac{1}{N-i+1}&#x3D;\frac{1}{N}  （1）<br>$$</p>
<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>由于当乘客座位没人坐的时候，他会优先选自己的座位，那么设金刚坐在<code>n</code>号位置，当<code>n=1/n&gt;j</code>，即在最开始时，前<code>i</code>个人的座位都保留着，那么他们上机后都会坐自己的座位；当<code>n=i</code>时，第<code>i</code>个人肯定坐不到自己的位置了；比较麻烦的就是当金刚在<code>1&lt;n&lt;i</code>之间的情况，此时<code>2~n-1</code>这几位乘客还是能坐到自己的位置，而第<code>n</code>位乘客肯定坐不到自己的位置了，他要开始<strong>随便</strong>坐了，既然他都<strong>随便</strong>坐了，那和金刚有什么区别？因此我们换种想法：</p>
<p><img src="/image-20201014131143349.png" alt="image-20201014131143349"></p>
<p>即把金刚当作第<code>n</code>个人，而真正的第<code>n</code>人当作金刚，只不过该虚假的金刚和真正的金刚还是有点差别的，那就是他没有真正金刚那么多的座位选择，这个假金刚只能从剩下的<code>N-n+1</code>个座位里边选一个坐（1， n+1，n+2，…，N）。如此一来，当金刚坐在第<code>n</code>个座位（<code>1&lt;n&lt;i</code>）时，第<code>i</code>个人坐到自己座位的概率就变成了：<br>$$<br>f(n)&#x3D;\sum_j \frac{1}{N-n+1}*f(j),(j&#x3D;1,n+1,…,N)（2）<br>$$<br>由该递推式，进一步可以得到<code>n=n+1</code>时的情况，即：<br>$$<br>f(n+1)&#x3D;\sum_j \frac{1}{N-n}<em>f(j),(j&#x3D;1,n+2,…,N)（3）<br>$$<br>上述两个式子相减，即得到：<br>$$<br>(N-n)</em>[f(n)-f(n+1)]&#x3D;f(n+1)-f(n) &#x3D;&gt; f(n)&#x3D;f(n+1),(1&lt;n&lt;i-1)（4）<br>$$<br>最终可得：<br>$$<br>f(n)&#x3D;\frac{N-i+1}{N-i+2}（5）<br>$$<br>在不同情况下的<code>f(n)</code>都已求得，最后在把所有情况概率和相加即可：<br>$$<br>\sum_{n&#x3D;1}^N \frac{1}{N}*f(n)&#x3D;\frac{N-i+1}{N-i+2}（6）<br>$$</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>上述两种情况都假设乘客按照顺序上机，那如果乘客上机的顺序也是随机，第<code>i</code>个乘客上机坐到自己位置的概率怎么算呢？</p>
<p>对第一种情况影响不大，因为所有人就算是按顺序上机，座位也是随便坐的，和随便登机没差。</p>
<p>第二种情况下，当金刚坐在<code>n</code>号座位时，如果紧接着就是第<code>n</code>个人登机，那么他完全有可能坐到前<code>n</code>个人的座位，Orz</p>
]]></content>
      <tags>
        <tag>kong kim</tag>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title>gray code</title>
    <url>/2020/10/16/gray-code/</url>
    <content><![CDATA[<p>格雷码（gray code&#x2F;reflected binary code），循环二进制单位距离码，是任意两个相邻编码只有一位差异的编码，属于可靠性编码。</p>
<p>一个简单的例子，普通二进制中<code>011-&gt;100(3-&gt;4)</code>时，三个bit位都需要取反，因此在三位未完全转换时，存在6种中间状态（之转换了一位+剩一位没转换），但是格雷码中<code>010-&gt;110</code>只需要一位取反，避免了其他的可能。</p>
<span id="more"></span>

<h3 id="二进制转格雷码"><a href="#二进制转格雷码" class="headerlink" title="二进制转格雷码"></a>二进制转格雷码</h3><p>假设四位格雷码起始为<code>0000</code>，则二进制<code>abcd</code>对应的格雷码为<code>(0^a)(a^b)(b^c)(c^d)</code></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>格雷码</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>000</td>
</tr>
<tr>
<td>001</td>
<td>001</td>
</tr>
<tr>
<td>010</td>
<td>011</td>
</tr>
<tr>
<td>011</td>
<td>010</td>
</tr>
<tr>
<td>100</td>
<td>110</td>
</tr>
<tr>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>110</td>
<td>101</td>
</tr>
<tr>
<td>111</td>
<td>100</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gray = binary ^ (binary&gt;&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="格雷码转二进制"><a href="#格雷码转二进制" class="headerlink" title="格雷码转二进制"></a>格雷码转二进制</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gray = binary ^ (binary&gt;&gt;<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 两边同时异或 &#x27;gray &gt;&gt; 1&#x27;，即 &#x27;(binary ^ (binary&gt;&gt;1)) &gt;&gt; 1&#x27;</span></span><br><span class="line">gray ^ (binary ^ (binary&gt;&gt;<span class="number">1</span>)) &gt;&gt; <span class="number">1</span> = binary ^ (binary&gt;&gt;<span class="number">1</span>) ^ (binary&gt;&gt;<span class="number">1</span>) ^ (binary&gt;&gt;<span class="number">2</span>) </span><br><span class="line">gray ^ (binary ^ (binary&gt;&gt;<span class="number">1</span>)) &gt;&gt; <span class="number">1</span> = binary ^ (binary&gt;&gt;<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 可以发现等号右边 (binary&gt;&gt;1) 变成了 (binary&gt;&gt;2)</span></span><br><span class="line"><span class="comment"># 以此类推，两边继续异或下去，当 (binary&gt;&gt;n) == 0时，右边就剩binary了，二左边自然就是二进制表示了</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他生成格雷码的方法还有镜像法，观察以<code>0</code>为起始码的格雷码即可发现该规律</p>
]]></content>
      <tags>
        <tag>gray</tag>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 22. Generate Parentheses</title>
    <url>/2020/10/16/valid-parenthesis/</url>
    <content><![CDATA[<p>假设有<code>n</code>对括号，让你生成所有的有效的括号序列。</p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>官方给出了三种方法，一是暴力法，生成所有可能的序列，然后再判断该序列是否有效；二是回溯法，即在生成括号的过程中就进行判断，主要是根据当前左右括号的数量。</p>
<p>第三种方法比较类似分治？因为第一个位置一定要是个<code>(</code>，那么和该括号匹配的<code>)</code>就需要在一个奇数位置（从0开始），这样这对括号之间才能空出偶数个空，才能放置有效的括号序列，类似这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(..A..)..B..</span><br></pre></td></tr></table></figure>

<p>若与第一个<code>(</code>匹配的<code>)</code>的坐标设为<code>2*i+1(0&lt;=i&lt;n)</code>，那么片段<code>A</code>就是包含<code>i</code>对括号的有效序列，片段<code>B</code>就是包含<code>n-i-1</code>对括号的有效序列，假设<code>n</code>对括号的有效序列数设为<code>f(n)</code>，那么就有下式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)*f(0)</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beauty0403</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;String&gt;[] caches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">2</span>*n];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        caches[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        caches[<span class="number">0</span>].add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        List&lt;String&gt; generate = generate(n);</span><br><span class="line">        System.out.println(generate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (caches[n] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches[n];</span><br><span class="line">        &#125;</span><br><span class="line">        caches[n] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n-<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String sf : generate(i)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String ss : generate(n-i-<span class="number">1</span>)) &#123;</span><br><span class="line">                    ans.add(<span class="string">&quot;(&quot;</span> + sf + <span class="string">&quot;)&quot;</span> + ss);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        caches[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>上述表达式和<a href="https://en.wikipedia.org/wiki/Catalan_number"><code>Catalan Number</code></a>的定义类似，而且还有很多问题都和<code>Catalan Number</code>相关，比如编程之美的4.3，及其扩展问题，还有wiki上举的一些例子。</p>
<p>有些题目很容易理解，取值范围和<code>Catalan Number</code>一致时，可以直接套上边的模板，但是有个多边形划分为三角形问题，就不太一样。</p>
]]></content>
      <tags>
        <tag>parenthesis</tag>
        <tag>catalan</tag>
      </tags>
  </entry>
  <entry>
    <title>ants crawl</title>
    <url>/2020/10/17/ants-crawl/</url>
    <content><![CDATA[<p>一根细杆上有几只蚂蚁，杆子太细了以致于不能同时通过两只蚂蚁，开始时，蚂蚁的头朝向是随机的，只会朝前走或掉头，但不会后退。当任意两只蚂蚁碰头时，他们会同时调头朝反方向走，假设蚂蚁们每秒可以走1cm，求所有蚂蚁都离开木杆的最长和最短时间。</p>
<span id="more"></span>

<p>由于蚂蚁们的速度是一样的，当两个蚂蚁相遇掉头时，可以转化为互换位置，如下图所示：</p>
<p><img src="/fig1.png" alt="change positions"></p>
<p>虽然蚂蚁不一样了，但是需要的所有的蚂蚁离开木杆的时间，这样转换对于最终的结果是没有影响的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Beauty0407</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">27</span>;</span><br><span class="line">        <span class="type">int</span>[] antPos = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">23</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;min-max:&quot;</span> + Arrays.toString(calTime(length, antPos)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] calTime(<span class="type">int</span> length, <span class="type">int</span>[] antPos) &#123;</span><br><span class="line">        <span class="comment">// min time, max time</span></span><br><span class="line">        <span class="type">int</span>[] times = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> currentMin;</span><br><span class="line">        <span class="type">int</span> currentMax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> antPo : antPos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPo &lt; (length &gt;&gt; <span class="number">1</span>)) &#123;         <span class="comment">// left part</span></span><br><span class="line">                currentMax = length - antPo;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentMax = antPo;               <span class="comment">// right part</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentMin = length - currentMax;         <span class="comment">// reverse</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (times[<span class="number">1</span>] &lt; currentMax) &#123;</span><br><span class="line">                times[<span class="number">1</span>] = currentMax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times[<span class="number">0</span>] &lt; currentMin) &#123;      <span class="comment">// 这个地方原书有点问题？</span></span><br><span class="line">                times[<span class="number">0</span>] = currentMin;        <span class="comment">// 应该是计算最小值中的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展1"><a href="#扩展1" class="headerlink" title="扩展1"></a>扩展1</h3><pre><code>第i个蚂蚁，什么时候走出木杆？
</code></pre>
<p>引入一个结论：</p>
<pre><code>假设初始时一共N个蚂蚁，朝左的有a只，朝右的有N-a只，最终经过数次碰撞后，初始情况下从左数a只蚂蚁会从左边掉落，从右数N-a只蚂蚁会从右掉落
</code></pre>
<p>先考虑最简单的情况，比如只有两个蚂蚁的时候：</p>
<p><img src="/fig2.png" alt="two ants"></p>
<p>黑蚂蚁朝右边走，白蚂蚁朝左边走，<code>1s</code>后俩相遇：</p>
<p><img src="/fig3.png" alt="meet"></p>
<p>然后两蚂蚁掉头，一直走到木杆尽头：</p>
<p><img src="/fig4.png" alt="arrive at end"></p>
<p>经过统计后，黑蚂蚁用时<code>3s</code>（先右<code>1s</code>，后左<code>2s</code>），白蚂蚁用时<code>4s</code>（先左<code>1s</code>，后右<code>3s</code>）。</p>
<p>在这种简单的情况下， 很容易发现由于两蚂蚁速度是相同的，在相遇时，两只蚂蚁走过的距离是相同的，而后黑白蚂蚁又分别掉头，可以看出黑蚂蚁走过的路程起始是白蚂蚁往左走到尽头需要的距离，而白蚂蚁走过的路程，又是黑蚂蚁往右走到尽头的距离。</p>
<p>在考虑三个蚂蚁的情况：</p>
<p><img src="/fig5.png"></p>
<p><img src="/fig6.png"></p>
<p><img src="/fig7.png"></p>
<p>黑蚂蚁走了5格，白蚂蚁走了6格，灰蚂蚁走了4格</p>
<p>对比初始状态：</p>
<ul>
<li>灰蚂蚁走过的路，正好是从右开始数，第一个朝右的白蚂蚁距离右端的距离</li>
<li>白蚂蚁走过的路，正好是从右开始数，第二个朝右的黑蚂蚁距离右端的距离</li>
<li>黑蚂蚁走过的路，正好是从左开始数，第一个朝左的灰蚂蚁距离左端的距离</li>
</ul>
<p>推论：</p>
<pre><code>当i&lt;=N-a时，说明蚂蚁i最终要掉左边，那么蚂蚁i走过的路程为从左往右数，第i个朝左的蚂蚁距离左端的距离；当i&gt;N-a时，说明蚂蚁i最终要掉右边，那么蚂蚁i走过的路程为从右往左数，第N-i+1个朝右的蚂蚁距离右端的距离
</code></pre>
<p>但要如何证明这个结论呢</p>
<h3 id="扩展2"><a href="#扩展2" class="headerlink" title="扩展2"></a>扩展2</h3><pre><code>蚂蚁一共会碰撞多少次？
</code></pre>
<p>需要注意的是，一共的碰撞次数并不是所有蚂蚁碰撞次数之和，因为这样会重复计算碰撞，可以只选朝左（右）的蚂蚁作为计算单位，看他们左（右）边，朝右（左）的蚂蚁个数，就是该蚂蚁碰撞次数，这样累加标准方向的蚂蚁碰撞次数即为总的碰撞次数。</p>
]]></content>
      <tags>
        <tag>beautyOfProgramming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1024. Video Stitching</title>
    <url>/2020/10/25/leetcode1024/</url>
    <content><![CDATA[<p>给定一些区间，从中选择某些区间（可重叠），使得其能完全覆盖<code>[0, T]</code>，返回最少需要的区间个数。</p>
<span id="more"></span>

<p>看到这一题想到了编程之美上的区间重合问题，又想一下发现求解是不同的，一个是简单的判断能否完全覆盖，一个需要最少区间的区间个数去覆盖。由于见识比较少，就想着按书上的思路来，先做个排序再说，这样一来，区间片段就按开始从小到大排序，当开始相同时，就忽略掉前边的区间，因为后边的总能把前边的区间完全覆盖掉，因此只考虑相同起始点的最后一个区间。然后挨着盘的看后边的区间能否<strong>延长</strong>当前已覆盖的区间，如果能延长的话，就把需要的区间数+1，但是这样是存在问题的，比如下边的情况，要覆盖的总区间为<code>[0, 9]</code></p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>这样的情况，在上边的简单的判断逻辑情况下，会发现每个区间都能<strong>延长</strong>前边的区间们所覆盖的区间，这样一来要覆盖完全就需要上边的所有4个区间，但其实只用3个区间就行（0-4,4-8,6-9||0-4,2-6,6-9），后来又经过长时间的冥思苦想，发现可以这样做，首先0开头的肯定是要选的，比如是[0, a]，那么后边的就可以选从[1, a]之间，能覆盖的最远的区间（看了解答后才想起来是青蛙跳）。</p>
<p>但是提交后，发现效率很低，那肯定是排序的影响，其实也确实是不用排序的，只需要提前处理一遍，把[0, T]之间开头的能到的最远的区间记录下来，剩下的步骤其实和上边是一样的。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
        <tag>青蛙跳</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 144. Binary Tree Preorder Traversal</title>
    <url>/2020/10/27/leetcode144/</url>
    <content><![CDATA[<p>二叉树的前序遍历，除了递归，还有两种迭代的方法，一种是常见的利用栈空间复杂度为O(n)，另一种只利用树中空间指针空间复杂度为O(1).</p>
<span id="more"></span>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>利用栈的话：</p>
<ul>
<li>从头开始遍历，用<code>cur</code>表示当前访问的点（直接打印值）</li>
<li>然后再把把<code>cur</code>放进栈（因为后边先只访问了它左边的子树，后边还要再取出来访问它右边的子树），<code>cur=cur-&gt;left</code></li>
<li>当<code>cur</code>为空时，就从栈中弹出一个元素作为<code>cur</code>，再接着上述步骤，直到栈为空，<code>cur</code>为空</li>
</ul>
<h3 id="morris"><a href="#morris" class="headerlink" title="morris"></a>morris</h3><p>这种方法是由J. H. Morris在1979年提出的方法，其主要思想是通过在遍历过程中，利用每个节点<code>cur</code>的前驱节点<code>pre</code>的右指针（由于<code>pre</code>是<code>cur</code>的前驱了，因此<code>pre</code>的右边一定是<code>null</code>），将<code>pre.right=cur</code>，如此一来，在当前访问到<em>尽头</em>时，可以通过该指针在跳回到上面去，以此完成遍历。</p>
<p>存在如下情况：</p>
<ol>
<li>设置<code>cur=root, pre=null</code></li>
<li>当<code>cur.left=null</code>时，它已经不存在前驱了，直接访问然后向右走</li>
<li>当<code>cur.left!=null</code>时，其必然存在前驱，通过遍历找到<code>cur</code>的前驱<code>pre</code>，此时有两种情况：<ul>
<li><code>pre.right=null</code>，说明这是第一次遇到<code>cur</code>，则对其访问，并设置<code>pre.right=cur</code>，<code>cur</code>继续向左走</li>
<li><code>pre.right=cur</code>，说明之前已经遇到过<code>cur</code>了（才能这样设置），且以<code>pre</code>作垂线，其左边部分必然也全部访问过了，即<code>cur</code>左边的部分已经全部访问过了，不然<code>cur</code>也不会转完一圈回到之前的地方，此时<code>cur</code>向右走，并且把<code>pre.right</code>设置为空（已经没有利用价值了，并且要保持原树结构）</li>
</ul>
</li>
</ol>
<p>比如说下图的树：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>当<code>cur</code>从<code>1-&gt;2-&gt;4</code>(<strong>case3.1</strong>)，虚线表示他们各自的前驱指向他们，这时候<code>1，2，4</code>都访问过了，接着往左走</p>
<p><img src="/fig2.png" alt="fig2"></p>
<p><code>cur=5</code>，由于<code>5</code>没得前驱了，直接访问<code>5</code>然后往右走(<strong>case2</strong>)。由于之前的设置，<code>cur</code>又回到了把<code>5</code>当作前驱的节点<code>4</code>，此时符合<strong>case3.2</strong>，后续访问如下所示：</p>
<p><img src="/fig3.png" alt="fig3"></p>
<p><img src="/fig4.png" alt="fig4"></p>
<p><img src="/fig5.png" alt="fig5"></p>
<p><img src="/fig6.png" alt="fig6"></p>
<p><img src="/fig7.png" alt="fig7"></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>morris</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 927. Three Equal Parts</title>
    <url>/2020/10/27/leetcode927/</url>
    <content><![CDATA[<p>将一个只含1&#x2F;0的数组分为三部分，使得各个部分表示的二进制的值相同，高位的0可以忽略</p>
<span id="more"></span>

<p>我想到的解比较复杂，即假设三个部分的有效长度为<code>x</code>，然后依次求得各个部分的结束的坐标，然后往左判断是否相等。由于前导0对二进制的值是没有影响的，因此某个部分的结束坐标可以向左平移，这样空出来的0就算到下一个部分的前导0了，当测试用例比较大时就tle了。</p>
<p>正确的解答是，先根据1的个数确定三个部分的大致界限，因为三个部分二进制数相等必然能推出三个部分含1的个数相同，因此当给定数组中的1的个数不能被3除尽时，就不可能存在正解；否则就找到三个片段使得其中含有的1的个数相同，又由于第三部分是要持续到数组末尾的，所有要考虑第三部分最后的0的个数，如下图：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>part123部分含有的1的个数相等，那么剩下的部分开头以及gap123就只剩0了，又由于part3要持续到数组结束，因此part3实际上要包含gap3的所有的0，因此当gap1或gap2小于gap3时，就说明part1或part2没法搞来那么多低位0，因此也不会有正解。经过调整后，如果存在解，那么解必然如下所示：</p>
<p><img src="/fig2.png" alt="fig2"></p>
<p>可以再判断一次各个部分长度是否相等，然后再以此判断各个位上是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] threeEqualParts(<span class="type">int</span>[] A) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] former1 = <span class="keyword">new</span> <span class="title class_">int</span>[A.length+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                currentCount ++;</span><br><span class="line">                former1[currentCount] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentCount == <span class="number">0</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            res[<span class="number">1</span>] = A.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentCount % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">first1Begin</span> <span class="operator">=</span> former1[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">first1End</span> <span class="operator">=</span> former1[currentCount/<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">second1Begin</span> <span class="operator">=</span> former1[currentCount/<span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">second1End</span> <span class="operator">=</span> former1[currentCount/<span class="number">3</span> * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">third1Begin</span> <span class="operator">=</span> former1[currentCount/<span class="number">3</span> * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">third1End</span> <span class="operator">=</span> former1[currentCount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A.length-<span class="number">1</span> - third1End &gt; third1Begin - second1End - <span class="number">1</span> || A.length-<span class="number">1</span> - third1End &gt; second1Begin - first1End - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= third1End-third1Begin; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[third1End-i] != A[second1End-i] || A[third1End-i] != A[first1End-i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = first1End + A.length - <span class="number">1</span> - third1End;</span><br><span class="line">        res[<span class="number">1</span>] = second1End + A.length - third1End;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>问题转换</tag>
        <tag>我怎么想不到</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 10. Regular Expression Matching</title>
    <url>/2020/10/28/leetcode10/</url>
    <content><![CDATA[<p>给定一个含<code>*</code>和<code>.</code>的模式串，判断该模式串是否能匹配其他的字符串。</p>
<p>其中，<code>*</code>表示其前边的字符可以重复0或多次，<code>.</code>匹配任意单个字符</p>
<span id="more"></span>

<p>这一题和<a href="https://leetcode-cn.com/problems/wildcard-matching/">LeetCode 44. Wildcard Matching</a>的差异在于44题中<code>*</code>可以匹配任意字符串，而本题中<code>*</code>只能匹配其前一个字符。</p>
<p>44题可参考<a href="https://wangz1x.github.io/2019/03/27/Wildcard-Matching">https://wangz1x.github.io/2019/03/27/Wildcard-Matching</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>dp的话，dp[i][j]就表示p串的前i个能不能和s串的前j个匹配，用p[i-1]表示遍历到的p串的字符，s[j-1]表示遍历到的s串的字符，有如下几种情况：</p>
<ol>
<li><code>p[i-1] != *</code><ul>
<li><code>s[j-1] match p[i-1]</code>，此时能否匹配就看前边的i-1和j-1能否匹配了，即dp[i][j] &#x3D; dp[i-1][j-1]</li>
<li><code>s[j-1] not match p[i-1]</code>, 此时必然不能匹配了</li>
</ul>
</li>
<li><code>p[i-1] == *</code> <ul>
<li><code>s[j-1] match p[i-2]</code>, 此时说明s[j-1]可以被<code>*</code>包括，那么具体要不要包括又分两种情况，但是目的是一样的，只要能匹配就行，因此dp[i][j] &#x3D; dp[i-2][j] || dp[i][j-1]</li>
<li><code>s[j-1] not match p[i-2]</code>, 此时说明s[j-1]没法被<code>*</code>匹配了，<code>*</code>只好匹配前边字符0次，看看还有没有机会继续匹配, 即dp[i][j] &#x3D; dp[i-2][j]</li>
</ul>
</li>
</ol>
<p><img src="/fig1.png" alt="fig1"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[p.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span> pc;</span><br><span class="line">        <span class="type">char</span> sc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; p.length()+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            pc = p.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; s.length() + <span class="number">1</span>; j ++) &#123;</span><br><span class="line">                sc = s.charAt(j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pc == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sc == p.charAt(i-<span class="number">2</span>) || p.charAt(i-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">2</span>][j];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">2</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="string">&#x27;.&#x27;</span> || pc == sc) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">        <span class="keyword">return</span> dp[p.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 32. Longest Valid Parentheses</title>
    <url>/2020/10/31/leetcode32/</url>
    <content><![CDATA[<p>在只包含<code>(</code>and<code>)</code>的字符串中找最长有效括号串的长度</p>
<span id="more"></span>

<h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><p>dp[i]表示从头到第i位的有效括号长度，注意这里要包含从0到i的每一位，那么也就是说，当第i位是<code>(</code>时，其有效长度总是0，因为没有和第i个<code>(</code>相匹配的。剩下的就是第i位为<code>)</code>时的判断，此时其有效长度可分为两部分计算：</p>
<h4 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h4><p>第一部分为包含当前第i个<code>)</code>的片段的有效长度，此时就要找到和这个<code>)</code>匹配的位置是否是<code>(</code>，那么如何找到和这个右括号相匹配的位置呢？</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>通过观察上图，可以发现其对应位置坐标为 i-dp[i-1]-1，其中dp[i-1]表示第i个<code>)</code>前边的有效长度，那么其对应位置和i之间就隔了这么远，因此能得到上述对应的坐标，此时可以判断这个地方是不是<code>(</code>，是的话，<code>dp[i]=dp[i-1]+2</code>，这就是第一部分</p>
<h4 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h4><p>第二部分就是，抛去包含i的这一段的有效长度，看剩下的位置的有效长度能否和这一段接上，那么如何找到剩下的这一部分呢，很简单，因为之前dp[i]定义的就是正好到i这一位置的有效长度，那么前一段的末尾的坐标就是<code>i-dp[i-1]-2</code>, 比如下图：</p>
<p><img src="/fig2.png" alt="fig2"></p>
<p>然后<code>dp[i] += dp[i-dp[i-1]-2]</code>就行了</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到对应位置，part1</span></span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 再试着接头，part2</span></span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈的方式比较巧妙，栈不是用来存储元素的，而是用来存储元素的坐标的。</p>
<p>如果是<code>(</code>，无脑入栈其坐标；如果是<code>)</code>，先把栈顶出出来，有两种可能，如果栈不为空则出的是<code>(</code>，因为栈底保存了一个最新遇到的不会被匹配的<code>)</code>，此时的有效长度就为<code>i-栈顶元素的坐标</code>；如果栈为空，说明把那个不匹配的<code>)</code>给出了，则当前遇到的<code>)</code>就作为最新遇到的不会被匹配的<code>)</code>入栈。</p>
<p>确保栈底放的是最后一个不匹配的<code>)</code>的坐标，相当于<strong>重置</strong>的功能，利用上边dp的说法，就是该<code>)</code>的后部分不会和<code>)</code>的前部分<strong>接头了</strong></p>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                        stack.push(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        max = Math.max(i-stack.peek(), max);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数判断"><a href="#计数判断" class="headerlink" title="计数判断"></a>计数判断</h3><p>如果只是判断字符串是否为有效的括号对时，只用比较遇到的左括号的数量是否会一直大于等于右括号的数量，其长度就为有效的左括号或右括号的两倍。</p>
<p>从左到右遍历时，如果右括号的数量等于左括号的数量时，说明此时是有效片段，且长度为左括号数的两倍；如果右括号数大于左括号数，说明此时的右括号不会再匹配到了，进行<strong>重置</strong>，即将左右括号计数归0，和用栈时栈底的<code>)</code>类似。</p>
<p>但是这样遍历一遍是不够的，存在左括号一直大于右括号的情况，这样就没法到达计算有效长度的逻辑了，因此还要再从右往左遍历一遍。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用时: dp&lt;计数&lt;栈，空间: 计数&lt;dp，栈</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>我怎么想不到</tag>
        <tag>栈</tag>
        <tag>妙</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 316. Remove Duplicate Letters</title>
    <url>/2020/10/29/leetcode316/</url>
    <content><![CDATA[<p>删除字符串中的重复字母并使得保留下来的字符串是按字母表排序最小的。</p>
<span id="more"></span>

<p>如果当前栈顶的元素比待入栈的元素大，并且通过预处理知道后续还会遇到栈顶的元素，那么就先把栈顶的元素出栈，让小的先进去，反正后边还会遇到当前位于栈顶的较大的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Character&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!queue.contains(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &gt; s.charAt(i) &amp;&amp; count[queue.peekLast() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                queue.addLast(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Character c : queue) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用栈判断是否包含s串当前字符比用数组或其他方式记录来判断的慢，但是不用额外的空间。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp</title>
    <url>/2020/10/19/kmp/</url>
    <content><![CDATA[<p><code>KMP</code>是以三位发明者命名的，全称为<code>Knuth-Morris-Pratt</code>，是一种字符串查找算法，可在一个主文本字符串<code>S</code>内查找一个词<code>W</code>的出现位置。有很多关于该算法的介绍，将自己的理解进行记录。</p>
<span id="more"></span>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>采用最简单的字符串匹配时，当发现<code>W</code>当前位置和<code>S</code>当前位置不匹配时，则<code>W</code>前进一位，再从头和当前对应的<code>S</code>进行匹配，如下图1所示：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>传统的做法是：</p>
<p><img src="/fig2.png" alt="fig2"></p>
<p>发现开头就不匹配，然后<code>W</code>再前进一位…</p>
<p><code>KMP</code>算法就提出了一种方案，跳过这些无用匹配。在初始匹配到第五位的时候，说明前面四位都是匹配的，即<code>S[0]=W[0], S[1]=W[1]...</code>，原始方法在<code>W</code>移动时还要去比较<code>W[0]</code>与<code>S[1]</code>，其实可以通过提前比较<code>W[0]</code>与<code>W[1]</code>来实现。具体效果为，当发现第五位不匹配时，<code>W</code>可以直接移动两位，如下图3所示：</p>
<p><img src="/fig3.png" alt="fig3"></p>
<p>具体是如何实现的呢？</p>
<h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p><code>KMP</code>算法中有一个很重要的概念，即<code>next</code>数组，<code>next[i]</code>表示的是一个坐标，即<code>W[i]</code>和<code>W[next[i]]</code>相同，且<code>0-next[i]</code>这一段字符串也出现在<code>x-W[i]</code>中（通俗讲就是前缀和后缀要相同）。（理解与实现都是按照自己方式来的，可能和其他更专业的讲解有所不同，而且实现也没有别人的优雅，但是我感觉这样好理解一点点）</p>
<p>下面针对<code>ababa</code>计算其<code>next</code>数组：</p>
<p><code>next[0]</code>直接初始化为<code>-1</code></p>
<p><code>next[1]</code>看字符串<code>ab</code>，由于<code>next[0]=-1</code>，则只用比较最后的字符<code>b</code>和开头的字符<code>a</code>，由于他们不同，则<code>next[1]=-1</code></p>
<p><code>next[2]</code>看字符串<code>aba</code>，同样只用比较开头和结束字符，即后缀<code>a</code>和前缀<code>a</code>相同，则<code>next[1]=0</code>（指向相同点的坐标）</p>
<p><code>next[3]</code>看字符串<code>abab</code>，由于<code>next[2]=0</code>，这里就直接比较<code>W[3]</code>和<code>W[0+1]</code>，因为是要取相同的最长前后缀，当<code>W[3]==W[0+1]</code>时，就表明了<code>W[01]==W[23]</code>，否则的话就再比较<code>W[3]</code>和<code>W[0]</code>。而这里判断是相同的，则<code>next[3]=1</code>，指向当前匹配的前边的<code>b</code>的坐标</p>
<p><code>next[4]</code>看字符串<code>ababa</code>，由于<code>next[3]=1!=-1</code>，同上，先直接比较<code>W[4]</code>和<code>W[1+1]</code>，发现相等，此时就说明了前缀<code>aba</code>等于后缀<code>aba</code>，<code>next[4]=2</code></p>
<p>综上，<code>next=[-1, -1, 0, 1, 2]</code></p>
<p>其中<code>-1</code>表示当前字符字串不存在任何前缀和后缀相等的情况。</p>
<h3 id="使用next"><a href="#使用next" class="headerlink" title="使用next"></a>使用next</h3><p>有了<code>next</code>，下一步就是要利用它来实现高效匹配，以上边的例子进行说明，为什么当<code>S[4]!=W[4]</code>时，<code>W</code>能前进两格。</p>
<p>当<code>S[4]!=W[4]</code>时，说明前四个字符是匹配的，不然也不会匹配到这来，那么就看前四个字符<code>abab</code>最长匹配前缀和后缀了，将相同的前缀补在相同的后缀上，再接着往后匹配，画图表示为：</p>
<p><img src="/fig4.png" alt="fig4"></p>
<p>其中粉色部分表示<code>W</code>当前判断字符前的字串的最长的前缀和后缀，当当前字符不相符时，直接把前缀挪到后缀去：</p>
<p><img src="/fig5.png" alt="fig5"></p>
<p>至于为什么中间的全能跳过去，其原理就是通过<code>W</code>子串的前缀和后缀之间的关系，来反应<code>W</code>和<code>S</code>串之间的关系，因为<code>W</code>串的特点保证了就算不跳这么远，只一个一个的移动，还是无法将<code>W</code>和<code>S</code>的当前位置进行匹配的。</p>
<p>根据这一般的情况，再看字符串<code>abab</code>，由<code>next[3]=1</code>可知<code>W[01]==W[23]</code>，因此直接把<code>ab</code>（前缀）移动到<code>ab</code>(后缀)的位置，再接着比较<code>W[2]</code>与<code>S[4]</code>即可（因为这时候已经保证了<code>W[2]</code>前边和<code>S</code>是一一对应的）。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kmp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;ababa&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ababcababaca&quot;</span>;</span><br><span class="line">        System.out.println(match(s, p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] calculateNext(String pattern) &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length()];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compareIndex</span> <span class="operator">=</span> next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (tempIndex &lt; pattern.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(tempIndex) == pattern.charAt(compareIndex + <span class="number">1</span>)) &#123;</span><br><span class="line">                next[tempIndex] = compareIndex + <span class="number">1</span>;</span><br><span class="line">                compareIndex = next[tempIndex];</span><br><span class="line">                tempIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareIndex != -<span class="number">1</span>) &#123;    <span class="comment">// 可能还有较短的前缀和后缀匹配</span></span><br><span class="line">                compareIndex = next[compareIndex];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[tempIndex] = -<span class="number">1</span>;</span><br><span class="line">                compareIndex = -<span class="number">1</span>;</span><br><span class="line">                tempIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(String source, String pattern)</span> &#123;</span><br><span class="line">        <span class="comment">// not decrease</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s_point</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// up and down</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p_point</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = calculateNext(pattern);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (s_point &lt; source.length() &amp;&amp; p_point &lt; next.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.charAt(s_point) == pattern.charAt(p_point)) &#123;</span><br><span class="line">                s_point++;</span><br><span class="line">                p_point++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_point == <span class="number">0</span>) &#123;  <span class="comment">// P[0]都不和S匹配，那S只好向前挪一格</span></span><br><span class="line">                s_point++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p_point = next[p_point - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p_point &gt;= next.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;match from: &quot;</span> + (s_point - next.length));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;not match!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2020-x2F-11-x2F-3-更新"><a href="#2020-x2F-11-x2F-3-更新" class="headerlink" title="2020&#x2F;11&#x2F;3 更新"></a>2020&#x2F;11&#x2F;3 更新</h1><p>以上述方法求出来next数组，再进行优化更新的时候就比较麻烦，先来看看为什么要优化</p>
<p><img src="/fig6.png" alt="fig6"></p>
<p>当a和c不匹配时，按照上边计算的next数组，pattern会移动到虚线框所示的位置，发现此时依然是a和c比，就浪费了一次比较的机会，更理想的情况是：</p>
<p><img src="/fig7.png" alt="fig7"></p>
<p>优化的主要思想是，当前待匹配位置发生失配时，如果跳到下一个位置和该字符依然相等的话，就需要更新当前待匹配位置的next值</p>
<p>为了能够方便的优化，计算next数组的方式需要改变一下，即让next值直接表示发生失配时，下一个应匹配的位置；而上文中计算下一个位置还需要看前边元素的next值+1，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] otherNext(String pattern) &#123;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length()];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">comparePointer</span> <span class="operator">=</span> <span class="number">0</span>;           <span class="comment">// 前缀的最后一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 直接指到这来</span></span><br><span class="line">        next[i] = comparePointer;</span><br><span class="line">        <span class="comment">// 调整位置</span></span><br><span class="line">        <span class="keyword">while</span> (comparePointer &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(i) != pattern.charAt(comparePointer)) &#123;</span><br><span class="line">            comparePointer = next[comparePointer];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(comparePointer) == pattern.charAt(i)) comparePointer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优化过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pattern.length(); i ++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> next[i];</span><br><span class="line">        <span class="keyword">while</span> (temp &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(i) == pattern.charAt(temp)) &#123;</span><br><span class="line">            temp = next[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">otherMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] next = otherNext(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">s_point</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p_point</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compareTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s_point &lt; s.length() &amp;&amp; p_point &lt; p.length()) &#123;</span><br><span class="line">        compareTime ++;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(s_point) == p.charAt(p_point)) &#123;</span><br><span class="line">            s_point++;</span><br><span class="line">            p_point++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[p_point] != -<span class="number">1</span>) &#123;</span><br><span class="line">            p_point = next[p_point];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p_point = <span class="number">0</span>;</span><br><span class="line">            s_point ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p_point == p.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s_point - p.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种方式计算出来的next如下：</p>
<p>针对字符串”ababa”</p>
<p>next: [-1, -1, 0, 1, 2]</p>
<p>otherNext: [-1, 0, 0, 1, 2]   优化后变为：[-1, 0, -1, 0, -1]</p>
<p>可以发现第二种方法计算出来的next数组就是第一种方法计算出的next数组各元素加1并右移一位，同时在0补上-1</p>
<p><img src="/fig8.png" alt="fig8"></p>
<p>对于上述的示例，优化前和优化后需要比较的次数分别为：13，11</p>
]]></content>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 139. Word Break || 140. Word Break II</title>
    <url>/2020/11/01/leetcode139140/</url>
    <content><![CDATA[<p>判断一个字符串能否由给定的多个词组合而成以及输出每种组合方式（词以空格分开），可重用单词</p>
<span id="more"></span>

<h3 id="139"><a href="#139" class="headerlink" title="139"></a>139</h3><p>开始想用dfs，结果过了36&#x2F;43个测试用例，后边就超时了，主要终止条件有点难搞，比如这个测试用例<code>&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaab&quot;, [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;, &quot;aaaaaa&quot;]</code>，当深入到最后一个<code>b</code>时，发现不匹配，就会再往前回溯，怎么才能让它在某一时刻明白“哦，我已经没机会了”直接返回false呢。</p>
<p>看了题解，用的dp，大致思想是，如下图</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>图中表示给定了四个词，判断长白条能否由这四个词组成，如果可以的，至少是这四种情况中的一种，即末尾由这四个词中的一个组成；如果前边一部分字符串也能由这四个词组成，那么就满足题目的要求了。因此dp[i]表示从0到i的字符串能否由这些词组成，那么就看去掉末尾的单词后（假设是从j到i部分为一个单词），dp[j-1]是否为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word: wordDict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - word.length()+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = word.equals(s.substring(i - word.length()+<span class="number">1</span>, i+<span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// string before i-word.length()+1</span></span><br><span class="line">                    <span class="keyword">if</span> (i - word.length() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i] = dp[i] &amp;&amp; dp[i-word.length()];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="140"><a href="#140" class="headerlink" title="140"></a>140</h3><p>在前一题的基础上，要求出所有满足的分词方法，dfs依然过不了，那就索性把0到i这一段字符串的所有分词方法都保存起来，后边需要用的话，直接往这些分词中在加上当前匹配的word，这一题需要用<code>LinkedList</code>；<code>ArrayList</code>每次扩容增加一半，最大值为<code>0x7fffffff-8</code>，也可以为<code>0x7fffffff</code>，在本题中可能会越到<code>0x80000000</code>从而引发<code>OutOfMemoryError()</code>。</p>
<p>但是即使是官方题解，我在本机上也没法跑出类似<code>aaa...aaa, [a, aa, aaa, aaaa, aaaaa, aaa...aaa]</code>这样的用例，其复杂度最差可到O(n*2^n)</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>什么时候才能看到字符串就想到dp呢</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>记忆化</tag>
        <tag>LinkedList</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode213Week</title>
    <url>/2020/11/01/leetcode213week/</url>
    <content><![CDATA[<p>leetcode第213场周赛，四个题目：</p>
<ul>
<li><a href="#能否连接形成数组">能否连接形成数组</a></li>
<li><a href="#统计字典序元音字符串的数目">统计字典序元音字符串的数目</a></li>
<li>可以到达的最远建筑</li>
<li>第K条最小指令</li>
</ul>
<span id="more"></span>

<h3 id="能否连接形成数组"><a href="#能否连接形成数组" class="headerlink" title="能否连接形成数组"></a>能否连接形成数组</h3><p><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">https://leetcode-cn.com/problems/check-array-formation-through-concatenation/</a></p>
<p>先给定一个数组target和一个数组片段pieces（即包含很多个数组），这两个玩意中的元素都不带重复的，问能否由pieces，在不改变其各个数组中元素位置情况下（当然数组与数组的位置可以改变），组合成target</p>
<p>由于不存在重复元素，那直接遍历target数组，看pieces中有没有某个片段开头的元素与之等于，相等的话就遍历该片段看该片段是否能完全匹配target这一部分，可以的话就继续，不然就直接gg了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFormArray</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[][] pieces)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[pieces.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; ) &#123;</span><br><span class="line">            <span class="comment">// find arr[i]</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pieces.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (pieces[j][<span class="number">0</span>] == arr[i]) &#123;</span><br><span class="line">                    <span class="comment">// visit all ele in pieces[j]</span></span><br><span class="line">                    visited[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; pieces[j].length; ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pieces[j][k] == arr[i]) &#123;</span><br><span class="line">                            k++;</span><br><span class="line">                            i++;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// match, and jump to next part</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// a loop and no found any piece match arr[i]</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= pieces.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计字典序元音字符串的数目"><a href="#统计字典序元音字符串的数目" class="headerlink" title="统计字典序元音字符串的数目"></a>统计字典序元音字符串的数目</h3><p><a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">https://leetcode-cn.com/problems/count-sorted-vowel-strings/</a></p>
<p>假设长度为n时，若a打头，则a后边可以跟所有长度为n-1的串；若e打头，则e后边可以跟所有不以a打头的长度为n-1的串，规律入下图所示：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] count = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            count[<span class="number">0</span>] = count[<span class="number">0</span>] + count[<span class="number">1</span>] + count[<span class="number">2</span>] + count[<span class="number">3</span>] + count[<span class="number">4</span>];</span><br><span class="line">            count[<span class="number">1</span>] = count[<span class="number">1</span>] + count[<span class="number">2</span>] + count[<span class="number">3</span>] + count[<span class="number">4</span>];</span><br><span class="line">            count[<span class="number">2</span>] = count[<span class="number">2</span>] + count[<span class="number">3</span>] + count[<span class="number">4</span>];</span><br><span class="line">            count[<span class="number">3</span>] = count[<span class="number">3</span>] + count[<span class="number">4</span>];</span><br><span class="line">            count[<span class="number">4</span>] = count[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>] + count[<span class="number">1</span>] + count[<span class="number">2</span>] + count[<span class="number">3</span>] + count[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可以到达的最远建筑"><a href="#可以到达的最远建筑" class="headerlink" title="可以到达的最远建筑"></a>可以到达的最远建筑</h3><p><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">https://leetcode-cn.com/problems/furthest-building-you-can-reach/</a></p>
<p>开始试着用dfs，即每当有个槛儿时，分别用砖头和梯子，看谁到的远就用谁，果然超时了。</p>
<p>后来又想，只要把梯子放在遇到的比较高的地方，其他的用砖头就好了，因此就用优先队列把遇到的槛儿都记录下来，优先队列里边的就用梯子，当梯子用完了，就从队列里边找个最矮的槛换成砖头，如果砖头不够用了，那就不能再前进了（因为此时梯子和砖头都不够哇）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">furthestBuilding</span><span class="params">(<span class="type">int</span>[] heights, <span class="type">int</span> bricks, <span class="type">int</span> ladders)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ladders &gt;= heights.length - <span class="number">1</span>) <span class="keyword">return</span> heights.length - <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] - heights[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// use ladders</span></span><br><span class="line">                deque.add(heights[i] - heights[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// not enough ladders</span></span><br><span class="line">                <span class="keyword">if</span> (deque.size() &gt; ladders) &#123;</span><br><span class="line">                    <span class="comment">// replace shortest</span></span><br><span class="line">                    <span class="keyword">if</span> (bricks &gt;= deque.peek()) bricks -= deque.poll();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的思路，按照大佬们的逻辑简化了代码，发现时间和内存都多了一点，不过这样看起来是真的简约，令人愉悦</p>
<h3 id="第K条最小指令"><a href="#第K条最小指令" class="headerlink" title="第K条最小指令"></a>第K条最小指令</h3><p><a href="https://leetcode-cn.com/problems/kth-smallest-instructions/">https://leetcode-cn.com/problems/kth-smallest-instructions/</a></p>
<p>记<code>choice[i, j]</code>为位于<code>(i, j)</code>时，到达目的地的线路个数，则<code>choice[i, j]=choice[i+1, j] + choice[i, j+1]</code>，那么可以先把最后一排和最后一列初始化为1，然后从右下角开始填满整个二维数组。</p>
<p>可以预见的，往右的优先级要高于往下的优先级（对于字典序来说），因此比较朝右的选择数和K，如果朝右的选择数大于k，就往右走；否则往下走，并且更新k，看它往下的选择中排老几。</p>
<p>其实就是排列组合<code>C_n^i</code>（假装latex）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">kthSmallestPath</span><span class="params">(<span class="type">int</span>[] destination, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(destination[<span class="number">0</span>] + destination[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] choose = <span class="keyword">new</span> <span class="title class_">int</span>[destination[<span class="number">0</span>] + <span class="number">1</span>][destination[<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; destination[<span class="number">1</span>] + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            choose[destination[<span class="number">0</span>]][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; destination[<span class="number">0</span>] + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            choose[i][destination[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> destination[<span class="number">0</span>] - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> destination[<span class="number">1</span>] - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                choose[i][j] = choose[i + <span class="number">1</span>][j] + choose[i][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (choose[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (choose[i][j+<span class="number">1</span>] &gt;= k) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;V&quot;</span>);</span><br><span class="line">                k -= choose[i][j+<span class="number">1</span>];</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; destination[<span class="number">0</span>]) sb.append(<span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (j++ &lt; destination[<span class="number">1</span>]) sb.append(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>再困难的题，总有大佬用我想象不到代码量完成。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>优先队列</tag>
        <tag>排列组合</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中的进程</title>
    <url>/2020/11/01/os-process/</url>
    <content><![CDATA[<p>进程不只是运行的程序（text section&#x2F;code section），还包括</p>
<ul>
<li>当前活动如程序计数器（program counter）的值和处理器寄存器的内容</li>
<li>进程堆栈（stack），存储临时数据，如函数参数，返回地址和局部变量</li>
<li>数据段（data section），包括全局变量</li>
<li>堆（heap），进程在运行时动态分配的内存</li>
</ul>
<span id="more"></span>

<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p><img src="/fig1.png" alt="fig1"></p>
<p>操作系统内的每个进程用PCB（task control block）表示，包含许多与进程相关的信息</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>切换CPU到另一个进程，需要保存当前进程状态，并恢复另一个进程的状态，这称为上下文切换。</p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>Linux中进程<code>init</code>为所有用户进程的父进程</p>
<p>通过系统调用<code>fork()</code>可以创建新进程，新进程中（子进程）该函数返回0，原进程中（父进程）该函数返回新进程的pid</p>
<p>若在新进程中调用<code>exec()</code>, 则其不会在执行原程序中的后续代码</p>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>如果一个进程终止，那么它的所有子进程也会终止，称为<code>级联终止</code></p>
<p>当进程已经终止，但是其父进程尚未调用wait(), 则称该进程为<code>僵尸进程</code></p>
<p>如果父进程没有调用wait()就终止了，则其子进程就会变为<code>孤儿进程</code></p>
<p>孤儿进程会称为init进程的子进程，而init会周期性的调用wait()，来释放孤儿进程的pid和进程表条目</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol>
<li>共享内存</li>
</ol>
<p><code>POSIX</code>共享内存的实现为内存映射文件，它将共享内存区域与文件相关联。通过如下方式创建共享内存对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shm_fd = shm_open(name, O_CREAT | O_RDRW, 0666);</span><br></pre></td></tr></table></figure>

<p>共享内存可能快于消息传递，因为消息传递需要频繁？的系统调用，因此需要消耗更多时间（涉及内核，切换）</p>
<ol start="2">
<li>消息队列</li>
</ol>
<p>对于多核系统，消息传递的性能要优于共享内存，因为共享内存会有缓存一致性问题。</p>
<ol start="3">
<li>套接字（socket）</li>
</ol>
<p>套接字是由一个IP地址和一个端口号组成的，即类似于<code>146.85.5.20:1625</code>。</p>
<p>套接字属于分布式进程之间的一种低级通信形式，主要原因是套接字只允许在通信线程之间交换无结构的字节流，可能需要额外自定义传输数据的数据结构</p>
<ol start="4">
<li>远程过程调用（remote procedure call）</li>
</ol>
<p>RPC通信交换的信息具有明确的结构。</p>
<p>客户端需要获取服务端执行RPC的端口，因此服务器端有个类似于DNS的服务程序matchmaker由于提供和RPC名称对应的端口号</p>
<ol start="5">
<li>管道</li>
</ol>
<p>管道是一种特殊类型的文件，可由子进程继承</p>
<p>管道用于同一台机器上的进程通信</p>
<ul>
<li><p>匿名管道</p>
<ul>
<li>匿名管道是单向的</li>
<li>进程通信需要有父子关系</li>
<li>创建采用<code>pipe(int fd[])</code></li>
<li><code>fd[0]</code>为读出端，<code>fd[1]</code>为写入端</li>
<li>一旦通信完成并终止，匿名管道就不存在了</li>
</ul>
</li>
<li><p>命名管道</p>
<ul>
<li>半双工（允许双向，但同一时间只能单向）</li>
<li>不需要父子关系</li>
<li>一旦创建，表现为文件系统的典型文件</li>
<li>命名管道为FIFO，通过调用<code>mkfifo()</code></li>
<li>通信进程完成后，命名管道依然存在，直到它被显示的从文件系统中删除</li>
<li>只允许字节流的数据</li>
</ul>
</li>
</ul>
<ol start="6">
<li>信号（signal）</li>
</ol>
<ul>
<li>信号是由特定事件的发生而产生的</li>
<li>信号被传递给某个进程</li>
<li>信号一旦收到就应处理</li>
</ul>
<p>信号可分为同步信号和异步信号，同步信号是指信号会发送到产生该信号的进程；异步信号则可发送到另一进程。</p>
<p>每个信号都有一个默认信号处理程序（default signal handler），用户也可定义信号处理程序</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
        <tag>进程</tag>
        <tag>process</tag>
        <tag>理论</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 29. 两数相除</title>
    <url>/2020/11/03/leetcode29/</url>
    <content><![CDATA[<p>不用乘&#x2F;除&#x2F;求余三个操作，计算两数整除的结果</p>
<span id="more"></span>

<p>溢出的情况大概就一种吧，被除数为0x80000000, 除数为-1，此时会溢出，按照题目要求返回0x7fffffff即可，可以把这种情况单独拿出来判断。</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>两数一直相加或相减（根据符号判断），直到结果大于0或小于0停止，进行的操作数就是最终的商了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span> (divisor == -<span class="number">1</span>) <span class="type">return</span> <span class="variable">dividend</span> <span class="operator">=</span>= <span class="number">0x80000000</span> ? <span class="number">0x7fffffff</span> : -dividend;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dividend &gt;= divisor) &#123;</span><br><span class="line">                dividend -= divisor;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">                dividend -= divisor;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (dividend + divisor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dividend += divisor;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = -res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dividend + divisor &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dividend += divisor;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = -res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常慢</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>除数二倍二倍的增加，如果被除数依然大于增大后的除数，则商也翻倍；当被除数小于增大后的除数时，说明剩下的被除数小于除数的一半了，此时就在拿剩下的被除数和原始除数继续做这种操作，如下图所示：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span> (divisor == -<span class="number">1</span>) <span class="type">return</span> <span class="variable">dividend</span> <span class="operator">=</span>= <span class="number">0x80000000</span> ? <span class="number">0x7fffffff</span> : -dividend;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留结果的符号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>)) sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的符号已经没用了，但毕竟两个数同符号比较好操作一点，</span></span><br><span class="line">        <span class="comment">// 为什么选择负数呢，因为被除数和除数都可能等于0x80000000，</span></span><br><span class="line">        <span class="comment">// 换成正数的话就直接溢出了，所以负数比较好</span></span><br><span class="line">        dividend = dividend &lt; <span class="number">0</span> ? dividend : -dividend;</span><br><span class="line">        divisor = divisor &lt; <span class="number">0</span> ? divisor : -divisor;</span><br><span class="line"></span><br><span class="line">        <span class="type">return</span> <span class="variable">sign</span> <span class="operator">=</span>= -<span class="number">1</span> ? -dfs(dividend, divisor) : dfs(dividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempDivisor</span> <span class="operator">=</span> divisor;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 注意除数翻倍的时候也可能会溢出，所以这一提前判断不然一般超过这个阈值</span></span><br><span class="line">            <span class="comment">// 如果超过了这个阈值，就没必要再循环了，因为被除数不可能小于0x80000000</span></span><br><span class="line">            <span class="keyword">while</span> (tempDivisor &gt;= <span class="number">0xc0000000</span> &amp;&amp; dividend &lt;= tempDivisor+tempDivisor) &#123;</span><br><span class="line">                tempDivisor = tempDivisor+tempDivisor;</span><br><span class="line">                count += count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有除尽的话，就用剩余的部分（被除数）和原始除数继续做上述操作</span></span><br><span class="line">            <span class="keyword">if</span> (tempDivisor != dividend) &#123;</span><br><span class="line">                count += dfs(dividend-tempDivisor, divisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样快乐多了</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>类似的还有最小公倍数和Fibonacci数列求解，都可采用移位+二分法法，只不过移位也算作乘除，这一题没用，</p>
<p>比如最小公倍数：</p>
<ul>
<li>两数都为偶数时，右移一位（表示除以2），最终结果（公倍数）乘以2</li>
<li>一奇一偶时，偶数右移一位，最终结果不动（比如3和6，6右移一位变为3，再继续操作）</li>
<li>两奇时，相减（辗转相减法）</li>
<li>当小的为0时，大的就是中间结果了</li>
</ul>
<p>而Fibonacci数列，根据资料显示，二阶递推式可以化为矩阵相乘，这样一来，求Fn就变成求矩阵的n次方了，再把n转化为二进制，最多遍历32次，即看每一位是不是1，是1就乘到结果里边，是0就跳过。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>两数相除</tag>
        <tag>二分法</tag>
        <tag>gcd</tag>
        <tag>斐波那契</tag>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 33. 搜索旋转排序数组</title>
    <url>/2020/11/03/leetcode33/</url>
    <content><![CDATA[<p>首先有一个递增的数组，它会在某一位进行旋转，就是把后边的放到前边去，然后需要查找一个元素</p>
<span id="more"></span>

<p>首先确定是二分，但是和普通的二分不一样，会存在两种情况（mid为断层的情况也包含了）：</p>
<p><img src="/fig1.png" alt="fig1"></p>
<p>这两种情况可以按照nums[mid]和nums[start]（nums[end]也可以）的大小来判断</p>
<ul>
<li>nums[mid] &gt; nums[start], 则是左边情况</li>
<li>否则就是右边情况</li>
</ul>
<p>先确定好这两种大的情况后，在继续分左右讨论，这里以第一种情况为例：</p>
<ol>
<li>如果是下图这样，就把end挪到mid那；</li>
</ol>
<p><img src="/fig2.png" alt="fig2"></p>
<ol start="2">
<li>如果不是上图那样，就把start挪到mid那。</li>
</ol>
<p>第二种情况类似，不再赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target &amp;&amp; nums[nums.length-<span class="number">1</span>] &lt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (begin+end)/2: four </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[end]) &#123;</span><br><span class="line">                <span class="comment">// target在左边</span></span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] || target &gt; nums[end]) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="comment">// target在右边</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] || target &lt; nums[start]) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>开始想的时候，情况分的太细了，想着直接用if… else if… else if… else if…直接把脑袋想炸了，可以的话还是先大情况，再分小情况，Orz</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>linux修改密码</title>
    <url>/2020/11/19/modify-password/</url>
    <content><![CDATA[<p>修改<code>linux</code>中<code>root</code>的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd</span><br></pre></td></tr></table></figure>

<p>不管之前有没有设置过密码，都直接输入新密码，然后确认一遍即可。</p>
<p>修改<code>linux</code>中普通用户的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>

<p>需要输入原密码，在该新密码然后确认；</p>
<p>或者先切换到<code>root</code>，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>

<p>直接修改用户的密码</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 327. 区间和的个数</title>
    <url>/2020/11/09/leetcode327/</url>
    <content><![CDATA[<p>归并的要点在于：</p>
<ol>
<li>理解为啥排序后不会对满足条件的数值个数不会产生影响，其他排序能用嘛</li>
<li>在两个排序的数组中找到特定区间的值，的方法</li>
</ol>
<p>线段树的要点在于：</p>
<ol>
<li>知道线段树是什么，比如我之前没听过，为了看懂这个方法，索性就照着代码把整个过程画出来</li>
<li>问题转换后就不要在对原问题中某个点在新问题中的含义做过深的探究，就好比递归一样，既然已经转化问题了，就专心处理新问题就好（特指对于preSum[0]的考虑）</li>
</ol>
<span id="more"></span>

<p>如果后续真的入了pad+pencil，就可以方便的画图+欣赏了</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>归并排序</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>password free using sudo</title>
    <url>/2020/11/19/password-free-using-sudo/</url>
    <content><![CDATA[<p>可能有两种方式，但都是修改一个文件：<code>/etc/sudoers</code></p>
<p>查看这个文件，要求必须使用<code>visudo</code>命令修改!!!</p>
<h3 id="修改方式一"><a href="#修改方式一" class="headerlink" title="修改方式一"></a>修改方式一</h3><ol>
<li><p>将当前想体验免密码的用户加到<code>sudo</code>用户组里，可以直接编辑<code>/etc/group</code>文件，或者使用<code>usermod -G sudo current_user</code></p>
</li>
<li><p>命令<code>sudo visudo</code>，将<code>%sudo  ALL=(ALL:ALL) ALL</code> -&gt; <code>%sudo  ALL=(ALL:ALL) NOPASSWD:ALL</code></p>
</li>
</ol>
<h3 id="修改方式二"><a href="#修改方式二" class="headerlink" title="修改方式二"></a>修改方式二</h3><p>命令<code>sudo visudo</code>，将在<code>%sudo  ALL=(ALL:ALL) ALL</code>行下补充 -&gt; <code>username  ALL=(ALL) NOPASSWD:ALL</code></p>
<p>但是生效好像要重启，暂时先这样</p>
<h3 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h3><p><code>%sudo  ALL=(ALL:ALL) ALL</code></p>
<p>对应表示：授权用户组（加%）&#x2F;用户   在哪个主机登录可进行授权&#x3D;（切换到哪些用户：切换到哪些组）[是否需要密码]  可授权执行的命令</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-in-docker</title>
    <url>/2020/11/20/mysql-in-docker/</url>
    <content><![CDATA[<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>在docker中启动一个mysql容器，在容器外部进行连接的时候，指定ip可以为<code>127.0.0.1</code>，也可以为本机（运行docker的机器）的ip，还可以为docker为该容器分配的ip（docker inspect container_name），啊</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>这个问题我自己没有遇到，在查看ip相关的blog时，发现有人提到这一点，就是用5.7的mysql client去连接8.0的mysql server会由于两个版本验证方式不同而无法连接，需要修改mysql server中的认证方式：</p>
<p>这样查看plugin（不晓得怎么翻译）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,plugin <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure>

<p>8.0的应该是<code>caching_sha2_password</code>，需要修改5.7用的<code>mysql_native_password</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;your_password&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>一般blog都说要加上后边的密码，但是我这不加密码也行？</p>
<p>太多问题了</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>docker</tag>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title>github connection timed out</title>
    <url>/2020/11/23/github-connection-timed-out/</url>
    <content><![CDATA[<p>修改协议很麻烦，无法保证修改后可以使用，那就直接在<code>.ssh</code>下新建config文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>

<p>但是就算这样改了，也不能保证一定可行，那就过一段时间在push</p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>区间相关问题</title>
    <url>/2020/12/31/intervals-question/</url>
    <content><![CDATA[<p>区间问题的总集：</p>
<ol>
<li>区间重合判断  -《编程之美2.19》</li>
<li>安排会议 -</li>
<li>无重叠区间</li>
<li>最少重合区间</li>
<li>打气球</li>
</ol>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>intervals</tag>
        <tag>区间问题</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉回环与哈密尔顿图</title>
    <url>/2021/03/05/Euler-circuit-and-Hamiltonian-graph/</url>
    <content><![CDATA[<p>欧拉回环：一笔画问题，每条边只能走一次，能否遍历所有的边。</p>
<ul>
<li>第一种递归：后序遍历，为了保证能把中间节点的环放到整个大环里边</li>
<li>第二种递归：先序遍历，但是需要优先访问大的边，这样可以把所有的边都访问完了才回去</li>
</ul>
<p>哈密尔顿图：每个节点只能访问一次，能否遍历所有的点。比上边的苛刻很多，一个点只能遍历一次，那么该点所有的边只有一条会被遍历，其他都无法访问了（不然就重复访问了该点）</p>
]]></content>
      <tags>
        <tag>欧拉回环</tag>
        <tag>Eulerian path</tag>
      </tags>
  </entry>
  <entry>
    <title>Create container in docker</title>
    <url>/2021/03/06/create-container-in-docker/</url>
    <content><![CDATA[<h2 id="ftp服务，但是只能宿主机访问，我其他机子用的chrome无法访问"><a href="#ftp服务，但是只能宿主机访问，我其他机子用的chrome无法访问" class="headerlink" title="ftp服务，但是只能宿主机访问，我其他机子用的chrome无法访问"></a>ftp服务，但是只能宿主机访问，我其他机子用的chrome无法访问</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 20:20 -p 21:21 -p 21000-21200 \</span><br><span class="line">-v /home/docker/ftp:/home/vsftpd \</span><br><span class="line">-e FTP_USER=ftp1103 -e FTP_PASS=1103ftp \</span><br><span class="line">-e PASV_ADDRESS=XXX.XXX.XXX.XXX \</span><br><span class="line">-e PASV_MIN_PORT=21000 \</span><br><span class="line">-e PASV_MAX_PORT=21200 \</span><br><span class="line">--name ftp-1 \</span><br><span class="line">fauria/vsftpd:latest</span><br></pre></td></tr></table></figure>

<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>容器中的 WorkingDir为 <code>/usr/local/tomcat</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8081:8080 \</span><br><span class="line">-v /home/docker/tomcat:/var/tomcat \</span><br><span class="line">--name tomcat-1 \</span><br><span class="line">tomcat:8.5.64-jdk8-adoptopenjdk-hotspot</span><br></pre></td></tr></table></figure>

<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">-v /home/docker/redis/:/var/redis \</span><br><span class="line">--name redis-1 \</span><br><span class="line">redis:latest</span><br></pre></td></tr></table></figure>

<p>指定配置文件时，后边加上 <code>redis-server /xxx/redis.conf</code>，要注意容器内redis的版本和指定的配置文件的版本，不对应的话可能会报错，<code>line XXX, bad directive or wrong number of arguments</code></p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v /home/docker/mysql/:/var/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=XXXX \</span><br><span class="line">--name mysql-1 \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zookeeper-2 --restart always -d -e &quot;ZOO_MY_ID=2&quot; -e ZOO_SERVERS=&quot;server.1=172.17.0.4:2888:3888;2181 server.2=172.17.0.5:2888:3888;2181 server.3=172.17.0.6:2888:3888;2181&quot; zookeeper</span><br></pre></td></tr></table></figure>

<p>某些容器中的配置项可以通过 <code>-e</code> 来改写，如果修改的配置不多的话，这样比较方便，避免了创建文件进行映射等操作。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>由于电脑经常死机, 重启后<code>docker</code>中的容器也可能会重启<code>(--restart always)</code>, 此时各个容器启动顺序不确定, 则其按顺序分配到的<code>ip</code>也可能会和之前不同.</p>
<p>那我配置的<code>zookeeper</code>假集群就没法用了(因为创建这些<code>zookeeper</code>实例时需要指定各台机器的<code>ip</code>). </p>
<p>查了一下，发现可以为容器指定固定的ip, 下面记录下步骤:</p>
<ol>
<li>创建自己的<code>docker</code>网络</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create --subnet=172.18.0.0/16 mybridge</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若使用默认的bridge，则会出现:</span></span><br><span class="line">docker: Error response from daemon: user specified IP address is supported on user defined networks only.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建新的容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart always --net mybridge --ip 172.18.0.2 \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">-v /home/docker/redis/:/var/redis \</span><br><span class="line">--name redis-1 \</span><br><span class="line">redis:latest</span><br><span class="line">ba55ec0fad37ccf9ed42c47871e0d79b7e6fb12a10fa08786e660caa809d1b75</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk Dynamic Proxy</title>
    <url>/2021/04/09/jdk-Dynamic-Proxy/</url>
    <content><![CDATA[<h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>使用jdk提供的动态代理技术，主要包含以下几个步骤：</p>
<ol>
<li>创建服务接口</li>
<li>实现服务接口，称为服务类，作为被代理类</li>
<li>实现<code>InvocationHandler</code>接口，可以通过构造函数的形式，将被代理类传进去<ul>
<li>该接口主要需要实现<code>invoke(Object proxy, Method method, Object[] args)</code>方法，其中<code>proxy</code>为生成的代理对象，<code>method</code>为代理对象调用的方法(在使用时)，<code>args</code>为方法参数</li>
<li>在实现该方法时，可以通过传进来的被代理类对象，调用被代理类的原生方法，在前后可以做增强操作</li>
</ul>
</li>
<li>调用<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>方法<ul>
<li><code>loader</code> 指定生产代理类时的类加载器</li>
<li><code>interfaces</code> 指定代理类实现的接口</li>
<li><code>h</code> 上边自定义的<code>InvocationHandler</code>实现类</li>
</ul>
</li>
</ol>
<p>这样就得到了一个代理类了，在调用代理类的方法时，实际上执行的是<code>InvocationHander</code>的<code>invoke</code>方法。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p><code>jdk</code>提供的动态代理只能代理，实现了接口的类；当代理一个没有实现接口的类的时候，得到的代理对象其实是没用的。</p>
<h2 id="从源码看代理过程"><a href="#从源码看代理过程" class="headerlink" title="从源码看代理过程"></a>从源码看代理过程</h2><ol>
<li><p>看<code>Proxy.newProxyInstance</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="comment">// 权限检查 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         * !!!!!!  查找或者生成代理类， 注意是 Class  !!!!!!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取生成代理类的，参数类型为 InvocationHandler 的构造方法</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 设置构造方法可访问</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过该构造方法创建一个代理对象</span></span><br><span class="line">        <span class="comment">// newProxyInstance方法中的InvocationHander参数,其实是该代理对象的一个参数</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中，最重要的就是<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code> 通过这个方法调用，就得到了代理对象类了，因此下一步看这个</p>
</li>
<li><p><code>getProxyClass0</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释得知，当该缓存中不存在时，会通过<code>ProxyClassFactory</code>创建代理类，而这个<code>ProxyClassFactory</code>类是<code>Proxy</code>类的静态内部类，直接去看这个类</p>
</li>
<li><p><code>ProxyClassFactory</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 对待实现接口的一系列验证</span></span><br><span class="line">            <span class="comment">// 确认类加载器解析该接口的到的名字一致</span></span><br><span class="line">            <span class="comment">// 确认该接口确实是接口对象</span></span><br><span class="line">            <span class="comment">// 确认接口没有重复的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">             * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">             * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">		    <span class="comment">// 确认所有的 非公有 接口，都在同一个包下，因为最终生成的代理对象会定义在</span></span><br><span class="line">             <span class="comment">// 和 非公有 接口相同的包下，如果有多个，就不晓得最后要放哪了 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 生成代理对象的名字，一般匿名内部类的名字也含有$</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// jdk1.8 中就是 com.sun.proxy.$Proxynum</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 生成具体的 代理类的 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">		   <span class="comment">// invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line">            <span class="comment">// class creation (such as virtual machine limitations exceeded).</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类实现了一个函数式接口(简单理解为只包含一个抽象方法，会加上注解<code>@FunctionalInterface</code>)，其<code>apply</code>方法，会在上一步缓存中没找到该代理对象时调用。该类中的<code>apply</code>方法中最重要的就是<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</code>这一句，看看</p>
</li>
<li><p><code>ProxyGenerator.generateProxyClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name,</span><br><span class="line">                                        Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                        <span class="type">int</span> accessFlags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ProxyGenerator</span> <span class="variable">gen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyGenerator</span>(name, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] classFile = gen.generateClassFile();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        <span class="comment">// 保存class文件</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> classFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下一步，通过<code>gen.generateClassFile()</code>方法就得到字节码文件了！！！！</p>
</li>
<li><p><code>generateClassFile</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] generateClassFile() &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为接口中的方法提供代理</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : intf.getMethods()) &#123;</span><br><span class="line">            addProxyMethod(m, intf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 提供构造方法</span></span><br><span class="line">        methods.add(generateConstructor());        </span><br><span class="line">   </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* ============================================================</span></span><br><span class="line"><span class="comment">     * Step 3: Write the final class file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 父类: &quot;java/lang/reflect/Proxy&quot;</span></span><br><span class="line">        dout.writeShort(cp.getClass(superclassName));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过该方法就可以知道，代理类是<code>Proxy</code>的子类!!!</p>
</li>
</ol>
<p>有上述可知，如果某个类没有实现接口，那么最终代理出来的类完全是和该类没有关系的，是个无用的代理类；但是如果实现了接口，那么代理类中就会有该接口的方法，在使用该代理类时，可以通过转化为相应的接口（多态）而代替原被代理类。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>java中四舍五入保留指定位数小数</title>
    <url>/2021/04/14/number-format/</url>
    <content><![CDATA[<p>在做一些笔试编程题的时候，偶尔需要输出指定位数的小数，目前用了两种简单方式：</p>
<ol>
<li>直接调用<code>System.out.printf(&quot;%.4f&quot;, number)</code>，四舍五入保留4位小数, 注意该方法</li>
<li>偶尔可能要把数据处理完了统一输出，那就先把结果保存，<code>double/float res = xx.xxxxxx</code>, 在输出的时候，调用<code>String.format(&quot;%.4f&quot;, res)</code></li>
</ol>
<p>上述两种形式，最终都是通过<code>Formatter().format()</code>方法实现的</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>number</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的String</title>
    <url>/2021/04/14/String-in-java/</url>
    <content><![CDATA[<h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str0</span> <span class="operator">=</span> <span class="string">&quot;str0&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>+<span class="string">&quot;str1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节码为：</span></span><br><span class="line"> <span class="number">0</span> ldc #<span class="number">2</span> &lt;str0&gt;</span><br><span class="line"> <span class="number">2</span> astore_1</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">3</span> &lt;str1str2&gt;</span><br><span class="line"> <span class="number">5</span> astore_2</span><br><span class="line"> <span class="number">6</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> ldc #<span class="number">5</span> &lt;newString&gt;</span><br><span class="line"><span class="number">12</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">15</span> astore_3</span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>带有引号的字符串在编译阶段，会放到<code>Class</code>文件的常量池中，在类加载的加载阶段，二进制字节流会按照虚拟机设定的格式存储在方法区中，而常量池就被放到运行时常量池中。</p>
<p><code>ldc</code>指令的含义为：将<code>int</code>, <code>float</code>, <code>String</code>类型的常量值从常量池中推送至栈顶，因此<code>str0</code>,<code>str1</code>都是直接指向了常量池中的字符串；而<code>str2</code>则是根据常量池中的<code>str2</code>作为参数构造一个新的字符串对象。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu开启启动项</title>
    <url>/2021/06/11/running-when-boot/</url>
    <content><![CDATA[<p><code>linux</code>开机启动有好几种方式，先记录用到过的：</p>
<h3 id="clash-service"><a href="#clash-service" class="headerlink" title="clash.service"></a>clash.service</h3><p>编写<code>myService.service</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/XXX/XXX/XXX -d /XXX/XXX</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>这个文件写好后，放到<code>/etc/systemd/system/</code>下，<code>systemctl start/enable myService</code>即可启动&#x2F;开机启动该服务了。</p>
<p>配置文件中的含义如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Description：运行软件描述</span><br><span class="line">Documentation：软件的文档</span><br><span class="line">After：因为软件的启动通常依赖于其他软件，这里是指定在哪个服务被启动之后再启动，设置优先级</span><br><span class="line">Wants：弱依赖于某个服务，目标服务的运行状态可以影响到本软件但不会决定本软件运行状态</span><br><span class="line">Requires：强依赖某个服务，目标服务的状态可以决定本软件运行。</span><br><span class="line">ExecStart：执行命令</span><br><span class="line">ExecStop：停止执行命令</span><br><span class="line">ExecReload：重启时的命令</span><br><span class="line">Type：软件运行方式，默认为simple</span><br><span class="line">WantedBy：这里相当于设置软件，选择运行在linux的哪个运行级别，只是在systemd中不在有运行级别概念，但是这里权当这么理解。  </span><br></pre></td></tr></table></figure>



<h3 id="rc-local"><a href="#rc-local" class="headerlink" title="rc.local"></a>rc.local</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>在该文件的<code>exit 0</code>之前加入自己想要启动时执行的命令</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字涉及到的四种形态</title>
    <url>/2021/06/25/biased-lock/</url>
    <content><![CDATA[<p><code>synchronized</code>关键字经过优化后，多了两种形态：<strong>偏向锁</strong>和<strong>轻量级锁</strong></p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>众所周知，锁的不同形态可以在一个对象的对象头中体现出来，具体的可以使用<code>jol</code>工具查看对象头信息，<code>maven</code>导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可. </p>
<p>如果想要查看某个对象的对象头，直接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ClassLayout.parseInstance(t).toPrintable());</span><br></pre></td></tr></table></figure>
<p>即可. </p>
<p>比如对于只包含一个<code>int</code>类型的属性的对象<code>t2</code>，其对象头显示如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">      0     4   (object header)       01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4   (object header)       00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4   (object header)       05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4   int Test.field        7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，本人所使用的<code>jdk1.8</code>默认是开启了<code>UseCompressedOops</code>和<code>UseCompressedClassPointers</code>两个虚拟机选项的，表示采用指针压缩，原本<code>64bit</code>的指针压缩到<code>32bit</code>了，因此，在关闭这两个选项后(关闭任意一个均可)，<code>t2</code>对象头显示如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">      0     4   (object header)       01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4   (object header)       00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4   (object header)       28 b2 0a 83 (00101000 10110010 00001010 10000011) (-2096451032)</span><br><span class="line">     12     4   (object header)       31 7f 00 00 (00110001 01111111 00000000 00000000) (32561)</span><br><span class="line">     16     4   int Test.field        7</span><br><span class="line">     20     4   (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>和上边对比，发现<code>Mark Word</code>的8个字节没变化，下边的类指针多了4个字节.</p>
<p>通过对比相关资料对于<code>Mark Word</code>组成部分的描述，可以推断出<code>jol</code>是按低位到高位顺序输出对象头的(?)，想要得到和相关资料那样的顺序，只用把<code>jol</code>输出的字节顺序逆序即可.</p>
<p>无锁状态锁的标志位是<code>01</code>, 偏向锁状态是<code>0</code>.</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当创建完对象，打印其对象头，发现不论怎么搞都得到的是初始无锁状态的对象，用<code>synchronized</code>加个锁就变<strong>轻量级锁</strong>了，怎么也去不到<strong>偏向锁</strong>的状态.</p>
<p>原来是因为虚拟机启动时，默认有个参数为<code>BiasedLockingStartupDelay=4000</code>，表示虚拟机启动<code>4s</code>之后才启用<strong>偏向锁</strong>. 这一步的目的为减少虚拟机启动时由于偏向锁的不当使用造成的影响.</p>
<p>那么可以把该参数设为0，或者等待个四五秒在创建对象，果然就是偏向状态了:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启了指针压缩</span></span><br><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION      VALUE</span><br><span class="line">      0     4   (object header)       05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4   (object header)       00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4   (object header)       05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4   int Test.field        7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到此时偏向状态为<code>1</code>, 而前边所有的bit都为0(包括线程ID, epoch, 分带年龄), 由于偏向ID为空，此时的状态也称作匿名偏向状态, 即后续可以直接偏向其他的线程. </p>
<p>需要注意的是, 由于<code>Mark Word</code>会随着锁的不同状态而重用这部分数据结构, <strong>轻量级锁</strong>与<strong>重量级锁</strong>状态下, 对象的<code>Mark Word</code>会被保存到持有该锁的线程栈帧中, 而<strong>无锁</strong>状态下切换到<strong>偏向锁</strong>状态时, 其原本的<code>Mark Word</code>并不会保存到其他位置, 因此当调用了对象的强一致性<code>hashcode()</code>方法(即未重写过对象的<code>hashcode()</code>方法)后, 对象就无法在到达<strong>偏向锁</strong>状态了, 实验如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION       VALUE</span><br><span class="line">      0     4   (object header)        05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4   (object header)        00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4   (object header)        05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4   int Test.field         7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里调用对象继承自Object类的hashcode()方法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了突出hashcode, 把高25bit未使用的位用<span class="string">&#x27;-&#x27;</span>表示</span></span><br><span class="line">hashcode: ee7d9f1</span><br><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION       VALUE</span><br><span class="line">      0     4   (object header)        01 f1 d9 e7 (00000001 11110001 11011001 11100111) (-405147391)</span><br><span class="line">      4     4   (object header)        0e 00 00 00 (-0001110 -------- -------- --------) (14)</span><br><span class="line">      8     4   (object header)        05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4   int Test.field         7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>从上边可以发现, 原本处于匿名偏向状态的对象, 调用过强一致性<code>hashcode()</code>方法后, 其偏向状态变为了<code>0</code>.</p>
<p>这里突出强调是<strong>强一致性hashcode</strong>的原因在于, 如果重写了<code>hashcode()</code>方法, 那么其计算结果不会保存到<code>Mark Word</code>中, 如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4    int Test.field                                7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重写hashcode方法</span></span><br><span class="line">hashcode: 7777777</span><br><span class="line">com.wzx.Test object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c1 00 20 (00000101 11000001 00000000 00100000) (536920325)</span><br><span class="line">     12     4    int Test.field                                7</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>结果很明显了, 调用重写后的<code>hashcode()</code>方法并没有像上边那样写入到<code>Mark Word</code>中, 因为自定义的<code>hashcode()</code>方法很有可能和对象的属性相关, 那么对象的属性一旦修改, 计算出来的<code>hashcode</code>也就不同了, 没必要放到<code>Mark Word</code>中.</p>
<p>除了上边的一些介绍, 最主要的还是要和其他锁状态联系起来, 探究其状态转换, 比如升级到轻量级锁, 批量重偏向, 批量撤销等.</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3>]]></content>
      <tags>
        <tag>java</tag>
        <tag>synchronized</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Knowledges in springboot</title>
    <url>/2021/08/06/knowledges-in-springboot/</url>
    <content><![CDATA[<p>记录<code>springboot</code>中的一些小知识点.</p>
<h3 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h3><p>当一个项目中同时存在多个配置文件, 比如<code>application.properties</code>, <code>application.yml</code>, <code>application.yaml</code>, 如果这些文件中有相同的配置项, 比如都配置了<code>server.port</code>，但是具体端口配置的不一样，那么最后应用启动时用到的是哪个配置文件中的信息呢?</p>
<p>配置文件的加载顺序为: <code>yaml---yml---properties</code>, 而后加载的配置会覆盖先加载的配置，因此最后用到的是<code>properties</code>中的端口</p>
<p>如果启动项目时有一些配置项，比如<code>java -jar demo-app.jar --server.port=7777</code>，应用启动后的端口就是<code>7777</code>，即启动参数会覆盖所有的配置文件中相应的配置。</p>
<span id="more"></span>

<h3 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h3><p>在配置文件中如果加入了一些自定义的配置, 比如<code>com.wzx.foo=bar</code>, 想要在应用中读取到该配置该怎么做呢?</p>
<ol>
<li>使用<code>@Value(&quot;$&#123;com.wzx.foo&#125;&quot;)</code> 注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFoo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.wzx.foo&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFoo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyFoo myFoo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;myFoo: &quot;</span> + myFoo.getFoo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output：</p>
<p><img src="/myfoo-bar.png" alt="控制台输出"></p>
<p>注意使用这种方式, 即使<code>bean</code>未实现<code>setter</code>也能起作用。</p>
<ol start="2">
<li>使用<code>@ConfigurationProperties(prefix = &quot;com.wzx&quot;)</code>注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;com.wzx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFoo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFoo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoo</span><span class="params">(String foo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DemoApplication 不变</span></span><br></pre></td></tr></table></figure>

<p>output: 一样</p>
<p>注意，使用这种方式需要<code>bean</code>实现<code>setter</code>方法，否则异常：</p>
<p><img src="/no-setter.png" alt="异常"></p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3>]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>rpc in cim</title>
    <url>/2021/08/08/rpc-in-cim/</url>
    <content><![CDATA[<p>最近在研究<code>cim</code>这个项目, 随便记录下. </p>
<p>项目地址 <a href="https://github.com/crossoverJie/cim">https://github.com/crossoverJie/cim</a>.</p>
<p>首先是项目中用到的<code>RPC</code>.</p>
<span id="more"></span>

<p>所谓的远程过程调用, 个人简单理解就是想调用的方法的代码不在本地，在其他机器上, 需要通过一些手段, 在本地使用其他机器的代码.</p>
<p>具体的手段又有好多种, 比如用<code>socket</code>, <code>http</code>等</p>
<p>如果是<code>socket</code>的话，一般都会基于<code>Netty</code>这个高并发网络编程框架</p>
<p>但是<code>cim</code>并没采用这个, 学习源码应该是基于<code>http</code>的, 用到的是<code>OkHttpClient</code>这个<a href="https://square.github.io/okhttp/"><code>HTTP client</code></a></p>
<p>之间了解微服务时, <code>Eureka</code>提供了下面这种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">updateStock</span><span class="params">(Stock stock)</span> &#123;</span><br><span class="line">  ResponseEntity&lt;String&gt; stringResponseEntity = restTemplate.postForEntity(<span class="string">&quot;http://stock-service/stock/v1&quot;</span>, stock, String.class);</span><br><span class="line">  <span class="keyword">return</span> stringResponseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>stock-service</code>是对应微服务的<code>spring.application.name</code>, 其他的还要微服务注册之类的, 应该也算是<code>RPC</code>吧</p>
<p>下面参照<code>cim</code>项目结构，绘制和<code>sendMsg</code>远程调用相关的架构</p>
<!-- ![项目RPC结构](architecture.png) -->

<img src="/2021/08/08/rpc-in-cim/architecture.png" class="" title="项目RPC结构">

]]></content>
      <tags>
        <tag>cim</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>search in github</title>
    <url>/2021/08/08/search-in-github/</url>
    <content><![CDATA[<h4 id="在指定用户仓库中搜索项目"><a href="#在指定用户仓库中搜索项目" class="headerlink" title="在指定用户仓库中搜索项目"></a>在指定用户仓库中搜索项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user:wangz1x cim</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>github</tag>
        <tag>skill</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>stream and character</title>
    <url>/2021/08/09/stream-and-character/</url>
    <content><![CDATA[<p><code>java</code>中有很多字节流, 字符流, 由于不经常见到(项目做少了), 记录下见到的</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p>三个构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(InputStream in)</span><br><span class="line">InputStreamReader(InputStream in, String charsetName)</span><br><span class="line">InputStreamReader(InputStream in, Charset cs) &#123;</span><br></pre></td></tr></table></figure>

<p>看到其构造方法就知道这个玩意能够指定编码</p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">&#125;</span><br><span class="line">FileReader(File file)</span><br><span class="line">FileReader(FileDescriptor fd)</span><br></pre></td></tr></table></figure>

<p>从其构造方法可以看出，这个玩意就是替我们把<code>stream</code>的创建过程省了, 但是这样只能用默认的编码了</p>
<h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p>打印流，能装挺多的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter(File file)</span><br><span class="line">PrintWriter(File file, String csn)</span><br><span class="line">PrintWriter(OutputStream out)</span><br><span class="line">PrintWriter(OutputStream out, <span class="type">boolean</span> autoFlush)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本都会包个 BufferedWriter</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName))),</span><br><span class="line">          <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintWriter(String fileName, String csn)</span><br><span class="line">PrintWriter (Writer out)</span><br><span class="line">PrintWriter(Writer out, <span class="type">boolean</span> autoFlush)</span><br></pre></td></tr></table></figure>

<p>就是不太懂为啥指定编码的那个构造方法要设为<code>private</code>, 上边和文件相关的构造方法如果指定了编码方式都会调用这个私有的构造方法</p>
<p>这里可以指定一个<code>boolean</code>表示是否自动<code>flush</code></p>
<h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader(Reader in, <span class="type">int</span> sz)</span><br><span class="line">BufferedReader(Reader in)</span><br></pre></td></tr></table></figure>

<p>给<code>Reader</code>套一层缓冲, 一般流的最外边都会套个这个?</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream(File file)</span><br><span class="line">FileOutputStream(File file, <span class="type">boolean</span> append)</span><br><span class="line">FileOutputStream(FileDescriptor fdObj)</span><br><span class="line">FileOutputStream(String name)</span><br><span class="line">FileOutputStream(String name, <span class="type">boolean</span> append)</span><br></pre></td></tr></table></figure>

<p>这里也有个<code>boolean</code>， 用来指定是否以追加的方式写入文件</p>
]]></content>
      <tags>
        <tag>stream</tag>
        <tag>character</tag>
      </tags>
  </entry>
  <entry>
    <title>WeakReference in ThreadLocalMap</title>
    <url>/2021/08/13/WeakReference-in-ThreadLocalMap/</url>
    <content><![CDATA[<p><code>ThreadLocalMap</code>提供了一种线程私有变量的机制，对于某个变量，可以做到每个线程都有自己各自的一份，不会和其他线程冲突，当然也没法访问其他线程里的该变量.</p>
<p><code>ThreadLocalMap</code>虽然名字里有个<code>Map</code>，但其实现并未实现任何接口，也没有父类，具体由<code>Entry</code>数组以及再哈希法实现.</p>
<p><code>ThreadLocalMap</code>中的<code>Entry</code>键值对继承与<code>WeakReference</code>，该弱引用指向的是<code>ThreadLocal</code>，即<code>Entry</code>中的<code>key</code>.</p>
<p><code>WeakReference</code>不会对其引用的对象造成任何影响，当其引用的对象没有其他强引用引用时，垃圾回收时就会将其回收，这里使用弱引用的考虑为:</p>
<ul>
<li><p>假设不采用弱引用, 则对于每个<code>ThreadLocal</code>，用户代码声明其时会有一个强引用，在存值时，<code>ThreadLocalMap</code>中的<code>Entry</code>也会对该<code>ThreadLocal</code>生成一个强引用; 当用户不再使用该<code>ThreadLocal</code>时，只能去掉一个强引用，<code>Entry</code>中的强引用无法被消除, 此时就没法清理</p>
</li>
<li><p>采用弱引用后，用户代码中的<code>ThreadLocal</code>置为空，则没有强引用引用该对象，该对象可以被回收. 而在<code>ThreadLocal</code>中的某些操作，发现该弱引用引用的对象为空时，就知道该<code>key</code>被回收了, 那么也能对<code>value</code>作一个回收.</p>
</li>
</ul>
<p>当然更保险的还是调用<code>ThreadLocal</code>的<code>remove</code>方法</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>WeakReference</tag>
        <tag>ThreadLocal</tag>
        <tag>ThreadLocalMap</tag>
      </tags>
  </entry>
  <entry>
    <title>方法调用</title>
    <url>/2021/08/14/method-invike/</url>
    <content><![CDATA[<p>摘自《深入理解Java虚拟机》第二版<code>P244 8.3</code>.</p>
<h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><p>方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法</p>
<p>一切方法调用在<code>Class</code>文件里存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址</p>
<p>需要在类加载，甚至到运行期间才能确定目标方法的直接引用</p>
<h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><p>在类加载的解析阶段，会将其中一部分符号引用转化为直接引用</p>
<p>前提是，方法在程序真正运行之前就有一个<strong>可确定</strong>的调用版本，并且该版本在运行期是<strong>不可变的</strong></p>
<p><code>Java</code>中符合“编译期可知，运行期不变”的要求的方法，主要有<strong>静态方法</strong>和<strong>私有方法</strong></p>
<p>对应的方法调用字节码指令为: <code>invokestatic</code>, <code>invokespecial</code></p>
<p>只要是由这两条字节码指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器方法，父类方法4类，他们在类加载时就会把符号引用解析为该方法的直接引用，又称非虚方法</p>
<p>虽然<code>final</code>方法使用<code>invokevirtual</code>调用，但明确他是非虚方法</p>
<p>解析调用一定是个静态的过程，在编译期间就完全确定</p>
<h3 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h3><h4 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h4><p>典型: 重载(overload)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>

<p><code>Human</code>称为静态类型或外观类型, <code>Man</code>称为实际类型</p>
<p>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型在编译期是可知的</p>
<p>实际类型的变化在运行期才可确定，编译器在编译程序的时候不知道一个对象的实际类型是什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line"><span class="type">Human</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">man = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">method((Man) man);</span><br><span class="line">method((Woman) man);</span><br></pre></td></tr></table></figure>

<p><strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据</strong>，因此，在编译阶段，编译器会根据参数的静态类型决定使用哪个重载版本</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，发生在编译阶段</p>
<h4 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h4><p>典型: 重写(override)</p>
<p>与<code>invokevirtual</code>指令的多台查找过程有关，该指令的运行时解析过程大致可分为：</p>
<ol>
<li><p>找到操作数栈顶第一个元素所指向对象的<strong>实际类型</strong></p>
</li>
<li><p>如果在该类型中找到了与符号引用中的描述符和简单名称都相符的方法，再对其作权限校验，通过则返回该方法的直接引用；否则<code>java.lang.IllegalAccessError</code>异常</p>
</li>
<li><p>没找到，则按照继承关系从下往上一次对各个父类进行第二步的过程</p>
</li>
<li><p>最终还是没找到,则<code>java.lang.AbstractMethodError</code>异常</p>
</li>
</ol>
<h4 id="3-单分派与多分派"><a href="#3-单分派与多分派" class="headerlink" title="3. 单分派与多分派"></a>3. 单分派与多分派</h4><p>静态分派过程中，需要查看方法接受者(调用方法的对象)和方法参数的静态类型，属于多分派</p>
<p>动态分派过程中，只依据方法接受者的实际类型，属于单分派</p>
<h4 id="4-动态分派的优化"><a href="#4-动态分派的优化" class="headerlink" title="4. 动态分派的优化"></a>4. 动态分派的优化</h4><p>由于动态分派很频繁，不优化，则方法选择过程需要运行时在类的方法元数据中搜索合适的目标方法</p>
<p>常用的优化就是在类的方法区中建立一个<strong>虚方法表</strong>(virtual method table, vtable)</p>
<p>如果某个方法在子类中没有重写，那么子类的虚方法表里边的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口</p>
<p>方法表一般在类加载的连接阶段(验证，准备，解析)进行初始化，准备了类变量的初始值后，虚拟机会把虚方法表也初始化完毕</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>圣经</tag>
      </tags>
  </entry>
  <entry>
    <title>hyperloglog</title>
    <url>/2021/09/23/hyperloglog/</url>
    <content><![CDATA[<p><code>redis</code>中的一种数据结构, 用于计数场景, 如统计某页面访问次数等</p>
<p>常规思维，可能在计数的时候就会考虑<code>Map</code>, <code>Set</code>等数据结构，将数据进行存储，实现去重的效果</p>
<p>这样做的话，计数所需要的内存空间就和数据本身息息相关</p>
<p>进一步，可能考虑使用<code>bitmap</code>等数据结构，即用位代替真实的数据，这样<code>100,000,000</code>条数据需要<code>12.5MB</code>的存储空间</p>
<p>虽然已经减少了很多，但需要的存储空间依然和数据总数息息相关</p>
<p>上述方式都是精准统计的</p>
<p>当数据量继续增加时，我们可能会想到是否一定要精准统计呢</p>
<p>能否类似与布隆过滤器那样，允许计数存在些许的误差</p>
<p><code>HyperLogLog</code>作为<code>LogLog</code>的改进，主要是降低误差</p>
<p><code>LogLog</code>的名字应该是和该算法的空间复杂度相关</p>
<p>下面对<code>redis</code>中该算法的实现作个概述</p>
<h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><ol>
<li>计算<code>hash</code>值</li>
</ol>
<p><code>hash</code>值为64位，前14位用作分桶的依据，后50位为抛硬币模拟</p>
<ol start="2">
<li>分桶</li>
</ol>
<p>一共<code>2^14=16384</code>个桶，每个桶有6个<code>bit</code>用于记录第一个1出现的位置，足够表示50</p>
<ol start="3">
<li>更新桶</li>
</ol>
<p>如果该条记录的后50位中，第一个1出现的位置更靠后，则更新该桶对应的1出现的位置</p>
<p>比如原本该桶记录值为4(表示一条xxxx1000的记录，第4位为1)，该条记录为xxxx100000, 则需要桶对应值应更新为6，否则不变</p>
<ol start="4">
<li>计数</li>
</ol>
<p>计算所有桶中元素个数的调和平均数，在乘以桶的个数和微调因子(0.72125左右)，即为最终计数值</p>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>hyperloglog</tag>
      </tags>
  </entry>
  <entry>
    <title>10月是你的背锅</title>
    <url>/2021/11/12/ISSRE-in-Wuhan/</url>
    <content><![CDATA[<p>10月底，导师牵头举办的第32届’ISSRE’会议在武汉举办，本以为能划水玩几天，结果还是要打工。</p>
<p>事情比较杂比较多，让我印象最深的就是造的几口锅了，虽然不是我来背，但还是很在意。</p>
<h3 id="1-Zoom连线"><a href="#1-Zoom连线" class="headerlink" title="1. Zoom连线"></a>1. Zoom连线</h3><p>由于有些国外专家教授无法到现场参会，基本都采用线上视频会议的形式（本地会有大的LED屏幕），在之前和国外一位大牛教授学者连线测试的时候，发现ZOOM需要有主持人授权，会议室的参会人员才能共享屏幕，之前自己试用ZOOM缺根本没想着测下共享桌面的功能，导致测试那天只能开视频说说话 &#x3D; &#x3D;</p>
<p>在正式会议期间，由于前一位教授用的Teams软件进行线上，后一位教授用的ZOOM，但由于没协调好时间，导致第二位教授干等了十几分钟！！！</p>
<h3 id="2-最佳论文投票"><a href="#2-最佳论文投票" class="headerlink" title="2. 最佳论文投票"></a>2. 最佳论文投票</h3><p>纯属之前策划时没沟通清楚，导致老师理解有误，哎，一晚上8，9个电话 &#x3D; &#x3D;</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>不过能为这个国际会议付出自己的一些汗水，还是比较值得的。</p>
<p>最后还蹭了一趟游轮晚宴，才发现夜晚的楼都这么亮。 </p>
]]></content>
      <tags>
        <tag>issre</tag>
        <tag>锅</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu中安装无线网卡驱动</title>
    <url>/2021/12/24/install-wifi-adapter-on-Ubuntu/</url>
    <content><![CDATA[<p>参考链接<a href="https://blog.csdn.net/mhlwsk/article/details/52833374">ubuntu安装无线网卡驱动（包括离线安装</a></p>
<ol>
<li>将iso镜像作为源</li>
</ol>
<p>挂载iso镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop -t iso9660 xx/ubuntu-xx.iso /media/cdrom/</span><br></pre></td></tr></table></figure>

<p>这里可能会提示没有<code>/media/cdrom</code>目录，我是手动创建了一个</p>
<p>添加源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-cdrom -m -d /media/cdrom add</span><br></pre></td></tr></table></figure>

<p>编辑源信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>只保留<code>deb cdrom xxx</code>一行，注意先备份，后边有网了再替换回去</p>
<p>更新源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从iso源中安装依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install dkms</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装驱动</li>
</ol>
<p>首先要下载对应的无线网卡驱动的deb安装包，原作中给出的链接是broadcom的，正好和我匹配，但是链接地址需要修改下，可以从<a href="http://mirrors.kernel.org/ubuntu/pool/restricted/b/bcmwl/">http://mirrors.kernel.org/ubuntu/pool/restricted/b/bcmwl/</a>这里边找，我选了最新的一个，没想到就能用，不太晓得到底需要哪一个</p>
<p>下载完后拷到ubuntu中，然后安装该包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i bcmwl-xx.deb</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>adapter</tag>
      </tags>
  </entry>
  <entry>
    <title>VideoRecord</title>
    <url>/2022/01/05/VideoRecord/</url>
    <content><![CDATA[<h1 id="记录看过的剧、动漫、电影等"><a href="#记录看过的剧、动漫、电影等" class="headerlink" title="记录看过的剧、动漫、电影等"></a>记录看过的剧、动漫、电影等</h1><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><h3 id="进击的巨人"><a href="#进击的巨人" class="headerlink" title="进击的巨人"></a>进击的巨人</h3><p><img src="/AttackOnTitan.jpeg" alt="AttackOnTitan"></p>
<span id="more"></span>

<h4 id="season2"><a href="#season2" class="headerlink" title="season2"></a>season2</h4><h4 id="season3"><a href="#season3" class="headerlink" title="season3"></a>season3</h4><h4 id="season4"><a href="#season4" class="headerlink" title="season4"></a>season4</h4><h4 id="final-season"><a href="#final-season" class="headerlink" title="final season"></a>final season</h4><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><h2 id="剧"><a href="#剧" class="headerlink" title="剧"></a>剧</h2><h3 id="浴血黑帮-Peaky-Blinders"><a href="#浴血黑帮-Peaky-Blinders" class="headerlink" title="浴血黑帮(Peaky Blinders)"></a>浴血黑帮(Peaky Blinders)</h3><h4 id="season1"><a href="#season1" class="headerlink" title="season1"></a>season1</h4><ol>
<li><p>赌马, Tommy, Arthur, Belfast, 错偷了枪, Campbell, 大哥被打, 留枪, 假杀, 卧底</p>
</li>
<li><p>抛硬币, look at me the wrong way, 误杀, 和Campbell交易失败, 和Kimb谈</p>
</li>
<li><p>结婚, 去马场, 跳舞, 当Kimb的保镖</p>
</li>
<li><p>Lee报复, 开门的小孩不是Fine - -||, Stanly Chapman, Freddie Thorne, Tommy到处谈生意, Kiss, 突如其来的婚礼, 为啥警察知道他去了她家</p>
</li>
<li><p>丹尼尔墓里边是枪？父子重逢, 大哥被爹骗了? IRA找来了, 埋伏然并卵, 挖枪, 等爹</p>
</li>
<li><p>坦白局</p>
</li>
</ol>
<h4 id="season2-1"><a href="#season2-1" class="headerlink" title="season2"></a>season2</h4><ol>
<li><p>酒吧爆炸, 被老头协迫, 进驻伦敦结果被揍, Sabini</p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>动漫</tag>
        <tag>电影</tag>
        <tag>剧</tag>
        <tag>书</tag>
      </tags>
  </entry>
  <entry>
    <title>从0打造亿级流量秒杀项目(一)</title>
    <url>/2021/08/18/record-miaosha-project/</url>
    <content><![CDATA[<h3 id="Mybatis-Generator"><a href="#Mybatis-Generator" class="headerlink" title="Mybatis Generator"></a>Mybatis Generator</h3><p>第一次知道有这么个东西，可以用来快速生成模板代码，包括与数据库对应的实体对象(DO)，Mapper接口，以及Mapper.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- springboot 打包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis Generator --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 输出详细信息? 允许移动生产的文件?--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 覆盖生成文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 定义配置文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>解决: 注解，且需要前端<code>ajax</code>请求配合参数设置</p>
<h3 id="嵌套实体"><a href="#嵌套实体" class="headerlink" title="嵌套实体"></a>嵌套实体</h3><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><h3 id="统一返回值"><a href="#统一返回值" class="headerlink" title="统一返回值"></a>统一返回值</h3><h3 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h3><p>每一层都应有对应的模型对象： VO、Model、DO</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>miaosha</tag>
      </tags>
  </entry>
</search>
